<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://youngyang.top/"/>
  <updated>2020-07-04T12:08:11.103Z</updated>
  <id>https://youngyang.top/</id>
  
  <author>
    <name>youngyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JMS（Java Message Service）</title>
    <link href="https://youngyang.top/2020/07/04/JMS%EF%BC%88Java%20Message%20Service%EF%BC%89/"/>
    <id>https://youngyang.top/2020/07/04/JMS（Java Message Service）/</id>
    <published>2020-07-04T12:11:14.749Z</published>
    <updated>2020-07-04T12:08:11.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>JMS是Java EE中的一部分，好比是盘子和点心的关系，JMS是Java EE中的额一个组成部分。<br><img src="https://img-blog.csdnimg.cn/20191217201717408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191217201745254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="JMS的组成"><a href="#JMS的组成" class="headerlink" title="JMS的组成"></a>JMS的组成</h1><p>JMS有四部分组成。分别为：</p><p>JMS privider： 实现JMS接口与规范的消息中间件，也就是我们的MQ服务器。<br>JMS producer：消息生产者，创建与发送JMS消息的客户端应用。<br>JMS consumer：消息的消费者，接受与处理JMS消息的客户端应用。<br>JMS message：JMS的消息。</p><h2 id="JMS-message的组成"><a href="#JMS-message的组成" class="headerlink" title="JMS message的组成"></a>JMS message的组成</h2><p>JMS message由三部分组成：消息头、消息头和消息属性。</p><h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>在JMS message中包含很多消息头，如下所示：<br><img src="https://img-blog.csdnimg.cn/20191217203129546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>几个比较重要的消息头如下：</p><p>1、<strong>JMSdestination</strong>：message发送的目的地，比如queue和topic。<br>2、<strong>JMSDeliveryMode</strong>:主要是指定消息的持久或者非持久化。<br><img src="https://img-blog.csdnimg.cn/20191217203559742.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191217203319377.png" alt="在这里插入图片描述"><br>3、JMSExpiration：消息存活时间。<br><img src="https://img-blog.csdnimg.cn/20191217203702484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4、JMSPriority：消息优先级。<br><img src="https://img-blog.csdnimg.cn/20191217203801226.png" alt="在这里插入图片描述"></p><p>5、JMSMessageID：唯一识别每个消息的标志，由MQ产生。</p><h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><p>消息体顾名思义作用就是<strong>封装具体消息的数据</strong>。<br>那么消息的数据到底有多少种格式呢，有五种。其中最常用的为<strong>TextMessage</strong>和<strong>MapMessage</strong>两种。<br>1、TextMessage：普通的字符串消息，包含一个string。<br>2、MapMessage：一个map类型的消息，key为stirng类型，而value 为<strong>java的基本类型</strong>。如下：<br><img src="https://img-blog.csdnimg.cn/20191217204358515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果MapMessage中的value放的是char类型数据，则创键方式如下所示：<br><img src="https://img-blog.csdnimg.cn/20191217204259849.png" alt="在这里插入图片描述"><br>3、BytesMessage：二进制数组消息，包含一个byte[]。<br>4、StreamMessage：java数据流消息，用标准流操作来顺序的填充或读取。<br>5、ObjectMessage：对象消息，包含一个可序列化的java对象。</p><p><strong><em>注意：</em></strong><br>    发送和接受的消息体类型必须是一致对应的。如发送的是TextMessage，则接收方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> onMessage(Message message) &#123;</span><br><span class="line">               <span class="keyword">if</span> (null != message &amp;&amp; message instanceof TextMessage) &#123;</span><br><span class="line">                   TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       System.out.println(<span class="string">"msg-----"</span> + textMessage.getText());</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h3 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h3><p>如果需要使用消息头以外的值，那么可以使用消息属性（一种加强型的api），可用于识别/去重/重点标注等操作。<br><img src="https://img-blog.csdnimg.cn/20191217211429786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="JMS的可靠性"><a href="#JMS的可靠性" class="headerlink" title="JMS的可靠性"></a>JMS的可靠性</h1><h2 id="persistent：持久性"><a href="#persistent：持久性" class="headerlink" title="persistent：持久性"></a>persistent：持久性</h2><h3 id="基于队列queue"><a href="#基于队列queue" class="headerlink" title="基于队列queue"></a>基于队列queue</h3><p>1、非持久化：<br><img src="https://img-blog.csdnimg.cn/20191217212023194.png" alt="在这里插入图片描述"><br>2、持久化<br><img src="https://img-blog.csdnimg.cn/20191217212047638.png" alt="在这里插入图片描述"><br>3、默认情况下ActiveMQ是持久化的，即向MQ中发送消息之后即使MQ服务器宕机挂掉然后重新启动之后，消费者也可以从MQ中取到原来发送的消息；而如果使用上述方法设置消息非持久化，那么在重新启动之后就不能取到原来的数据，原来的数据就会被丢失。</p><h3 id="基于主题topic发布订阅"><a href="#基于主题topic发布订阅" class="headerlink" title="基于主题topic发布订阅"></a>基于主题topic发布订阅</h3><p> <strong>持久的发布主题生产者：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.durable;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ</span></span><br><span class="line"><span class="comment"> * JMS（Java Message Service）的生产者编码</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurableJmsProduceTopic</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String ACTIVE_URL = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String TOPIC_NAME = <span class="string">"topic-01"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接工厂，按照指定的url地址，采用默认用户名和密码</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVE_URL);</span><br><span class="line">        <span class="comment">//通过连接工厂创建连接</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建回话session，两个参数：事务和签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//常见目的地（队列或queue者主题topic）</span></span><br><span class="line">        Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">        <span class="comment">//创建生产者</span></span><br><span class="line">        MessageProducer producer = session.createProducer(topic);</span><br><span class="line">        <span class="comment">//设置持久化的topic生产者</span></span><br><span class="line">        producer.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br><span class="line">        connection.start();</span><br><span class="line">        <span class="comment">//使用MessageProducer生产3条消息发送到MQ的队列里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建消息</span></span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">"msg------"</span> + i);</span><br><span class="line">            <span class="comment">//通过生产者MessageProducer发送给MQ</span></span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>持久的发布主题消费者：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.durable;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ</span></span><br><span class="line"><span class="comment"> * JMS（Java Message Service）的生产者编码</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurableJmsConsumerTopic</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String ACTIVEMQ_URL = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String TOPIC_NAME = <span class="string">"topic-01"</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JMSException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">"订阅者z3"</span>);</span><br><span class="line">        ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">        Connection connection = factory.createConnection();</span><br><span class="line">        connection.setClientID(<span class="string">"z3"</span>);</span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">        TopicSubscriber durableSubscriber = session.createDurableSubscriber(topic, <span class="string">"remark.."</span>);</span><br><span class="line"></span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        Message message = durableSubscriber.receive();</span><br><span class="line">        <span class="keyword">while</span> (null != message) &#123;</span><br><span class="line">            TextMessage textMessage = (TextMessage) message;</span><br><span class="line">            System.out.println(textMessage.getText());</span><br><span class="line">            message = durableSubscriber.receive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>持久化的表现：</strong><br>持久性的订阅者首先启动进行订阅，就算中途离线关掉了系统，也会在下次连接上线后收到消息。</p><h2 id="transaction：事务"><a href="#transaction：事务" class="headerlink" title="transaction：事务"></a>transaction：事务</h2><p>无论是在生产者还是消费者的时候都要创建一个session会话，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><p>其中第一个参数就是事务，false代表关闭事务，true代表使用事务。</p><p>如果生产者和消费者都设置为false，那么在producer.send(message)之后，消息就会直接传到队列中，consumer.receive之后消息就会直接取出来；<br>如果生产者和消费者都设置为true，那么必须手动session.commit()进行提交，出错之候可以session.rollback()。如果不commit，那么：producer.send()之后，消息不会发送到消息队列中，并且因为没有commit，consumer.receive()会多次消费同一条消息。</p><h2 id="acknowledge-签收模式"><a href="#acknowledge-签收模式" class="headerlink" title="acknowledge 签收模式"></a>acknowledge 签收模式</h2><p>签收模式的效果如何与事务的开启与否有着密切的关系，主要常用的签收模式包括两种：自动签收AUTO_ACKNOWLEDGE和手动签收CLIENT_ACKNOWLEDGE。</p><p><strong>1、在事务为false的时候，签收模式为：AUTO_ACKNOWLEDGE</strong><br>在此模式下，为自动签收。不用任何操作就会签收，不会出现二次消费的情况<br><strong>2、在事务为false的时候，签收模式为：CLIENT_ACKNOWLEDGE</strong><br>在此模式下消息不会自动签收，必须使用message.acknowledge()手动对消息进行签收，否则会出现二次消费。<br><strong>3、在事务为true的时候，签收模式为：AUTO_ACKNOWLEDGE</strong><br>在此模式下，并且调用session.commit()进行事务提交的情况下为自动签收。若事务不提交，则会出现二次消费的情况。<br><strong>4、在事务为true的时候，签收模式为：CLIENT_ACKNOWLEDGE</strong><br>在此模式下，并且调用session.commit()进行事务提交的情况下为手动签收。若事务不提交，则会出现二次消费的情况。即使message.acknowledge()进行消息手动签收也会出现二次消费。</p><p><strong>总结：</strong><br>在事务关闭的情况下，消息是否自动签收取决于签收模式，如AUTO_ACKNOWLEDGE或者CLIENT_ACKNOWLEDGE；在事务开启的情况下，并且调用commit方法，则无论签收模式是什么<strong>都会</strong>自动提交，在事务开启的情况下，若不调用commit方法，则无论签收模式是什么<strong>都不会</strong>自动提交。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="JMS点对点模式总结"><a href="#JMS点对点模式总结" class="headerlink" title="JMS点对点模式总结"></a>JMS点对点模式总结</h2><p><img src="https://img-blog.csdnimg.cn/20191218111916699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="JMS发布订阅模式总结"><a href="#JMS发布订阅模式总结" class="headerlink" title="JMS发布订阅模式总结"></a>JMS发布订阅模式总结</h2><p><img src="https://img-blog.csdnimg.cn/20191218112010364.png" alt="在这里插入图片描述"></p><h3 id="非持久订阅"><a href="#非持久订阅" class="headerlink" title="非持久订阅"></a>非持久订阅</h3><p><img src="https://img-blog.csdnimg.cn/20191218112039889.png" alt="在这里插入图片描述"></p><h3 id="持久订阅"><a href="#持久订阅" class="headerlink" title="持久订阅"></a>持久订阅</h3><p><img src="https://img-blog.csdnimg.cn/20191218112054756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="用哪个"><a href="#用哪个" class="headerlink" title="用哪个"></a>用哪个</h3><p>当所有消息必须被接受，则用持久订阅。当丢失消息能够被容忍，则用非持久订阅。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h1&gt;&lt;p&gt;JMS是Java EE中的一部分，好比是盘子和点心的关系，JMS是Java EE中的额一个组成部分。&lt;br&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一致性哈希</title>
    <link href="https://youngyang.top/2020/07/04/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    <id>https://youngyang.top/2020/07/04/一致性哈希/</id>
    <published>2020-07-04T12:11:14.743Z</published>
    <updated>2020-07-04T12:08:08.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>伴随着系统流量的增大,出现了应用集群。在 Redis 中为了保证 Redis 的高可用也为 Redis 搭建了集群对数据进行分槽存放。在 Mysql数据库要存储的量达到一个很高的地步的时候,我们会对数据库进行分库分表操作。OK，到这儿先假设我们不知道什么是集群、什么是分库分表,我们先来看一个数据库水平切分演变的例子:</p><blockquote><p>假设我们的系统中有一张会员表 customer_info, 我们的系统刚开始无人问津,我们在一个单个的数据库中放这张表，所有的会员记录都插入到这个数据库的这张表中，这没什么问题，是一个很正常且合理的操作。某段时间，我们的系统突然火爆了起来，注册会员激增，达到了千万级别并且还在快速增长，这时候所有的用户请求数据都会请求这张表，毫无疑问数据库的压力很大，于是可能会经常发生宕机事件，给系统造成了很大影响。为了解决这件事情，我们将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据不同。 这样做能够有效的缓解单机数据库的压力和系统的性能瓶颈。</p></blockquote><p>看完了这个例子,我们对水平拆分数据库有了一个大致的印象，其实就是把很多的数据按照一定的规则存放在不同的服务器上，然后查找的时候能够根据存放的时候的规则去找到前面存放的数据。那么我们要说的一致性哈希算法，其实就是解决了这里面的 存取规则 的问题，有了这个一致性哈希算法，我们能够准确的知道我们要取的数据落在哪个机器的哪个数据库中。</p><h1 id="简单哈希"><a href="#简单哈希" class="headerlink" title="简单哈希"></a>简单哈希</h1><p>还是上面水平拆分数据库的例子,假设我们现在不知道什么一致性哈希什么集群分槽，就让我们自己想的话，我们可以很容器的想到 java 中的 HashMap 的原理，它通过计算了一个 key 的哈希值，然后拿这个哈希值对底层数组取模就得到了一个哈希桶，如果数据存在的话，就一定在这个哈希桶里，否则就不存在。类似的可以想到，假设我们的 customer_info 我们可以按照用户id去分库分表，假设此时存在水平的三个库表,如下,我们分别称之为 节点D1,节点D2,节点D0</p><p>机器 ip    数据库    数据表</p><blockquote><p>127.0.0.1    customer    customer_info<br>127.0.0.2    customer    customer_info<br>127.0.0.3    customer    customer_info</p></blockquote><p>分库分表的时候,用户 A 的记录落在了 D1 机器，用户 B 的记录落在了 D2 机器，用户 C 的机器落在了 D0 机器上，用户 A 要存在哪条数据库上的计算过程是用户 A 的会员 id 的哈希值对 3 取模，因为现在只有 3 台机器，伪代码: A_id.hash() % / 3，用户 B 和用户 C 依次类推。如下图所示<br><img src="https://img-blog.csdnimg.cn/20200629231022751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="image.png"><br>这好像很方便的解决了存取规则的问题，我们来分析一波:<br>假设我们的系统用户量又激增了，我们就需要再加一些机器,此时我们再计算哈希值的时候，取模不再是对 3 取模了，而是对 4 进行取模了，之前 A_id.hash() % / 3 = 1,而现在 A_id.hash() % / 4 = ? 这个值很大概率不会是 1，所以这就会出现用户明明存在记录但是却查不到的情况，这就问题很大了，如果要解决这个问题只能在机器节点数量变化的时候对数据重新哈希，这代价就有点大了。所以，我们需要想办法让这种情况不发生，这种情况发生的根本是哈希算法本身的特性导致的，直接使用取模的话这是无法避免的。所以就有了一致性哈希</p><h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><p>上面通过数据库的例子介绍了哈希算法，然后也分析了它的劣势,当机器数量发生变动的时候，几乎所有的数据都会移动(不移动的应该是运气比较好吧前后取模都是同一个值)，这个代价很大。此时的问题从水平如何拆分变成了，当增加或者删除节点时，对于大多数记录，保证原来分配到的某个节点，现在仍然应该分配到那个节点，将数据迁移量的降到最低，这就是一致性哈希要做的事情。在这里我们不指定是数据库还是什么，反正都是分布式存储节点。</p><h2 id="一致性hash介绍"><a href="#一致性hash介绍" class="headerlink" title="一致性hash介绍"></a>一致性hash介绍</h2><p>一致性 Hash 算法也是使用取模的思想，只是，刚才描述的取模法是对节点数量进行取模，而一致性Hash算法是对 2^32 取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下，从 0 ~ 2^32-1 代表的分别是一个个的节点,这个环也叫哈希环<br><img src="https://img-blog.csdnimg.cn/20200629231122911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="image.png"><br>然后我们将我们的节点进行一次哈希，按照一定的规则，比如按照 ip 地址的哈希值，让节点落在哈希环上。比如此时我们可能得到了如下图的环:</p><p><img src="https://img-blog.csdnimg.cn/20200629231139440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="image.png"><br>然后就是需要通过数据 key 找到对应的服务器然后存储了，我们约定,通过数据 key 的哈希值落在哈希环上的节点，如果命中了机器节点就落在这个机器上，否则落在顺时针直到碰到第一个机器。如下图所示 : A 的哈希值落在了 D2 节点的前面，往下找落在了 D2 机器上，D的哈希值 在 D1 节点的前面，往下找到了 D1 机器，B的哈希值刚好落在了D1 节点上，依次<del>~</del></p><p><img src="https://img-blog.csdnimg.cn/20200629231154875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="image.png"></p><h2 id="一致性hash分析"><a href="#一致性hash分析" class="headerlink" title="一致性hash分析"></a>一致性hash分析</h2><p>一致性哈希主要就是解决当机器减少或增加的时候，大面积的数据重新哈希的问题，主要从下面 2 个方向去考虑的，当节点宕机时，数据记录会被定位到下一个节点上，当新增节点的时候 ，相关区间内的数据记录就需要重新哈希。</p><h3 id="某节点宕机"><a href="#某节点宕机" class="headerlink" title="某节点宕机"></a>某节点宕机</h3><p>我们假设上图中的 节点 D2 因为一些原因宕机了,可以看到，只有数据 A 的记录需要重新重新定位存储到节点 D1 上，因为 D1 是 D2 的下一个节点，其它的数据都没有被影响到，此时被影响的仅仅是 图中的 D0-D2 这段区间的记录，也就是之前落在 D2 上的数据现在都要落到 D1 上面了。如下图<img src="https://img-blog.csdnimg.cn/20200629231339864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="节点宕机"></p><h3 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h3><p>我们假设我们需要增加一台机器，也就是增加一个节点D4，如下图所示，这个节点落在 D2-D1 之间，按照上述的哈希环上的哈希值落在节点的规则，那么此时之前落在 D2 到 D4 之间的数据都需要重新定位到新的节点上面了，而其它位置的数据是不需要有改变的。<br><img src="https://img-blog.csdnimg.cn/20200629231356294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="新增节点"></p><h2 id="一致性哈希的数据倾斜问题"><a href="#一致性哈希的数据倾斜问题" class="headerlink" title="一致性哈希的数据倾斜问题"></a>一致性哈希的数据倾斜问题</h2><p>一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题。比如只有 2 台机器，这 2 台机器离的很近，那么顺时针第一个机器节点上将存在大量的数据，第二个机器节点上数据会很少。如下图所示，D0 机器承载了绝大多数的数据<br><img src="https://img-blog.csdnimg.cn/20200629231447277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="虚拟节点解决数据倾斜问题"><a href="#虚拟节点解决数据倾斜问题" class="headerlink" title="虚拟节点解决数据倾斜问题"></a>虚拟节点解决数据倾斜问题</h2><p>为了避免出现数据倾斜问题，一致性 Hash 算法引入了虚拟节点的机制，也就是每个机器节点会进行多次哈希，最终每个机器节点在哈希环上会有多个虚拟节点存在，使用这种方式来大大削弱甚至避免数据倾斜问题。同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“D1#1”、“D1#2”、“D1#3”三个虚拟节点的数据均定位到 D1 上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。这也是 Dubbo 负载均衡中有一种一致性哈希负载均衡的实现思想。<br><img src="https://img-blog.csdnimg.cn/20200629231459476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="一致性哈希的应用案例"><a href="#一致性哈希的应用案例" class="headerlink" title="一致性哈希的应用案例"></a>一致性哈希的应用案例</h2><p>一致性哈希用到的地方很多，特别是中间件里面，比如 Dubbo 的负载均衡也有一种策略是一致性哈希策略，使用的就是虚拟节点实现的。Redis 集群中也用到了相关思想但是没有用它而是根据实际情况改进了一下。而对于存储数据的节点水平切分的时候它的作用就更不可代替了。and so on···</p><h1 id="Redis-集群分槽的实现"><a href="#Redis-集群分槽的实现" class="headerlink" title="Redis 集群分槽的实现"></a>Redis 集群分槽的实现</h1><p>Redis 集群并没有直接使用一致性哈希，而是使用了哈希槽 （slot） 的概念，Redis 没有直接使用哈希算法 hash()，而是使用了crc16校验算法。槽位其实就是一个个的空间的单位。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布，可能会产生数据倾斜问题。而 Redis 的槽位空间是自定义分配的，类似于Windows盘分区的概念。这种分区是可以自定义大小，自定义位置的。Redis 集群包含了 16384 个哈希槽，每个 Key 经过计算后会落在一个具体的槽位上，而槽位具体在哪个机器上是用户自己根据自己机器的情况配置的，机器硬盘小的可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。<br>另外在容错性和扩展性上与一致性哈希一样，都是对受影响的数据进行转移而不影响其它的数据。而哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。</p><p>需要注意的是，对于槽位的转移和分派，Redis集群是不会自动进行的，而是需要人工配置的。所以Redis集群的高可用是依赖于节点的主从复制与主从间的自动故障转移。<br><img src="https://img-blog.csdnimg.cn/20200629231814902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;伴随着系统流量的增大,出现了应用集群。在 Redis 中为了保证 Redis 的高可用也为 Redis 搭建了集群对数据进行分槽存放。在 M
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一文读懂HashMap</title>
    <link href="https://youngyang.top/2020/07/04/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82HashMap/"/>
    <id>https://youngyang.top/2020/07/04/一文读懂HashMap/</id>
    <published>2020-07-04T12:11:14.733Z</published>
    <updated>2020-07-04T12:08:10.133Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>本文准备从以下几个方面去讲解HashMap：<br>1）HashMap源码详细分析<br>2）HashMap为什么是线程不安全的？<br>3）HashMap和HashTable的区别<br>4）1.7和1.8的HashMap实现区别总结</em></strong></p><h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>让我们先从构造函数说起，HashMap有四个构造方法，别慌。</p><h3 id="无参：HashMap"><a href="#无参：HashMap" class="headerlink" title="无参：HashMap()"></a>无参：HashMap()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.无参构造方法、</span></span><br><span class="line">   <span class="comment">// 构造一个空的HashMap，初始容量为16，负载因子为0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>无参构造方法就没什么好说的了。</p><h3 id="传容量：-HashMap-int-initialCapacity"><a href="#传容量：-HashMap-int-initialCapacity" class="headerlink" title="传容量： HashMap(int initialCapacity)"></a>传容量： HashMap(int initialCapacity)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.构造一个初始容量为initialCapacity，负载因子为0.75的空的HashMap，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HashMap(int initialCapacity) 这个构造方法调用了3中的构造方法。</p><h3 id="传容量和负载因子：HashMap-int-initialCapacity-float-loadFactor"><a href="#传容量和负载因子：HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="传容量和负载因子：HashMap(int initialCapacity, float loadFactor)"></a>传容量和负载因子：HashMap(int initialCapacity, float loadFactor)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个空的初始容量为initialCapacity，负载因子为loadFactor的HashMap</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//最大容量</span></span><br><span class="line">   <span class="comment">//static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span></span><br></pre></td></tr></table></figure><p>当指定的<strong>初始容量&lt; 0时抛出IllegalArgumentException</strong>异常；当指定的<strong>初始容量&gt; MAXIMUM_CAPACITY时，就让初始容量 = MAXIMUM_CAPACITY</strong>；<br>当<strong>负载因子小于0或者不是数字时，抛出IllegalArgumentException异常</strong>。</p><p>设定threshold。 这个threshold = capacity * load factor 。当HashMap的size到了threshold时，就要进行resize，也就是扩容。</p><p>tableSizeFor()的主要功能是<strong>返回一个比给定整数大且最接近的2的幂次方整数%</strong>，如给定10，返回2的4次方16。</p><p>我们进入tableSizeFor(int cap)的源码中看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Returns a power of two size for the given target capacity.</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> final <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong><em>note</em></strong>： <em>HashMap要求容量必须是2的幂</em>。</p><p>首先，int n = cap -1是为了防止cap已经是2的幂时，执行完后面的几条无符号右移操作之后，返回的capacity是这个cap的2倍，因为cap已经是2的幂了，就已经满足条件了。 如果不懂可以往下看完几个无符号移位后再回来看。</p><p>•如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是1（最后有个n+1的操作）。这里只讨论n不等于0的情况。</p><p>以16位为例，假设开始时 n 为 0000 1xxx xxxx xxxx （x代表不关心0还是1）</p><p>•第一次右移 n |= n &gt;&gt;&gt; 1;</p><p>由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，变为0000 11xx xxxx xxxx 。</p><p>•第二次右移 n |= n &gt;&gt;&gt; 2;</p><p>注意，这个n已经经过了n |= n &gt;&gt;&gt; 1; 操作。此时n为0000 11xx xxxx xxxx ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如0000 1111 xxxx xxxx 。</p><p>•第三次右移 n |= n &gt;&gt;&gt; 4;</p><p>这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中会有8个连续的1。如0000 1111 1111 xxxx 。</p><p>第。。。，你还忍心让我继续推么？相信聪明的你已经想出来了，容量最大也就是32位的正数，所以最后一次 n |= n &gt;&gt;&gt; 16; 可以保证最高位后面的全部置为1。当然如果是32个1的话，此时超出了MAXIMUM_CAPACITY ，所以取值到 MAXIMUM_CAPACITY 。</p><p>使用如下例子可以清晰看到：<br><img src="https://img-blog.csdnimg.cn/20200327161335685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>注意，得到的这个capacity却被赋值给了threshold。 </p><p>这里我和这篇博客的博主开始的想法一样，认为应该这么写：this.threshold = tableSizeFor(initialCapacity) * this.loadFactor; 因为这样子才符合threshold的定义：threshold = capacity * load factor 。但是，请注意，在构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算 。</p><h3 id="为什么容量必须是2的幂"><a href="#为什么容量必须是2的幂" class="headerlink" title="为什么容量必须是2的幂"></a>为什么容量必须是2的幂</h3><p>此处讲解一下为什么hashmap的容量必须为2的幂。</p><p>我个人认为主要有两方面：提高hashmap的效率，使hash散列的均匀分布。</p><p>HashMap的容量为什么是2的n次幂，和这个(n - 1) &amp; hash的计算方法有着千丝万缕的关系，符号&amp;是按位与的计算，这是位运算，计算机能直接运算，特别高效。<br>Hash 值的<br>范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应<br>用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之<br>前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash ”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（<strong>也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；</strong>）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</p><p>计算数组的索引使用的是与的方式，只有用1与才能使得hash更加均匀，如果是0则会大大加大的hash冲突的概率。因为0与上任何值都为0，而1与上1为1，与0为0，减小了hash冲突的概率。</p><p>终上所述，HashMap计算添加元素的位置时，使用的位运算，这是特别高效的运算；另外，HashMap的初始容量是2的n次幂，扩容也是2倍的形式进行扩容，是因为容量是2的n次幂，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低！</p><h3 id="传map：HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#传map：HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="传map：HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>传map：HashMap(Map&lt;? extends K, ? extends V&gt; m)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 构造一个和指定Map有相同mappings的HashMap，初始容量能充足的容下指定的Map,负载因子为0.75</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>套路，直接看 putMapEntries(m,false) 。源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将m的所有元素存入本HashMap实例中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function">final <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//得到 m 中元素的个数</span></span><br><span class="line">     <span class="keyword">int</span> s = m.size();</span><br><span class="line">     <span class="comment">//当 m 中有元素时，则需将map中元素放入本HashMap实例。</span></span><br><span class="line">     <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 判断table是否已经初始化，如果未初始化，则先初始化一些变量。（table初始化是在put时）</span></span><br><span class="line">         <span class="keyword">if</span> (table == null) &#123; <span class="comment">// pre-size</span></span><br><span class="line"> <span class="comment">// 根据待插入的map 的 size 计算要创建的　HashMap 的容量。</span></span><br><span class="line">             <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">             <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">             <span class="comment">// 把要创建的　HashMap 的容量存在　threshold　中</span></span><br><span class="line">             <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                 threshold = tableSizeFor(t);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果table初始化过，因为别的函数也会调用它，所以有可能HashMap已经被初始化过了。</span></span><br><span class="line">         <span class="comment">// 判断待插入的　map 的 size,若　size 大于　threshold，则先进行　resize()，进行扩容</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">             resize();</span><br><span class="line">         <span class="comment">//然后就开始遍历 带插入的 map ，将每一个 &lt;Key ,Value&gt; 插入到本HashMap实例。</span></span><br><span class="line">         <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">             K key = e.getKey();</span><br><span class="line">             V value = e.getValue();</span><br><span class="line">             <span class="comment">// put(K,V)也是调用　putVal　函数进行元素的插入</span></span><br><span class="line">             putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>来到putMapEntries函数中，如果table为null，那么这时就设置合适的threshold，如果不为空并且指定的map的size&gt;threshold，那么就resize()。然后把指定的map的所有Key，Value，通过putVal添加到我们创建的新的map中。</p><h2 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h2><p>hashmap的put方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>put方法底层是调用的putVal方法。<br>介绍putVal方法前，说一下HashMap的几个重要的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">    * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">    * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">    * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//实际存储key，value的数组，只不过key，value被封装成Node了</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">    * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">    * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">    * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">    * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">   <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">   <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">   <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">   <span class="comment">//因为 tableSizeFor(int) 返回值给了threshold</span></span><br><span class="line">   <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><strong>其实就是哈希表。HashMap使用链表法避免哈希冲突（相同hash值），当链表长度大于TREEIFY_THRESHOLD（默认为8）时，将链表转换为红黑树，当然小于UNTREEIFY_THRESHOLD（默认为6）时，又会转回链表以达到性能均衡。</strong></p><p> 我们看一张HashMap的数据结构（<strong>数组+链表+红黑树</strong> ）就更能理解table了：<br><img src="https://img-blog.csdnimg.cn/2020032716181136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>putVal中传入了个hash(key)，那我们就先来看看hash(key):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** key 的 hash值的计算是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</span></span><br><span class="line"><span class="comment">* 主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候</span></span><br><span class="line"><span class="comment">* 也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>异或运算：(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</p><p>原 来 的 hashCode : 1111 1111 1111 1111 0100 1100 0000 1010<br>移位后的hashCode: 0000 0000 0000 0000 1111 1111 1111 1111<br>进行异或运算 结果：1111 1111 1111 1111 1011 0011 1111 0101</p><p>这样做的好处是，可以将hashcode高位和低位的值进行混合做异或运算，而且混合后，低位的信息中加入了高位的信息，这样高位的信息被变相的保留了下来。掺杂的元素多了，那么生成的hash值的随机性会增大。</p><p>刚才我们漏掉了resize()和putVal() 两个函数，现在我们按顺序分析一波：</p><p>首先resize() ,先看一下哪些函数调用了resize()，从而在整体上有个概念：<br><img src="https://img-blog.csdnimg.cn/20200327161938680.png" alt="在这里插入图片描述"><br>接下来上源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">// 保存当前table</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">// 保存当前table的容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">// 保存当前阈值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="comment">// 初始化新的table容量和阈值 </span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. resize（）函数在size　&gt; threshold时被调用。oldCap大于 0 代表原来的 table 表非空，</span></span><br><span class="line"><span class="comment">           oldCap 为原表的大小，oldThr（threshold） 为 oldCap × load_factor</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 若旧table容量已超过最大容量，更新阈值为Integer.MAX_VALUE（最大整形值），这样以后就不会自动扩容了。</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 容量翻倍，使用左移，效率更高</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">// 阈值翻倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        2. resize（）函数在table为空被调用。oldCap 小于等于 0 且 oldThr 大于0，代表用户创建了一个 HashMap，但是使用的构造函数为      </span></span><br><span class="line"><span class="comment">           HashMap(int initialCapacity, float loadFactor) 或 HashMap(int initialCapacity)</span></span><br><span class="line"><span class="comment">           或 HashMap(Map&lt;? extends K, ? extends V&gt; m)，导致 oldTab 为 null，oldCap 为0， oldThr 为用户指定的 HashMap的初始容量。</span></span><br><span class="line"><span class="comment">    　　*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">//当table没初始化时，threshold持有初始容量。还记得threshold = tableSizeFor(t)么;</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. resize（）函数在table为空被调用。oldCap 小于等于 0 且 oldThr 等于0，用户调用 HashMap()构造函数创建的　HashMap，所有值均采用默认值，oldTab（Table）表为空，oldCap为0，oldThr等于0，</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新阈值为0</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        <span class="comment">// 初始化table</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 把 oldTab 中的节点　reHash 到　newTab 中去</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 若节点是单个节点，直接在 newTab　中进行重定位</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">// 若节点是　TreeNode 节点，要进行 红黑树的 rehash　操作</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">// 若是链表，进行链表的 rehash　操作</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="comment">// 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割（代码后有图解，可以回过头再来看），分成两个不同的链表，完成rehash</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 根据算法　e.hash &amp; oldCap 判断节点位置rehash　后是否发生改变</span></span><br><span class="line">                            <span class="comment">//最高位==0，这是索引不变的链表。</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; </span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//最高位==1 （这是索引发生改变的链表）</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;  </span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;  <span class="comment">// 原bucket位置的尾指针不为空(即还有node)  </span></span><br><span class="line">                            loTail.next = <span class="keyword">null</span>; <span class="comment">// 链表最后得有个null</span></span><br><span class="line">                            newTab[j] = loHead; <span class="comment">// 链表头指针放在新桶的相同下标(j)处</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="comment">// rehash　后节点新的位置一定为原来基础上加上　oldCap，具体解释看下图</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引自美团点评技术博客。我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。<br><img src="https://img-blog.csdnimg.cn/20200327162113978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="hashMap 1.8 哈希算法例图1"><br>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><img src="https://img-blog.csdnimg.cn/20200327162133375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="hashMap 1.8 哈希算法例图2"><br>因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图 ：</p><p><img src="https://img-blog.csdnimg.cn/20200327162302493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>什么时候扩容：通过HashMap源码可以看到是在put操作时，即向容器中添加元素时，判断当前容器中元素的个数是否达到阈值（当前数组长度乘以加载因子的值）的时候，就要自动扩容了。</p><p>扩容(resize)：其实就是重新计算容量；而这个扩容是计算出所需容器的大小之后重新定义一个新的容器，将原来容器中的元素放入其中。</p><p>resize()告一段落，接下来看 putVal() 。</p><p>上源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现put和相关方法。</span></span><br><span class="line">    <span class="function">final V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, boolean onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   boolean evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//如果table为空或者长度为0，则resize()</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == null || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">//确定插入table的位置，算法是(n - 1) &amp; hash，在n为2的幂时，相当于取摸操作。</span></span><br><span class="line">        <span class="comment">////找到key值对应的槽并且是第一个，直接加入</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == null)</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        <span class="comment">//在table的i位置发生碰撞，有两种情况，1、key值是一样的，替换value值，</span></span><br><span class="line">        <span class="comment">//2、key值不一样的有两种处理方式：2.1、存储在i位置的链表；2.2、存储在红黑树中</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//第一个node的hash值即为要加入元素的hash</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//2.2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p instanceof TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">//2.1</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不是TreeNode,即为链表,遍历链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">///链表的尾端也没有找到key值相同的节点，则生成一个新的Node,</span></span><br><span class="line">                <span class="comment">//并且判断链表的节点个数是不是到达转换成红黑树的上界达到，则转换成红黑树。</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == null) &#123;</span><br><span class="line">                         <span class="comment">// 创建链表节点并插入尾部</span></span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        <span class="comment">////超过了链表的设置长度8就转换成红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果e不为空就替换旧的oldValue值</span></span><br><span class="line">            <span class="keyword">if</span> (e != null) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注：hash 冲突发生的几种情况：<br>1.两节点key 值相同（hash值一定相同），导致冲突；<br>2.两节点key 值不同，由于 hash 函数的局限性导致hash 值相同，冲突；<br>3.两节点key 值不同，hash 值不同，但 hash 值对数组长度取模后相同，冲突；</p><p>相比put方法，get方法就比较简单，这里就不说了。</p><h1 id="1-7和1-8的HashMap的不同点"><a href="#1-7和1-8的HashMap的不同点" class="headerlink" title="1.7和1.8的HashMap的不同点"></a>1.7和1.8的HashMap的不同点</h1><p>（1）JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法就是能够提高插入的效率，但是也会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。</p><p>（2）扩容后数据存储位置的计算方式也不一样：<br>1.在JDK1.7的时候是直接用hash值和需要扩容的二进制数进行&amp;（这里就是为什么扩容的时候为啥一定必须是2的多少次幂的原因所在，因为如果只有2的n次幂的情况时最后一位二进制数才一定是1，这样能最大程度减少hash碰撞）（hash值 &amp; length-1） 。<br>2.而在JDK1.8的时候直接用了JDK1.7的时候计算的规律，也就是扩容前的原始位置+扩容的大小值=JDK1.8的计算方式，而不再是JDK1.7的那种异或的方法。但是这种方式就相当于只需要判断Hash值的新增参与运算的位是0还是1就直接迅速计算出了扩容后的储存方式。<br>（3）JDK1.7的时候使用的是数组+ 单链表的数据结构。但是在JDK1.8及之后时，使用的是数组+链表+红黑树的数据结构（当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O（N）变成O（logN）提高了效率）。</p><h1 id="HashMap为什么是线程不安全的？"><a href="#HashMap为什么是线程不安全的？" class="headerlink" title="HashMap为什么是线程不安全的？"></a>HashMap为什么是线程不安全的？</h1><p>HashMap 在并发时可能出现的问题主要是两方面：<br>1.put的时候导致的多线程数据不一致<br> 比如有两个线程A和B，首先A希望插入一个key-value对到HashMap中，首先计算记录所要落到的 hash桶的索引坐标，然后获取到该桶里面的链表头结点，此时线程A的时间片用完了，而此时线程B被调度得以执行，和线程A一样执行，只不过线程B成功将记录插到了桶里面，假设线程A插入的记录计算出来的 hash桶索引和线程B要插入的记录计算出来的 hash桶索引是一样的，那么当线程B成功插入之后，线程A再次被调度运行时，它依然持有过期的链表头但是它对此一无所知，以至于它认为它应该这样做，如此一来就覆盖了线程B插入的记录，这样线程B插入的记录就凭空消失了，造成了数据不一致的行为。<br>2.resize而引起死循环<br> 这种情况发生在HashMap自动扩容时，当2个线程同时检测到元素个数超过 数组大小 × 负载因子。此时2个线程会在put()方法中调用了resize()，两个线程同时修改一个链表结构会产生一个循环链表（JDK1.7中，会出现resize前后元素顺序倒置的情况）。接下来再想通过get()获取某一个元素，就会出现死循环。</p><h1 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h1><p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p><p>1、HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</p><p>2、HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</p><p>3.、另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p><p>4、由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</p><p>5、HashMap不能保证随着时间的推移Map中的元素次序是不变的。</p><p>需要注意的重要术语：</p><p>1.sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。</p><p>2.Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。</p><p>3.结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p><p>HashMap可以通过下面的语句进行同步：<br>Map m = Collections.synchronizeMap(hashMap);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;本文准备从以下几个方面去讲解HashMap：&lt;br&gt;1）HashMap源码详细分析&lt;br&gt;2）HashMap为什么是线程不安全的？&lt;br&gt;3）HashMap和HashTable的区别&lt;br&gt;4）1.7和1.8的HashMap实现区别总结&lt;/em&gt;&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>小白都看得懂的快速排序</title>
    <link href="https://youngyang.top/2020/07/04/%E5%B0%8F%E7%99%BD%E9%83%BD%E7%9C%8B%E5%BE%97%E6%87%82%E7%9A%84%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://youngyang.top/2020/07/04/小白都看得懂的快速排序/</id>
    <published>2020-07-04T12:11:14.731Z</published>
    <updated>2020-07-04T12:08:09.164Z</updated>
    
    <content type="html"><![CDATA[<p>时隔多日，我又开始了我的博客之旅。。。准备面试的时候真的发现心里一万只xxx在奔腾→_→。</p><p>今天学习了快排，这应该是比较常见的排序方法了，冒泡排序的时间复杂度为O(n2)，相对于冒泡排序而言，快排的<strong>平均时间复杂度为O(nlogn)。</strong></p><p><strong>快排，说白了就是给基准数据找到正确索引位置的过程。不断二分迭代，从而将所有的基准数据都放到正确的位置。</strong></p><p> 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。<br><img src="https://img-blog.csdnimg.cn/20200610204622737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="普通快排"><a href="#普通快排" class="headerlink" title="普通快排"></a>普通快排</h1><p>废话不多说了，直接上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2020/6/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LastQuickSort</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ints1 = quickSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : ints1) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == null || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ints = quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归函数，就是一个不断二分迭代的过程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] par = partion(nums, left, right);</span><br><span class="line">            quickSort(nums, left, par[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, par[<span class="number">1</span>] + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分区，每次都选取最后一个数作为基准。</span></span><br><span class="line">    <span class="comment">// 将小于基准的数放到左边，但是左边的数不一定都是有序的</span></span><br><span class="line">    <span class="comment">// 大于基准的数放到基准的右边，但是右边的数不一定都是有序的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partion(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = left;</span><br><span class="line">        <span class="keyword">int</span> more = right;</span><br><span class="line">        <span class="comment">//选取基准</span></span><br><span class="line">        <span class="keyword">int</span> basic = nums[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要还没有遍历到大于基准的最左边的数就一直向右遍历</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &gt; basic) &#123;</span><br><span class="line">                swap(nums, left, more--);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt; basic) &#123;</span><br><span class="line">                swap(nums, less++, left++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less, more&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换数组中的两个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="随机快排"><a href="#随机快排" class="headerlink" title="随机快排"></a>随机快排</h1><p>随机快排与普通快排除了在选取基准上没有任何区别，只不过是随机快排在每次的迭代过程程中随机选取一个数组中一个数作为基准进行排序。<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2020/6/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomQuickSort</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ints1 = quickSort(ints);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : ints1) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == null || nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ints = quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归函数，就是一个不断二分迭代的过程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//选取数组中一个随机索引处的数作为基准</span></span><br><span class="line">            <span class="keyword">int</span> rand = <span class="keyword">new</span> Random().nextInt(right - left + <span class="number">1</span>);</span><br><span class="line">            swap(nums, left + rand, right);</span><br><span class="line">            <span class="keyword">int</span>[] par = partion(nums, left, right);</span><br><span class="line">            quickSort(nums, left, par[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, par[<span class="number">1</span>] + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分区，每次都选取最后一个数作为基准。</span></span><br><span class="line">    <span class="comment">// 将小于基准的数放到左边，但是左边的数不一定都是有序的</span></span><br><span class="line">    <span class="comment">// 大于基准的数放到基准的右边，但是右边的数不一定都是有序的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partion(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = left;</span><br><span class="line">        <span class="keyword">int</span> more = right;</span><br><span class="line">        <span class="comment">//选取基准</span></span><br><span class="line">        <span class="keyword">int</span> basic = nums[right];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要还没有遍历到大于基准的最左边的数就一直向右遍历</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &gt; basic) &#123;</span><br><span class="line">                swap(nums, left, more--);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt; basic) &#123;</span><br><span class="line">                swap(nums, less++, left++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;less, more&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换数组中的两个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时隔多日，我又开始了我的博客之旅。。。准备面试的时候真的发现心里一万只xxx在奔腾→_→。&lt;/p&gt;
&lt;p&gt;今天学习了快排，这应该是比较常见的排序方法了，冒泡排序的时间复杂度为O(n2)，相对于冒泡排序而言，快排的&lt;strong&gt;平均时间复杂度为O(nlogn)。&lt;/stro
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>线程池的五种状态详解</title>
    <link href="https://youngyang.top/2020/07/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/"/>
    <id>https://youngyang.top/2020/07/04/线程池的五种状态详解/</id>
    <published>2020-07-04T12:11:14.728Z</published>
    <updated>2020-07-04T12:08:08.352Z</updated>
    
    <content type="html"><![CDATA[<p>线程池的5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最好的学习方式就是看源码，众所周知，创建线程池肯定会使用到ThreadPoolExecutor类，其中ThreadPoolExecutor的源码的注释不仅讲述了线程池的几种状态，还详细讲解了什么时候或者调用什么方法之后进行状态转换，如下：<br><img src="https://img-blog.csdnimg.cn/20200629115508356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200629115532740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来就按照我的理解讲解一下这几种状态以及状态之间如何切换。</p><h1 id="1、RUNNING"><a href="#1、RUNNING" class="headerlink" title="1、RUNNING"></a>1、RUNNING</h1><blockquote><p>状态说明：在RUNNING状态下，线程池可以接收新的任务和执行已添加的任务。</p></blockquote><p>线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建（比如调用Executors.newFixedThreadPool()或者使用ThreadPoolExecutor进行创建），就处于RUNNING状态，并且线程池中的任务数为0！线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 </p><h1 id="2、-SHUTDOWN"><a href="#2、-SHUTDOWN" class="headerlink" title="2、 SHUTDOWN"></a>2、 SHUTDOWN</h1><blockquote><p>状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 </p></blockquote><p>当一个线程池调用shutdown()方法时，线程池由RUNNING -&gt; SHUTDOWN。</p><h1 id="3、STOP"><a href="#3、STOP" class="headerlink" title="3、STOP"></a>3、STOP</h1><blockquote><p>状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在执行的任务。 </p></blockquote><p>调用线程池的shutdownNow()方法的时候，线程池由(RUNNING或者SHUTDOWN ) -&gt; STOP。</p><h1 id="4、TIDYING"><a href="#4、TIDYING" class="headerlink" title="4、TIDYING"></a>4、TIDYING</h1><blockquote><p>状态说明：当所有的任务已终止，记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。</p></blockquote><p>terminated()方法在ThreadPoolExecutor类中是空的，没有任何实现。<br><img src="https://img-blog.csdnimg.cn/20200629151535122.png" alt="在这里插入图片描述"><br>若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重写terminated()函数来实现。 当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，会由STOP -&gt; TIDYING。</p><h1 id="5、-TERMINATED"><a href="#5、-TERMINATED" class="headerlink" title="5、 TERMINATED"></a>5、 TERMINATED</h1><blockquote><p>状态说明：当钩子函数terminated()被执行完成之后，线程池彻底终止，就变成TERMINATED状态。 </p></blockquote><p>线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>状态之间状态，和各个状态之间的的切换总结<br><img src="https://img-blog.csdnimg.cn/20200629150312492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="线程池各个状态切换框架图："></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程池的5种状态：Running、ShutDown、Stop、Tidying、Terminated。&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最好的学习方式就是看源码
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>为什么lambda表达式使用的局部变量要是final的</title>
    <link href="https://youngyang.top/2020/07/04/%E4%B8%BA%E4%BB%80%E4%B9%88lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A6%81%E6%98%AFfinal%E7%9A%84/"/>
    <id>https://youngyang.top/2020/07/04/为什么lambda表达式使用的局部变量要是final的/</id>
    <published>2020-07-04T12:11:14.725Z</published>
    <updated>2020-07-04T12:08:08.662Z</updated>
    
    <content type="html"><![CDATA[<p>为什么 Lambda 表达式(匿名类) 不能访问非 final  的局部变量呢？</p><p>因为实例变量存在堆中，而局部变量是在栈上分配，<strong><em>Lambda 表达(匿名类) 会在另一个线程中执行</em></strong>。如果在线程中要直接访问一个局部变量，可能线程执行时该局部变量已经被销毁了，而 <strong>final 类型的局部变量在 Lambda 表达式(匿名类) 中其实是局部变量的一个拷贝，因为之前的存放在栈中（lambda表达式在其他线程运行的时候可能栈已经释放了），所以必须要拷贝出一份来</strong>。</p><p>Java 8 的 Lambda 可以捕获什么变量呢？</p><p>(1). 捕获实例变量或静态变量是没有限制的 (可认为是通过 final 类型的局部变量 this 来引用前两者)；</p><p>(2)<strong>. 捕获的局部变量必须显式的声明为 final 或实际效果的的 final 类型</strong>。<br>注意(敲黑板)：如果在Lambda表达式中使用局部变量，即使我们没有声明成final类型的，编译器也会帮助我们将他们声明成final的，所以如果重新赋值会出错。</p><p>如下：<br><img src="https://img-blog.csdnimg.cn/20200619225323534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>结果如下：<br><img src="https://img-blog.csdnimg.cn/20200619225438699.png" alt="在这里插入图片描述"><br>此时程序不会报错，虽然我们没有使用final修饰变量b，但是Lambda表达式中也能使用，这是因为编译器帮我们自动声明成final的。</p><p>众所周知，final类型的变量不能重新赋值，来验证下是不是编译器真的帮我们声明成了final，如下：<br><img src="https://img-blog.csdnimg.cn/20200619225600747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>报错：<br><img src="https://img-blog.csdnimg.cn/20200619225609710.png" alt="在这里插入图片描述"><br>那么是什么时候帮我们声明成final呢？答案是在创建变量的时候直接声明成final的，测试如下：<br><img src="https://img-blog.csdnimg.cn/20200619225749859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020061922575680.png" alt="在这里插入图片描述"></p><p><strong>总结：在Lambda表达式中可以捕获静态变量和实例变量，但是如果想要捕获局部变量的时候就需要声明成final的，即使我们不主动声明，编译器也会为我们自动声明成final的，不能再重新赋值。也就是Lambda表达式中访问的局部变量(隐式被声明为final的)是可读不可写的，但是Lambda表达式中访问的实例变量和静态变量是可读可写的。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为什么 Lambda 表达式(匿名类) 不能访问非 final  的局部变量呢？&lt;/p&gt;
&lt;p&gt;因为实例变量存在堆中，而局部变量是在栈上分配，&lt;strong&gt;&lt;em&gt;Lambda 表达(匿名类) 会在另一个线程中执行&lt;/em&gt;&lt;/strong&gt;。如果在线程中要直接访问一个局
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>同步组建的基础之队列同步器AQS</title>
    <link href="https://youngyang.top/2020/07/04/%E5%90%8C%E6%AD%A5%E7%BB%84%E5%BB%BA%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/"/>
    <id>https://youngyang.top/2020/07/04/同步组建的基础之队列同步器AQS/</id>
    <published>2020-07-04T12:11:14.722Z</published>
    <updated>2020-07-04T12:08:08.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-AQS-简单介绍"><a href="#1-AQS-简单介绍" class="headerlink" title="1 AQS 简单介绍"></a>1 AQS 简单介绍</h1><p>AQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。<br><img src="https://img-blog.csdnimg.cn/20200623111101483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p><h1 id="2-AQS-原理"><a href="#2-AQS-原理" class="headerlink" title="2 AQS 原理"></a>2 AQS 原理</h1><h2 id="2-1-AQS-原理概览"><a href="#2-1-AQS-原理概览" class="headerlink" title="2.1 AQS 原理概览"></a>2.1 AQS 原理概览</h2><p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p><p>看个AQS(AbstractQueuedSynchronizer)原理图：<br><img src="https://img-blog.csdnimg.cn/20200623111621193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="enter image description here"><br>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-AQS-对资源的共享方式"><a href="#2-2-AQS-对资源的共享方式" class="headerlink" title="2.2 AQS 对资源的共享方式"></a>2.2 AQS 对资源的共享方式</h2><p>AQS定义两种资源共享方式</p><h3 id="1-Exclusive（独占）"><a href="#1-Exclusive（独占）" class="headerlink" title="1)Exclusive（独占）"></a>1)Exclusive（独占）</h3><p>只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁,ReentrantLock 同时支持两种锁,下面以 ReentrantLock 对这两种锁的定义做介绍：</p><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁；</li><li>非公平锁：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li></ul><blockquote><p>说明：下面这部分关于 ReentrantLock 源代码内容节选自：<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer-2，这是一篇很不错文章，推荐阅读。" target="_blank" rel="noopener">https://www.javadoop.com/post/AbstractQueuedSynchronizer-2，这是一篇很不错文章，推荐阅读。</a></p></blockquote><p>下面来看 ReentrantLock 中相关的源代码：</p><p>ReentrantLock 默认采用非公平锁，因为考虑获得更好的性能，通过 boolean 来决定是否用公平锁（传入 true 用公平锁）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Synchronizer providing all implementation mechanics */</span></span><br><span class="line"><span class="keyword">private</span> final Sync sync;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(boolean fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantLock 中公平锁的 lock 方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> final <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="title">extends</span> <span class="title">Sync</span> &#123;</span></span><br><span class="line">    <span class="function">final <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> final <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> final boolean <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平锁的 lock 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// AbstractQueuedSynchronizer.acquire(int arg)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment"> * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里没有对阻塞队列进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：公平锁和非公平锁只有两处不同：</p><ul><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ul><p>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p><strong><em>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</em></strong></p><h3 id="2-Share（共享）"><a href="#2-Share（共享）" class="headerlink" title="2)Share（共享）"></a>2)Share（共享）</h3><p>多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p><p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在上层已经帮我们实现好了。</p><h2 id="2-3-AQS底层使用了模板方法模式"><a href="#2-3-AQS底层使用了模板方法模式" class="headerlink" title="2.3 AQS底层使用了模板方法模式"></a>2.3 AQS底层使用了模板方法模式</h2><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。</p><blockquote><p>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票buyTicket()-&gt;安检securityCheck()-&gt;乘坐某某工具回家ride()-&gt;到达目的地arrive()。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了ride()方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 ride()方法。</p></blockquote><p>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</p><blockquote><p>isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。<br>tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。</p></blockquote><p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。<strong><em>当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念</em></strong>。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><blockquote><p>推荐两篇 AQS 原理和相关源码分析的文章：<br><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a><br><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></p></blockquote><h1 id="3-Semaphore-信号量-允许多个线程同时访问"><a href="#3-Semaphore-信号量-允许多个线程同时访问" class="headerlink" title="3 Semaphore(信号量)-允许多个线程同时访问"></a>3 Semaphore(信号量)-允许多个线程同时访问</h1><p>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年9月30日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 需要一次性拿一个许可的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 一次只能允许执行的线程数量。</span></span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"finish"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 acquire 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；每个 release 方法增加一个许可证，这可能会释放一个阻塞的acquire方法。然而，其实并没有实际的许可证这个对象，Semaphore只是维持了一个可获得许可证的数量。 Semaphore经常用于限制获取某种资源的线程数量。</p><p>当然一次也可以一次拿取和释放多个许可，不过一般没有必要这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">semaphore.acquire(<span class="number">5</span>);<span class="comment">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br><span class="line">test(threadnum);</span><br><span class="line">semaphore.release(<span class="number">5</span>);<span class="comment">// 获取5个许可，所以可运行线程数量为20/5=4</span></span><br></pre></td></tr></table></figure><p>除了 acquire方法之外，另一个比较常用的与之对应的方法是tryAcquire方法，该方法如果获取不到许可就立即返回false。</p><p>Semaphore 有两种模式，公平模式和非公平模式。</p><ul><li>L公平模式： 调用acquire的顺序就是获取许可证的顺序，遵循FIFO；</li><li>非公平模式： 抢占式的。</li></ul><p>Semaphore 对应的两个构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><em>这两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。</em></strong></p><blockquote><p>由于篇幅问题，如果对 Semaphore 源码感兴趣的朋友可以看下面这篇文章：<br><a href="https://blog.csdn.net/qq_19431333/article/details/70212663" target="_blank" rel="noopener">https://blog.csdn.net/qq_19431333/article/details/70212663</a></p></blockquote><h1 id="4-CountDownLatch-（倒计时器）"><a href="#4-CountDownLatch-（倒计时器）" class="headerlink" title="4 CountDownLatch （倒计时器）"></a>4 CountDownLatch （倒计时器）</h1><p>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。在Java并发中，countdownlatch的概念是一个常见的面试题，所以一定要确保你很好的理解了它。</p><h2 id="4-1-CountDownLatch-的三种典型用法"><a href="#4-1-CountDownLatch-的三种典型用法" class="headerlink" title="4.1 CountDownLatch 的三种典型用法"></a>4.1 CountDownLatch 的三种典型用法</h2><p>①某一线程在开始运行前等待n个线程执行完毕。将 CountDownLatch 的计数器初始化为n ：new CountDownLatch(n) ，每当一个任务线程执行完毕，就将计数器减1 countdownlatch.countDown()，当计数器的值变为0时，在CountDownLatch上 await() 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</p><p>②实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 CountDownLatch 对象，将其计数器初始化为 1 ：new CountDownLatch(1) ，多个线程在开始执行任务前首先 coundownlatch.await()，当主线程调用 countDown() 时，计数器变为0，多个线程同时被唤醒。</p><p>③死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。</p><h2 id="4-2-CountDownLatch-的使用示例"><a href="#4-2-CountDownLatch-的使用示例" class="headerlink" title="4.2 CountDownLatch 的使用示例"></a>4.2 CountDownLatch 的使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SnailClimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: CountDownLatch 使用方法示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadnum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"finish"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们定义了请求的数量为550，当这550个请求被处理完成之后，才会执行System.out.println(“finish”);。</p><p>与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。</p><h2 id="4-3-CountDownLatch-的不足"><a href="#4-3-CountDownLatch-的不足" class="headerlink" title="4.3 CountDownLatch 的不足"></a>4.3 CountDownLatch 的不足</h2><p>CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。</p><h2 id="4-4-CountDownLatch相常见面试题："><a href="#4-4-CountDownLatch相常见面试题：" class="headerlink" title="4.4 CountDownLatch相常见面试题："></a>4.4 CountDownLatch相常见面试题：</h2><p>解释一下CountDownLatch概念？</p><p>CountDownLatch 和CyclicBarrier的不同之处？</p><p>给出一些CountDownLatch使用的例子？</p><p>CountDownLatch 类中主要的方法？</p><h1 id="5-CyclicBarrier-循环栅栏"><a href="#5-CyclicBarrier-循环栅栏" class="headerlink" title="5 CyclicBarrier(循环栅栏)"></a>5 CyclicBarrier(循环栅栏)</h1><p>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。</p><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p><h2 id="5-1-CyclicBarrier-的应用场景"><a href="#5-1-CyclicBarrier-的应用场景" class="headerlink" title="5.1 CyclicBarrier 的应用场景"></a>5.1 CyclicBarrier 的应用场景</h2><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。</p><h2 id="5-2-CyclicBarrier-的使用示例"><a href="#5-2-CyclicBarrier-的使用示例" class="headerlink" title="5.2 CyclicBarrier 的使用示例"></a>5.2 CyclicBarrier 的使用示例</h2><p>示例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Snailclimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 测试 CyclicBarrier 类中带参数的 await() 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample2</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line">  <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is ready"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/**等待60秒，保证子线程完全执行结束*/</span>  </span><br><span class="line">      cyclicBarrier.await(<span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"-----CyclicBarrierException------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is finish"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">threadnum:<span class="number">0</span>is ready</span><br><span class="line">threadnum:<span class="number">1</span>is ready</span><br><span class="line">threadnum:<span class="number">2</span>is ready</span><br><span class="line">threadnum:<span class="number">3</span>is ready</span><br><span class="line">threadnum:<span class="number">4</span>is ready</span><br><span class="line">threadnum:<span class="number">4</span>is finish</span><br><span class="line">threadnum:<span class="number">0</span>is finish</span><br><span class="line">threadnum:<span class="number">1</span>is finish</span><br><span class="line">threadnum:<span class="number">2</span>is finish</span><br><span class="line">threadnum:<span class="number">3</span>is finish</span><br><span class="line">threadnum:<span class="number">5</span>is ready</span><br><span class="line">threadnum:<span class="number">6</span>is ready</span><br><span class="line">threadnum:<span class="number">7</span>is ready</span><br><span class="line">threadnum:<span class="number">8</span>is ready</span><br><span class="line">threadnum:<span class="number">9</span>is ready</span><br><span class="line">threadnum:<span class="number">9</span>is finish</span><br><span class="line">threadnum:<span class="number">5</span>is finish</span><br><span class="line">threadnum:<span class="number">8</span>is finish</span><br><span class="line">threadnum:<span class="number">7</span>is finish</span><br><span class="line">threadnum:<span class="number">6</span>is finish</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， await方法之后的方法才被执行。</p><p>另外，CyclicBarrier还提供一个更高级的构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> SnailClimb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年10月1日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 新建 CyclicBarrier 的时候指定一个 Runnable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample3</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line">  <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"------当线程数达到之后，优先执行------"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadNum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is ready"</span>);</span><br><span class="line">    cyclicBarrier.await();</span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is finish"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">threadnum:<span class="number">0</span>is ready</span><br><span class="line">threadnum:<span class="number">1</span>is ready</span><br><span class="line">threadnum:<span class="number">2</span>is ready</span><br><span class="line">threadnum:<span class="number">3</span>is ready</span><br><span class="line">threadnum:<span class="number">4</span>is ready</span><br><span class="line">------当线程数达到之后，优先执行------</span><br><span class="line">threadnum:<span class="number">4</span>is finish</span><br><span class="line">threadnum:<span class="number">0</span>is finish</span><br><span class="line">threadnum:<span class="number">2</span>is finish</span><br><span class="line">threadnum:<span class="number">1</span>is finish</span><br><span class="line">threadnum:<span class="number">3</span>is finish</span><br><span class="line">threadnum:<span class="number">5</span>is ready</span><br><span class="line">threadnum:<span class="number">6</span>is ready</span><br><span class="line">threadnum:<span class="number">7</span>is ready</span><br><span class="line">threadnum:<span class="number">8</span>is ready</span><br><span class="line">threadnum:<span class="number">9</span>is ready</span><br><span class="line">------当线程数达到之后，优先执行------</span><br><span class="line">threadnum:<span class="number">9</span>is finish</span><br><span class="line">threadnum:<span class="number">5</span>is finish</span><br><span class="line">threadnum:<span class="number">6</span>is finish</span><br><span class="line">threadnum:<span class="number">8</span>is finish</span><br><span class="line">threadnum:<span class="number">7</span>is finish</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="5-3-CyclicBarrier和CountDownLatch的区别"><a href="#5-3-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="5.3 CyclicBarrier和CountDownLatch的区别"></a>5.3 CyclicBarrier和CountDownLatch的区别</h2><p>CountDownLatch是计数器，只能使用一次，而CyclicBarrier的计数器提供reset功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从jdk作者设计的目的来看，javadoc是这么描述它们的：</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；) CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p></blockquote><p>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><p>CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p><p><strong><em>CyclicBarrier和CountDownLatch的区别</em></strong><br><img src="https://img-blog.csdnimg.cn/2020062311402484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>CyclicBarrier和CountDownLatch的区别这部分内容参考了如下两篇文章：<br><a href="https://blog.csdn.net/u010185262/article/details/54692886" target="_blank" rel="noopener">https://blog.csdn.net/u010185262/article/details/54692886</a><br><a href="https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0" target="_blank" rel="noopener">https://blog.csdn.net/tolcf/article/details/50925145?utm_source=blogxgwz0</a></p></blockquote><h1 id="6-ReentrantLock-和-ReentrantReadWriteLock"><a href="#6-ReentrantLock-和-ReentrantReadWriteLock" class="headerlink" title="6 ReentrantLock 和 ReentrantReadWriteLock"></a>6 ReentrantLock 和 ReentrantReadWriteLock</h1><p>ReentrantLock 和 synchronized 的区别在上面已经讲过了这里就不多做讲解。另外，需要注意的是：读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。</p><blockquote><p>本文参考链接：<a href="https://github.com/PandaSkr/JavaGuide/blob/master/docs/java/Multithread/AQS.md#1-aqs-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">https://github.com/PandaSkr/JavaGuide/blob/master/docs/java/Multithread/AQS.md#1-aqs-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-AQS-简单介绍&quot;&gt;&lt;a href=&quot;#1-AQS-简单介绍&quot; class=&quot;headerlink&quot; title=&quot;1 AQS 简单介绍&quot;&gt;&lt;/a&gt;1 AQS 简单介绍&lt;/h1&gt;&lt;p&gt;AQS的全称为（AbstractQueuedSynchronizer），这个
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅析mysql中的事务</title>
    <link href="https://youngyang.top/2020/07/04/%E6%B5%85%E6%9E%90mysql%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
    <id>https://youngyang.top/2020/07/04/浅析mysql中的事务/</id>
    <published>2020-07-04T12:11:14.710Z</published>
    <updated>2020-07-04T12:08:09.631Z</updated>
    
    <content type="html"><![CDATA[<p>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p><h1 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h1><p>一般来说，事务是必须满足4个条件（ACID）：：<strong>原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</strong></p><p><strong>原子性</strong>：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p><strong>一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p><strong>隔离性</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括<strong>读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</strong>。</p><p><strong>持久性</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p><h1 id="事务的使用"><a href="#事务的使用" class="headerlink" title="事务的使用"></a>事务的使用</h1><p>默认事务是自动提交的：<br>可以使用下列语句来查看事务是否自动提交：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE <span class="string">"autocommit"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200414230213651.png" alt="在这里插入图片描述"><br>默认情况下，我们的每一条sql语句，比如增删改都是一个事务，只不过系统帮我们自动提交了。</p><p>我们也可以手动的开启事务和提交或者回滚。<br>如何关闭系统的自动提交事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=<span class="number">0</span>(或者set autocommit=off);</span><br></pre></td></tr></table></figure><p>开启系统的自动提交事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=<span class="number">1</span>(或者set autocommit=on);</span><br></pre></td></tr></table></figure><p>1、开启事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">start <span class="title">transaction</span><span class="params">(或者begin也可以开启)</span></span></span><br></pre></td></tr></table></figure><p>2、提交事务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><p>3、回滚事务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p>由于事务隔离级别的不同可能在并发事务情况下引发不同的并发问题，比如脏读，不可重复读和幻读。mysql的默认隔离级别是可重复读。</p><p><strong>四大隔离级别：（由低到高）<br>（1）读未提交：read uncommitted<br>（2）读已提交：read committed<br>（3）可重复读：repeatable read<br>（4）串行化：serializable</strong></p><p>隔离级别所引发的问题：<br><img src="https://img-blog.csdnimg.cn/20200414231254856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h2><p>事物A和事物B，事物A未提交的数据，事物B可以读取到<br>这里读取到的数据叫做“脏数据”<br>这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别</p><h2 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h2><p>事物A和事物B，事物A提交的数据，事物B才能读取到<br>这种隔离级别高于读未提交<br>换句话说，对方事物提交之后的数据，我当前事物才能读取到<br>这种级别可以避免“脏数据”<br>这种隔离级别会导致“不可重复读取”</p><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><p>事务A和事务B，事务A提交之后的数据，事务B读取不到<br>事务B是可重复读取数据<br>这种隔离级别高于读已提交<br>换句话说，对方提交之后的数据，我还是读取不到<br>这种隔离级别可以避免“不可重复读取”，达到可重复读取</p><h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>事务A和事务B，事务A在操作数据库时，事务B只能排队等待<br>这种隔离级别很少使用，吞吐量太低，用户体验差<br>这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发</p><h1 id="mysql锁技术以及MVCC基础"><a href="#mysql锁技术以及MVCC基础" class="headerlink" title="mysql锁技术以及MVCC基础"></a>mysql锁技术以及MVCC基础</h1><h2 id="锁技术"><a href="#锁技术" class="headerlink" title="锁技术"></a>锁技术</h2><p>当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里有读请求，又有修改请求时必须有一种措施来进行并发控制。不然很有可能会造成不一致。<br>读写锁<br>解决上述问题很简单，只需用两种锁的组合来对读写请求进行控制即可，这两种锁被称为：</p><p>共享锁(shared lock),又叫做”读锁”<br>读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。</p><p>排他锁(exclusive lock),又叫做”写锁”<br>写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。</p><p><strong>总结：通过读写锁，可以做到读读可以并行，但是不能做到写读，写写并行</strong></p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC (MultiVersion Concurrency Control) 叫做多版本并发控制。一般情况下，事务性储存引擎不是只使用表锁，行锁来处理数据。而是结合了MVCC机制，以处理更多的并发问题。MVCC处理高并发能力最强，但系统开销 比较大（较表锁、行级锁），这是为求高并发付出的代价。</p><p>下面,我们通过InnoDB的MVCC实现来分析MVCC使怎样进行并发控制的.<br>InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，没开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.下面看一下在REPEATABLE READ隔离级别下,MVCC具体是如何操作的.</p><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>InnoDB为新插入的每一行保存当前系统版本号作为版本号.<br>第一个事务ID为1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">insert into yang values(NULL,'yang') ;</span><br><span class="line">insert into yang values(NULL,'long');</span><br><span class="line">insert into yang values(NULL,'fei');</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>对应在数据中的表如下(后面两列是隐藏列，我们通过查询语句并不能看到)<br><img src="https://img-blog.csdnimg.cn/2020041423450275.png" alt="在这里插入图片描述"></p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>InnoDB会根据以下两个条件检查每行记录:<br>a.InnoDB只会查找版本早于当前事务版本的数据行(也就是,<strong>行的系统版本号小于或等于事务的系统版本号</strong>)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的.<br>b.<strong>行的删除版本要么未定义,要么大于当前事务版本号</strong>,这可以确保事务读取到的行，在事务开始之前未被删除. </p><p>只有a,b同时满足的记录，才能返回作为查询结果.</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识.。</p><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>nnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到被UPDATE的行的删除时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。&lt;/p&gt;
&lt;h1 id=&quot;事务的四大特性&quot;&gt;&lt;a href=&quot;#事务的四大特性&quot; class=&quot;headerlink&quot; title=&quot;事务的四大特性&quot;&gt;&lt;/a&gt;事务的四大特性&lt;/h1&gt;&lt;p&gt;一般来
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spring中开启事务的方式有哪些</title>
    <link href="https://youngyang.top/2020/07/04/Spring%E4%B8%AD%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
    <id>https://youngyang.top/2020/07/04/Spring中开启事务的方式有哪些/</id>
    <published>2020-07-04T12:11:14.698Z</published>
    <updated>2020-07-04T12:08:09.058Z</updated>
    
    <content type="html"><![CDATA[<p>Spring中开启事务的方式主要有两种：<strong>编程式事务和声明式事务</strong>。</p><h1 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h1><p>编程式事务：在代码中调用 commit()、rollback()等事务管理相关的方法。<br>maven pom.xml文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.2.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.2.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.2.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.2.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.2.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- mysql驱动 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.1.18&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>编程式事务管理，可以通过 java.sql.Connection 控制事务。spring 配置文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line">        </span><br><span class="line">&lt;bean id="driver" class="com.mysql.jdbc.Driver"&gt;&lt;/bean&gt;</span><br><span class="line"> </span><br><span class="line">&lt;bean id=<span class="string">"datasource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jdbc.datasource.SimpleDriverDataSource"</span>&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"0"</span> name=<span class="string">"driver"</span> ref=<span class="string">"driver"</span> /&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"1"</span>&gt;</span><br><span class="line">&lt;value&gt;jdbc:mysql:<span class="comment">//localhost:3306/test&lt;/value&gt;</span></span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"2"</span>&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"3"</span>&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">testManualTransaction();<span class="comment">//测试函数式控制事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testManualTransaction</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring_transaction.xml"</span>);</span><br><span class="line">DataSource ds = (DataSource)context.getBean(<span class="string">"datasource"</span>);</span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">initTable(conn);<span class="comment">//初始化表</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);<span class="comment">//设置不自动提交事务</span></span><br><span class="line">queryUsers(conn);<span class="comment">//查询打印用户表</span></span><br><span class="line">deleteUser(conn);<span class="comment">//删除 id=1 用户</span></span><br><span class="line">conn.rollback();<span class="comment">//回滚</span></span><br><span class="line">queryUsers(conn);<span class="comment">//查询打印用户表</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initTable</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">conn.createStatement().execute(<span class="string">"drop table if exists user"</span>);</span><br><span class="line">conn.createStatement().execute(<span class="string">"create table user(id int, username varchar(60)) ENGINE=InnoDB DEFAULT CHARSET=utf8 "</span>);<span class="comment">//是否支持事务与数据库引擎有关，此处删除 ENGINE=InnoDB DEFAULT CHARSET=utf8 可能不支持事务</span></span><br><span class="line">conn.createStatement().execute(<span class="string">"insert into user values(1, 'user1')"</span>);</span><br><span class="line">conn.createStatement().execute(<span class="string">"insert into user values(2, 'user2')"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">conn.createStatement().execute(<span class="string">"delete from user where id = 1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">queryUsers</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line">st.execute(<span class="string">"select * from user"</span>);</span><br><span class="line">ResultSet rs = st.getResultSet();</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">System.out.print(rs.getString(<span class="string">"id"</span>));</span><br><span class="line">System.out.print(<span class="string">" "</span>);</span><br><span class="line">System.out.print(rs.getString(<span class="string">"username"</span>));</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除用户语句回滚，打印出两个用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 user1</span><br><span class="line">2 user2</span><br><span class="line">1 user1</span><br><span class="line">2 user2</span><br></pre></td></tr></table></figure><h1 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h1><h2 id="基于-TransactionProxyFactoryBean-的声明式事务管理"><a href="#基于-TransactionProxyFactoryBean-的声明式事务管理" class="headerlink" title="基于 TransactionProxyFactoryBean 的声明式事务管理"></a>基于 TransactionProxyFactoryBean 的声明式事务管理</h2><p>新增 UserDao 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; getUsers();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增 UserDao 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; getUsers() &#123;</span><br><span class="line">String sql = <span class="string">"select * from user"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForList(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">String sql = <span class="string">"delete from user where id = "</span> + id;</span><br><span class="line"><span class="keyword">int</span> result = <span class="keyword">this</span>.getJdbcTemplate().update(sql);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 spring 配置文件，添加事务管理器 DataSourceTransactionManager 和事务代理类 TransactionProxyFactoryBean</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line">        </span><br><span class="line">&lt;bean id=<span class="string">"driver"</span> class=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"datasource"</span> class=<span class="string">"org.springframework.jdbc.datasource.SimpleDriverDataSource"</span>&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"0"</span> name=<span class="string">"driver"</span> ref=<span class="string">"driver"</span> /&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"1"</span>&gt;</span><br><span class="line">&lt;value&gt;jdbc:mysql://localhost:3306/<span class="built_in">test</span>&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"2"</span>&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"3"</span>&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> class=<span class="string">"constxiong.interview.transaction.UserDaoImpl"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"datasource"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 事务管理器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"tracnsactionManager"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"datasource"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"userProxy"</span> class=<span class="string">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"transactionManager"</span> ref=<span class="string">"tracnsactionManager"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=<span class="string">"target"</span> ref=<span class="string">"userDao"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=<span class="string">"transactionAttributes"</span>&gt;</span><br><span class="line">&lt;props&gt;</span><br><span class="line">&lt;!-- 主要 key 是方法   </span><br><span class="line">ISOLATION_DEFAULT  事务的隔离级别</span><br><span class="line">PROPAGATION_REQUIRED  传播行为</span><br><span class="line">--&gt;</span><br><span class="line">&lt;!-- -Exception 表示发生指定异常回滚，+Exception 表示发生指定异常提交 --&gt;</span><br><span class="line">&lt;prop key=<span class="string">"deleteUser"</span>&gt;-java.lang.RuntimeException&lt;/prop&gt;</span><br><span class="line">&lt;/props&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring_transaction.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">testUseTransactionProxy(); <span class="comment">//测试使用 spring TransactionProxyFactoryBean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testUseTransactionProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> UserDao userDao = (UserDao)context.getBean(<span class="string">"userProxy"</span>);</span><br><span class="line">printUsers(userDao);<span class="comment">//打印用户</span></span><br><span class="line">userDao.deleteUser(<span class="number">1</span>);<span class="comment">//删除 id=1 用户</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Map&lt;String, Object&gt; user : userDao.getUsers()) &#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;id=1, username=user1&#125;</span><br><span class="line">&#123;id=2, username=user2&#125;</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.RuntimeException</span><br><span class="line">at constxiong.interview.transaction.UserDaoImpl.deleteUser(UserDaoImpl.java:28)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:302)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionInterceptor<span class="variable">$1</span>.proceedWithInvocation(TransactionInterceptor.java:99)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class="line">at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:208)</span><br><span class="line">at com.sun.proxy.<span class="variable">$Proxy3</span>.deleteUser(Unknown Source)</span><br><span class="line">at constxiong.interview.transaction.TransactionTest.testUseTransactionProxy(TransactionTest.java:32)</span><br><span class="line">at constxiong.interview.transaction.TransactionTest.main(TransactionTest.java:13)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200617112307332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="基于注解-Transactional-的声明式事务管理"><a href="#基于注解-Transactional-的声明式事务管理" class="headerlink" title="基于注解 @Transactional 的声明式事务管理"></a>基于注解 @Transactional 的声明式事务管理</h2><p>UserDaoImpl 删除用户方法添加注解 @Transactional(rollbackFor=RuntimeException.class) 出现 RuntimeException 回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; getUsers() &#123;</span><br><span class="line">String sql = <span class="string">"select * from user"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForList(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor=RuntimeException.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">String sql = <span class="string">"delete from user where id = "</span> + id;</span><br><span class="line"><span class="keyword">int</span> result = <span class="keyword">this</span>.getJdbcTemplate().update(sql);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 spring 配置文件，开启 spring 的事务注解能力</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line">        </span><br><span class="line">&lt;bean id=<span class="string">"driver"</span> class=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"datasource"</span> class=<span class="string">"org.springframework.jdbc.datasource.SimpleDriverDataSource"</span>&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"0"</span> name=<span class="string">"driver"</span> ref=<span class="string">"driver"</span> /&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"1"</span>&gt;</span><br><span class="line">&lt;value&gt;jdbc:mysql://localhost:3306/<span class="built_in">test</span>&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"2"</span>&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"3"</span>&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> class=<span class="string">"constxiong.interview.transaction.UserDaoImpl"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"datasource"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 事务管理器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"tracnsactionManager"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"datasource"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 启用事务注解 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">"tracnsactionManager"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring_transaction.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">testAnnotationTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAnnotationTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">UserDao userDao = (UserDao)context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">printUsers(userDao);</span><br><span class="line">userDao.deleteUser(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Map&lt;String, Object&gt; user : userDao.getUsers()) &#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;id=1, username=user1&#125;</span><br><span class="line">&#123;id=2, username=user2&#125;</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.RuntimeException</span><br><span class="line">at constxiong.interview.transaction.UserDaoImpl.deleteUser(UserDaoImpl.java:30)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:302)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionInterceptor<span class="variable">$1</span>.proceedWithInvocation(TransactionInterceptor.java:99)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class="line">at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:208)</span><br><span class="line">at com.sun.proxy.<span class="variable">$Proxy5</span>.deleteUser(Unknown Source)</span><br><span class="line">at constxiong.interview.transaction.TransactionTest.testAnnotationTransaction(TransactionTest.java:20)</span><br><span class="line">at constxiong.interview.transaction.TransactionTest.main(TransactionTest.java:13)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200617112432727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="基于-Aspectj-AOP-配置（注解）事务"><a href="#基于-Aspectj-AOP-配置（注解）事务" class="headerlink" title="基于 Aspectj AOP 配置（注解）事务"></a>基于 Aspectj AOP 配置（注解）事务</h2><p>maven pom.xml 添加 Aspectj 的支持</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>去除 UserDaoImpl 注解@Transactional(rollbackFor=RuntimeException.class)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> constxiong.interview.transaction;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.support.JdbcDaoSupport;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; getUsers() &#123;</span><br><span class="line">String sql = <span class="string">"select * from user"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getJdbcTemplate().queryForList(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">String sql = <span class="string">"delete from user where id = "</span> + id;</span><br><span class="line"><span class="keyword">int</span> result = <span class="keyword">this</span>.getJdbcTemplate().update(sql);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 spring 配置文件，织入切面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans </span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span><br><span class="line">        </span><br><span class="line">&lt;bean id=<span class="string">"driver"</span> class=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"datasource"</span> class=<span class="string">"org.springframework.jdbc.datasource.SimpleDriverDataSource"</span>&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"0"</span> name=<span class="string">"driver"</span> ref=<span class="string">"driver"</span> /&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"1"</span>&gt;</span><br><span class="line">&lt;value&gt;jdbc:mysql://localhost:3306/<span class="built_in">test</span>&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"2"</span>&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=<span class="string">"3"</span>&gt;</span><br><span class="line">&lt;value&gt;root&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"userDao"</span> class=<span class="string">"constxiong.interview.transaction.UserDaoImpl"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"datasource"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 事务管理器 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"tracnsactionManager"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"datasource"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"tracnsactionManager"</span>&gt;</span><br><span class="line">&lt;tx:attributes&gt;</span><br><span class="line">&lt;!-- 为连接点指定事务属性 --&gt;</span><br><span class="line">&lt;tx:method name=<span class="string">"deleteUser"</span> rollback-for=<span class="string">"java.lang.RuntimeException"</span>/&gt;</span><br><span class="line">&lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;!-- 切入点配置 --&gt;</span><br><span class="line">&lt;aop:pointcut id=<span class="string">"point"</span> expression=<span class="string">"execution(* *constxiong.interview.transaction.UserDao.deleteUser(..))"</span> /&gt;</span><br><span class="line">&lt;aop:advisor advice-ref=<span class="string">"txAdvice"</span> pointcut-ref=<span class="string">"point"</span>/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package constxiong.interview.transaction;</span><br><span class="line"> </span><br><span class="line">import java.util.Map;</span><br><span class="line"> </span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line">public class TransactionTest &#123;</span><br><span class="line"> </span><br><span class="line">static ApplicationContext context = new ClassPathXmlApplicationContext(<span class="string">"spring_transaction.xml"</span>);</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">testAspectjTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static void <span class="function"><span class="title">testAspectjTransaction</span></span>() &#123;</span><br><span class="line">UserDao userDao = (UserDao)context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">printUsers(userDao);</span><br><span class="line">userDao.deleteUser(1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">private static void printUsers(UserDao userDao) &#123;</span><br><span class="line"><span class="keyword">for</span> (Map&lt;String, Object&gt; user : userDao.getUsers()) &#123;</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;id=1, username=user1&#125;</span><br><span class="line">&#123;id=2, username=user2&#125;</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.RuntimeException</span><br><span class="line">at constxiong.interview.transaction.UserDaoImpl.deleteUser(UserDaoImpl.java:28)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:302)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionInterceptor<span class="variable">$1</span>.proceedWithInvocation(TransactionInterceptor.java:99)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)</span><br><span class="line">at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class="line">at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)</span><br><span class="line">at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class="line">at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:208)</span><br><span class="line">at com.sun.proxy.<span class="variable">$Proxy2</span>.deleteUser(Unknown Source)</span><br><span class="line">at constxiong.interview.transaction.TransactionTest.testAnnotationTransaction(TransactionTest.java:20)</span><br><span class="line">at constxiong.interview.transaction.TransactionTest.main(TransactionTest.java:13)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200617112557251.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring中开启事务的方式主要有两种：&lt;strong&gt;编程式事务和声明式事务&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;编程式事务&quot;&gt;&lt;a href=&quot;#编程式事务&quot; class=&quot;headerlink&quot; title=&quot;编程式事务&quot;&gt;&lt;/a&gt;编程式事务&lt;/h1&gt;&lt;p&gt;编
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SpringDataJpa学习一</title>
    <link href="https://youngyang.top/2020/07/04/SpringDataJpa%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <id>https://youngyang.top/2020/07/04/SpringDataJpa学习一/</id>
    <published>2020-07-04T12:11:14.695Z</published>
    <updated>2020-07-04T12:08:10.662Z</updated>
    
    <content type="html"><![CDATA[<p>学springdatajpa之前，我觉得非常有必要复习一下Jpa规范和orm思想。</p><h1 id="JPA入门"><a href="#JPA入门" class="headerlink" title="JPA入门"></a>JPA入门</h1><h2 id="orm概述"><a href="#orm概述" class="headerlink" title="orm概述"></a>orm概述</h2><p>ORM（Object-Relational Mapping） 表示对象关系映射。在面向对象的软件开发中，通过ORM，就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了ORM对象关系映射。</p><p>简单的说：<strong>ORM就是建立实体类和数据库表之间的关系，从而达到操作实体类就相当于操作数据库表的目的。</strong></p><p>常见的orm框架：Mybatis（ibatis）、Hibernate、Jpa。</p><h2 id="JPA规范"><a href="#JPA规范" class="headerlink" title="JPA规范"></a>JPA规范</h2><p>JPA的全称是Java Persistence API， 即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成。</p><p>JPA通过JDK 5.0注解描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p><p>JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现。<br><img src="https://img-blog.csdnimg.cn/20200303101517225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>JPA和Hibernate的关系就像JDBC和JDBC驱动的关系，JPA是规范，Hibernate除了作为ORM框架之外，它也是一种JPA实现。<strong><em>java代码调用JPA规范中的接口和实现类，但是接口并不能实现功能，实际实现功能的还是hibernate框架，而hibernate还是对jdbc的封装，从而操作数据库。</em></strong></p><h2 id="JPA入门-1"><a href="#JPA入门-1" class="headerlink" title="JPA入门"></a>JPA入门</h2><p>目的：通过JPA规范实现对数据库中客户表的操作。<br>步骤一：创建maven工程，导入依赖；<br>步骤二：建立数据库表和实体类对象<br>步骤三：编写JPA的配置文件；<br>步骤四：进行单元测试。</p><p>步骤一：创建maven工程，导入依赖；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">       &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;project.hibernate.version&gt;5.0.7.Final&lt;/project.hibernate.version&gt;</span><br><span class="line">   &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--lombok进行代码简化--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.16.10&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- hibernate对jpa的支持包 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- c3p0数据库连接池 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- <span class="built_in">log</span>日志 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- Mysql驱动包 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>步骤二：建立数据库表和实体类对象</p><p>创建数据库表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE jpa;</span><br><span class="line">USE jpa;</span><br><span class="line"></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">t_customer</span><span class="params">(</span></span></span><br><span class="line">cst_id INT(10) PRIMARY KEY AUTO_INCREMENT COMMENT'顾客id(主键)',</span><br><span class="line">cst_name VARCHAR(32) COMMENT'顾客姓名',</span><br><span class="line">cst_age INT(2) COMMENT '顾客年龄'</span><br><span class="line">)ENGINE=INNODB AUTO_INCREMENT=<span class="number">1</span> DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>创建实体类对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package top.youngyang.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line">@Data<span class="comment">//lombok为类添加了setter，getter，toString，hashcode和equal方法</span></span><br><span class="line">@Entity<span class="comment">//说明当前是一个实体类</span></span><br><span class="line">@Table(name = <span class="string">"t_customer"</span>)<span class="comment">//@Table指定该实体类对应的数据库表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    @Id<span class="comment">//指明该字段为id主键</span></span><br><span class="line">    @GeneratedValue(strategy=GenerationType.IDENTITY)<span class="comment">//设置主键生成策略为自增</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    @Column(name = <span class="string">"cst_name"</span>)<span class="comment">//@Column指明该属性对应的字段</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    @Column(name = <span class="string">"cst_age"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤三：编写JPA的配置文件；</p><p>配置文件必须在META-INF文件夹下，并且名称为persistence.xml。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;persistence xmlns=<span class="string">"http://java.sun.com/xml/ns/persistence"</span> version=<span class="string">"2.0"</span>&gt;</span><br><span class="line">    &lt;!--在此约束下，需要配置persistence-unit，否则会报错</span><br><span class="line">        持久化单元：</span><br><span class="line">            name：持久化单元的名称</span><br><span class="line">            transaction-type:事务管理的方式</span><br><span class="line">                JTA：分布式事务管理</span><br><span class="line">                RESOURCE_LOCAL:本地事务管理</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;persistence-unit name=<span class="string">"myJpa"</span> transaction-type=<span class="string">"RESOURCE_LOCAL"</span>&gt;</span><br><span class="line">        &lt;!--jpa的实现方式--&gt;</span><br><span class="line">        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;!--配置数据库的信息</span><br><span class="line">                用户名：javax.persistence.jdbc.user</span><br><span class="line">                密码：javax.persistence.jdbc.password</span><br><span class="line">                驱动：javax.persistence.jdbc.driver</span><br><span class="line">                url：javax.persistence.jdbc.url--&gt;</span><br><span class="line"></span><br><span class="line">            &lt;property name=<span class="string">"javax.persistence.jdbc.user"</span> value=<span class="string">"root"</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=<span class="string">"javax.persistence.jdbc.password"</span> value=<span class="string">"root"</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=<span class="string">"javax.persistence.jdbc.driver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=<span class="string">"javax.persistence.jdbc.url"</span> value=<span class="string">"jdbc:mysql:///jpa"</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;!--配置实现方的信息（此处为hibernate）</span><br><span class="line">                <span class="number">1.</span>是否显示sql</span><br><span class="line">                <span class="number">2.</span>自动创建数据库表</span><br><span class="line">                    create:无表时创建，有表删除在创建</span><br><span class="line">                    update：没有表才创建</span><br><span class="line">                    none：无论有没有表都不会创建</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;property name=<span class="string">"hibernate.show_sql"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">            &lt;property name=<span class="string">"hibernate.format_sql"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">            &lt;property name=<span class="string">"hibernate.hbm2ddl.auto"</span> value=<span class="string">"update"</span> /&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/persistence-unit&gt;</span><br><span class="line">&lt;/persistence&gt;</span><br></pre></td></tr></table></figure><p>步骤四：进行单元测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package top.youngyang;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> top.youngyang.pojo.Customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityTransaction;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Persistence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJpa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建实体类管理器工厂，参数必须传入一个persistence-unit名称</span></span><br><span class="line">        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(<span class="string">"myJpa"</span>);</span><br><span class="line">        <span class="comment">//利用实体类管理器工厂创建实体类管理器</span></span><br><span class="line">        EntityManager entityManager = entityManagerFactory.createEntityManager();</span><br><span class="line">        <span class="comment">//获取事务，并且开启</span></span><br><span class="line">        EntityTransaction transaction = entityManager.getTransaction();</span><br><span class="line">        transaction.begin();</span><br><span class="line">        <span class="comment">//保存操作</span></span><br><span class="line">        Customer c = <span class="keyword">new</span> Customer(<span class="string">"hahha"</span>, <span class="number">11</span>);</span><br><span class="line">        entityManager.persist(c);</span><br><span class="line">        <span class="comment">//事务提交</span></span><br><span class="line">        transaction.commit();</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        entityManager.close();</span><br><span class="line">        entityManagerFactory.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>EntityManagerFactory</em></strong>：由javax.persistence.Persistence通过静态方法获得，主要是用来创建EntityManager。</p><p>由于EntityManagerFactory 是一个线程安全的对象（即多个线程访问同一个EntityManagerFactory 对象不会有线程安全问题），并且EntityManagerFactory 的创建极其浪费资源，所以在使用JPA编程时，我们可以对EntityManagerFactory 的创建进行优化，只需要做到一个工程只存在一个EntityManagerFactory 即可。</p><p><strong><em>EntityManager</em></strong>：在 JPA 规范中, EntityManager是完成持久化操作的核心对象。</p><p>实体类作为普通 java对象，只有在调用 EntityManager将其持久化后才会变成持久化对象。EntityManager对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。</p><p>我们可以通过调用EntityManager的方法完成获取事务，以及持久化数据库的操作。<br>方法说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getTransaction : 获取事务对象</span><br><span class="line">persist ： 保存操作</span><br><span class="line">merge ： 更新操作</span><br><span class="line">remove ： 删除操作</span><br><span class="line">find/getReference ： 根据id查询。</span><br><span class="line">注意：find为立即加载，getReference为延迟加载，即什么时候使用什么时候加载。</span><br></pre></td></tr></table></figure><h2 id="JPA的复杂查询"><a href="#JPA的复杂查询" class="headerlink" title="JPA的复杂查询"></a>JPA的复杂查询</h2><p>在JPA规范中也可使用JPQL完成复杂查询，JPQL全称Java Persistence Query Language。<strong>和sql相似，但是sql语句的查询来源和条件等等都是数据库表中的，而jpql语句则是从实体类中。</strong></p><p>使用jpql完成查询所有操作，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJSPL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">"myJpa"</span>);</span><br><span class="line">        EntityManager entityManager = factory.createEntityManager();</span><br><span class="line">        EntityTransaction tx = entityManager.getTransaction();</span><br><span class="line">        tx.begin();</span><br><span class="line">        <span class="comment">//编写jpql语句</span></span><br><span class="line">        String jpql = <span class="string">"from Customer"</span>;</span><br><span class="line">        Query query = entityManager.createQuery(jpql);</span><br><span class="line">        List resultList = query.getResultList();</span><br><span class="line">        <span class="keyword">for</span>(Object e:resultList)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如sql语句相似，也可使用带有占位符的jpql语句，如使用jpql完成条件查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJSPL2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">"myJpa"</span>);</span><br><span class="line">        EntityManager entityManager = factory.createEntityManager();</span><br><span class="line">        EntityTransaction tx = entityManager.getTransaction();</span><br><span class="line">        tx.begin();</span><br><span class="line">        String jpql = <span class="string">"from Customer where name like ?"</span>;</span><br><span class="line">        Query query = entityManager.createQuery(jpql);</span><br><span class="line">        <span class="comment">//占位符赋值从q开始</span></span><br><span class="line">        query.setParameter(<span class="number">1</span>,<span class="string">"ha%"</span>);</span><br><span class="line">        List resultList = query.getResultList();</span><br><span class="line">        <span class="keyword">for</span>(Object e:resultList)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="SpringDataJpa"><a href="#SpringDataJpa" class="headerlink" title="SpringDataJpa"></a>SpringDataJpa</h1><p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！</p><p>Spring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现，在实际的工作工程中，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦。</p><h2 id="SpringDataJpa、Hibernate和Jpa之间的关系"><a href="#SpringDataJpa、Hibernate和Jpa之间的关系" class="headerlink" title="SpringDataJpa、Hibernate和Jpa之间的关系"></a>SpringDataJpa、Hibernate和Jpa之间的关系</h2><p>JPA是一套规范，内部是有接口和抽象类组成的。hibernate是一套成熟的ORM框架，而且Hibernate实现了JPA规范，所以也可以称hibernate为JPA的一种实现方式，我们使用JPA的API编程，意味着站在更高的角度上看待问题（面向接口编程）。</p><p>Spring Data JPA是Spring提供的一套对JPA操作更加高级的封装，是在JPA规范下的专门用来进行数据持久化的解决方案。</p><p>三者之间的关系图：<br><img src="https://img-blog.csdnimg.cn/20200303113514754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>springdatajpa是对jpa规范的更加高级的封装，我们不在需要重复调用JPA规范完成功能，springdatajpa已经替我们完成。springdatajpa调用JPA规范完成功能，而JPA之是一套规范，只是一套接口和抽象类，底层还是使用hibernate完成实现，而hibernate对jdbc进行了封装，从而访问数据库。</p><h2 id="SpringDataJpa快速入门"><a href="#SpringDataJpa快速入门" class="headerlink" title="SpringDataJpa快速入门"></a>SpringDataJpa快速入门</h2><h3 id="步骤一：创建工程，导入坐标"><a href="#步骤一：创建工程，导入坐标" class="headerlink" title="步骤一：创建工程，导入坐标"></a>步骤一：创建工程，导入坐标</h3><p>使用Spring Data JPA，需要整合Spring与Spring Data JPA，并且需要提供JPA的服务提供者hibernate，所以需要导入spring相关坐标，hibernate坐标，数据库驱动坐标和SpringDataJpa坐标。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">      &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;</span><br><span class="line">      &lt;hibernate.version&gt;5.0.7.Final&lt;/hibernate.version&gt;</span><br><span class="line">      &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;</span><br><span class="line">      &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;</span><br><span class="line">      &lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt;</span><br><span class="line">      &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;4.9&lt;/version&gt;</span><br><span class="line">          &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;!-- spring aop相关jar包 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.6.8&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      </span><br><span class="line">&lt;!--spring ioc相关jar包--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">     &lt;!--spring对orm框架的支持--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- spring end --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- hibernate beg --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;5.2.1.Final&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- hibernate end --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- c3p0 连接池 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;c3p0&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;c3p0.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- c3p0 end --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- <span class="built_in">log</span>日志 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- <span class="built_in">log</span> end --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.9.0.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">&lt;!--spring的单元测试--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;!-- el beg 使用spring data jpa 必须引入 --&gt;</span><br><span class="line">      &lt;dependency&gt;  </span><br><span class="line">          &lt;groupId&gt;javax.el&lt;/groupId&gt;  </span><br><span class="line">          &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt;  </span><br><span class="line">          &lt;version&gt;2.2.4&lt;/version&gt;  </span><br><span class="line">      &lt;/dependency&gt;  </span><br><span class="line">      &lt;dependency&gt;  </span><br><span class="line">          &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;  </span><br><span class="line">          &lt;artifactId&gt;javax.el&lt;/artifactId&gt;  </span><br><span class="line">          &lt;version&gt;2.2.4&lt;/version&gt;  </span><br><span class="line">      &lt;/dependency&gt; </span><br><span class="line">      &lt;!-- el end --&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="整合SpringDataJpa和spring"><a href="#整合SpringDataJpa和spring" class="headerlink" title="整合SpringDataJpa和spring"></a>整合SpringDataJpa和spring</h3><p>applicationContext.xml文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:jdbc=<span class="string">"http://www.springframework.org/schema/jdbc"</span> xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">       xmlns:jpa=<span class="string">"http://www.springframework.org/schema/data/jpa"</span> xmlns:task=<span class="string">"http://www.springframework.org/schema/task"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/data/jpa</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--spring 和 spring data jpa的配置--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">1.</span>创建entityManagerFactory对象交给spring容器管理--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"entityManagerFactoty"</span> class=<span class="string">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span> /&gt;</span><br><span class="line">        &lt;!--配置的扫描的包（实体类所在的包） --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"packagesToScan"</span> value=<span class="string">"top.youngyang.pojo"</span> /&gt;</span><br><span class="line">        &lt;!-- jpa的实现厂家 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"persistenceProvider"</span>&gt;</span><br><span class="line">            &lt;bean class=<span class="string">"org.hibernate.jpa.HibernatePersistenceProvider"</span>/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--jpa的供应商适配器 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"jpaVendorAdapter"</span>&gt;</span><br><span class="line">            &lt;bean class=<span class="string">"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"</span>&gt;</span><br><span class="line">                &lt;!--配置是否自动创建数据库表 --&gt;</span><br><span class="line">                &lt;property name=<span class="string">"generateDdl"</span> value=<span class="string">"false"</span> /&gt;</span><br><span class="line">                &lt;!--指定数据库类型 --&gt;</span><br><span class="line">                &lt;property name=<span class="string">"database"</span> value=<span class="string">"MYSQL"</span> /&gt;</span><br><span class="line">                &lt;!--数据库方言：支持的特有语法 --&gt;</span><br><span class="line">                &lt;property name=<span class="string">"databasePlatform"</span> value=<span class="string">"org.hibernate.dialect.MySQLDialect"</span> /&gt;</span><br><span class="line">                &lt;!--是否显示sql --&gt;</span><br><span class="line">                &lt;property name=<span class="string">"showSql"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--jpa的方言 ：高级的特性 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"jpaDialect"</span> &gt;</span><br><span class="line">            &lt;bean class=<span class="string">"org.springframework.orm.jpa.vendor.HibernateJpaDialect"</span> /&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-<span class="number">-2.</span>创建数据库连接池 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"dataSource"</span> class=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"user"</span> value=<span class="string">"root"</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"jdbcUrl"</span> value=<span class="string">"jdbc:mysql:///jpa"</span> &gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"driverClass"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-<span class="number">-3.</span>整合spring dataJpa--&gt;</span><br><span class="line">    &lt;jpa:repositories base-package=<span class="string">"top.youngyang.dao"</span> transaction-manager-ref=<span class="string">"transactionManager"</span></span><br><span class="line">                      entity-manager-factory-ref=<span class="string">"entityManagerFactoty"</span> &gt;&lt;/jpa:repositories&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-<span class="number">-4.</span>配置事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"transactionManager"</span> class=<span class="string">"org.springframework.orm.jpa.JpaTransactionManager"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"entityManagerFactory"</span> ref=<span class="string">"entityManagerFactoty"</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">4.</span>txAdvice--&gt;</span><br><span class="line">    &lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"transactionManager"</span>&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"save*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"insert*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"update*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"delete*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"get*"</span> read-only=<span class="string">"true"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"find*"</span> read-only=<span class="string">"true"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">5.</span>aop--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">"pointcut"</span> expression=<span class="string">"execution(* top.youngyang.service.*.*(..))"</span> /&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">"txAdvice"</span> pointcut-ref=<span class="string">"pointcut"</span> /&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-<span class="number">-5.</span>声明式事务 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">6.</span> 配置IOC包扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">"top.youngyang"</span> &gt;&lt;/context:component-scan&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="步骤三-编写数据库表和实体类以及配置他们的关系"><a href="#步骤三-编写数据库表和实体类以及配置他们的关系" class="headerlink" title="步骤三 编写数据库表和实体类以及配置他们的关系"></a>步骤三 编写数据库表和实体类以及配置他们的关系</h3><p>此部分内容与JPA入门相应的内容相同。</p><h3 id="步骤四-编写符合Spring-Data-JPA规范的Dao层接口"><a href="#步骤四-编写符合Spring-Data-JPA规范的Dao层接口" class="headerlink" title="步骤四 编写符合Spring Data JPA规范的Dao层接口"></a>步骤四 编写符合Spring Data JPA规范的Dao层接口</h3><p>在Spring Data JPA中，对于定义符合规范的Dao层接口，我们只需要遵循以下几点就可以了：<br>1.创建一个Dao层接口，并实现JpaRepository和JpaSpecificationExecutor<br>2.提供相应的泛型。</p><p>dao接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package top.youngyang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaSpecificationExecutor;</span><br><span class="line"><span class="keyword">import</span> top.youngyang.pojo.Customer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JpaRepository&lt;实体类类型，主键类型&gt;：用来完成基本CRUD操作</span></span><br><span class="line"><span class="comment"> * JpaSpecificationExecutor&lt;实体类类型&gt;：用于复杂查询（分页等查询操作）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> interface CustomerDao extends JpaRepository&lt;Customer,Integer&gt;, JpaSpecificationExecutor&lt;Customer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤五-单元测试"><a href="#步骤五-单元测试" class="headerlink" title="步骤五 单元测试"></a>步骤五 单元测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package top.youngyang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> top.youngyang.dao.CustomerDao;</span><br><span class="line"><span class="keyword">import</span> top.youngyang.pojo.Customer;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)<span class="comment">//声明spring提供的测试环境</span></span><br><span class="line">@ContextConfiguration(<span class="string">"classpath:applicationContext.xml"</span>)<span class="comment">//指定spring配置文件的地方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringdataJpaTest</span> &#123;</span></span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Customer customer = customerDao.save(<span class="keyword">new</span> Customer(<span class="string">"1234"</span>, <span class="number">12</span>));</span><br><span class="line">        Assert.assertNotNull(customer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Customer customer = customerDao.findOne(<span class="number">3</span>);</span><br><span class="line">        Assert.assertNotNull(customer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringDataJpa的查询方式"><a href="#SpringDataJpa的查询方式" class="headerlink" title="SpringDataJpa的查询方式"></a>SpringDataJpa的查询方式</h1><p>在继承JpaRepository，和JpaRepository接口后,我们就可以使用接口中定义的方法进行查询</p><h2 id="1-继承JpaRepository后的方法列表"><a href="#1-继承JpaRepository后的方法列表" class="headerlink" title="1.继承JpaRepository后的方法列表"></a>1.继承JpaRepository后的方法列表</h2><p><img src="https://img-blog.csdnimg.cn/20200303215300743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-继承JpaSpecificationExecutor的方法列表"><a href="#2-继承JpaSpecificationExecutor的方法列表" class="headerlink" title="2.继承JpaSpecificationExecutor的方法列表"></a>2.继承JpaSpecificationExecutor的方法列表</h2><p><img src="https://img-blog.csdnimg.cn/20200303215323706.png" alt="在这里插入图片描述"></p><h2 id="3-使用JPQL语句查询"><a href="#3-使用JPQL语句查询" class="headerlink" title="3.使用JPQL语句查询"></a>3.使用JPQL语句查询</h2><p>使用Spring Data JPA继承自接口的查询方法已经可以解决大部分的应用场景，但是对于某些业务来说，我们还需要灵活的构造查询条件，这时就可以使用@Query注解，结合JPQL的语句方式完成查询</p><p>@Query 注解的使用非常简单，只需在方法上面标注该注解，同时提供一个JPQL查询语句即可，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface CustomerDao extends JpaRepository&lt;Customer,Integer&gt;, JpaSpecificationExecutor&lt;Customer&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用jpql定义自己的方法</span></span><br><span class="line">    @Query(<span class="string">"from Customer where id &gt; 2"</span>)</span><br><span class="line">    List&lt;Customer&gt; myFind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询。</p><p>若在jpql语句中使用到占位符，则方法中必须出现此参数，并且顺序不能改变，如要改变参数顺序，那么应该在占位符？后面加上索引(索引默认从1开始)，如?1。<br><strong>注意：在进行更新/删除操作时，要使用事物的支持（@Transactional），否则汇报异常。</strong></p><h2 id="4-使用SQL语句查询"><a href="#4-使用SQL语句查询" class="headerlink" title="4.使用SQL语句查询"></a>4.使用SQL语句查询</h2><p>在SpringDataJpa中不仅可以使用jpql语句查询，也可以使用sql语句查询，与jpql查询略有不同。需要在@Query注解中加入nativeQuery属性并设置为true，表明为本地查询（SQL查询），如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * nativeQuery : 使用本地sql的方式查询</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  @Query(value=<span class="string">"select * from cst_customer"</span>,nativeQuery=<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findSql</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="5-方法命名规则查询"><a href="#5-方法命名规则查询" class="headerlink" title="5.方法命名规则查询"></a>5.方法命名规则查询</h2><p>顾名思义，方法命名规则查询就是根据方法的名字，就能创建查询。只需要按照Spring Data JPA提供的方法命名规则定义方法的名称，就可以完成查询工作。Spring Data JPA在程序执行的时候会根据方法名称进行解析，并自动生成查询语句进行查询。</p><p>按照Spring Data JPA 定义的规则，查询方法以findBy开头，涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性首字母需大写。框架在进行方法名解析时，会先把方法名多余的前缀截取掉，然后对剩下部分进行解析。<br>如下所示：<br><img src="https://img-blog.csdnimg.cn/20200303223125680.png" alt="在这里插入图片描述"><br>此处表示模糊查询。</p><h1 id="SpringDataJpa动态查询"><a href="#SpringDataJpa动态查询" class="headerlink" title="SpringDataJpa动态查询"></a>SpringDataJpa动态查询</h1><p>有时我们在查询某个实体的时候，给定的条件是不固定的，这时就需要动态构建相应的查询语句，在Spring Data JPA中可以通过JpaSpecificationExecutor接口查询。相比JPQL,其优势是类型安全，更加的面向对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Sort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.domain.Specification;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *JpaSpecificationExecutor中定义的方法</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="keyword">public</span> interface JpaSpecificationExecutor&lt;T&gt; &#123;</span><br><span class="line">   <span class="comment">//根据条件查询一个对象</span></span><br><span class="line"> <span class="function">T <span class="title">findOne</span><span class="params">(Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">   <span class="comment">//根据条件查询集合</span></span><br><span class="line"> List&lt;T&gt; findAll(Specification&lt;T&gt; spec);</span><br><span class="line">   <span class="comment">//根据条件分页查询</span></span><br><span class="line"> Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable);</span><br><span class="line">   <span class="comment">//排序查询查询</span></span><br><span class="line"> List&lt;T&gt; findAll(Specification&lt;T&gt; spec, Sort sort);</span><br><span class="line">   <span class="comment">//统计查询</span></span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于JpaSpecificationExecutor，这个接口基本是围绕着Specification接口来定义的。我们可以简单的理解为，Specification构造的就是查询条件。</p><p><strong><em>Specification接口中只定义了如下一个方法：</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造查询条件</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*root：Root接口，代表查询的根对象，可以通过root获取实体中的属性</span></span><br><span class="line"><span class="comment">*query：代表一个顶层查询对象，用来自定义查询</span></span><br><span class="line"><span class="comment">*cb：用来构建查询，此对象里有很多条件方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="使用Specifications完成条件查询"><a href="#使用Specifications完成条件查询" class="headerlink" title="使用Specifications完成条件查询"></a>使用Specifications完成条件查询</h2><p><strong>注意：在使用精准查询（如name=zhangsan），可以直接进行查询，而其他的必须调用as()方法指定比较的对象，如as(String.class)。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依赖注入customerDao</span></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpecifications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//使用匿名内部类的方式，创建一个Specification的实现类，并实现toPredicate方法</span></span><br><span class="line">Specification &lt;Customer&gt; spec = <span class="keyword">new</span> Specification&lt;Customer&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123;</span><br><span class="line"><span class="comment">//cb:构建查询，添加查询方式   like：模糊匹配</span></span><br><span class="line"><span class="comment">//root：从实体Customer对象中按照custName属性进行查询</span></span><br><span class="line"><span class="keyword">return</span> cb.like(root.get(<span class="string">"custName"</span>).as(String.class), <span class="string">"传智播客%"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Customer customer = customerDao.findOne(spec);</span><br><span class="line">System.out.println(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若查询天条件存在多个，则需要调用CriteriaBuilder 中的and或者or方法进行合成。<br>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpec2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Specification&lt;Customer&gt; specification = <span class="keyword">new</span> Specification&lt;Customer&gt;() &#123;</span><br><span class="line">           <span class="keyword">public</span> Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123;</span><br><span class="line">               Path&lt;Object&gt; name = root.get(<span class="string">"name"</span>);</span><br><span class="line">               Path&lt;Object&gt; age = root.get(<span class="string">"age"</span>);</span><br><span class="line">               <span class="comment">//第一个条件</span></span><br><span class="line">               Predicate predicate1 = cb.equal(name, <span class="string">"haha"</span>);</span><br><span class="line">               <span class="comment">//第二个条件</span></span><br><span class="line">               Predicate predicate2 = cb.equal(age, <span class="number">11</span>);</span><br><span class="line">               <span class="comment">//两个条件进行合成</span></span><br><span class="line">               Predicate <span class="keyword">and</span> = cb.<span class="keyword">and</span>(predicate1, predicate2);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">and</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       Customer customer = customerDao.findOne(specification);</span><br><span class="line">       System.out.println(customer);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="基于Specifications的分页查询"><a href="#基于Specifications的分页查询" class="headerlink" title="基于Specifications的分页查询"></a>基于Specifications的分页查询</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   @Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造查询条件</span></span><br><span class="line">Specification&lt;Customer&gt; spec = <span class="keyword">new</span> Specification&lt;Customer&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123;</span><br><span class="line"><span class="keyword">return</span> cb.like(root.get(<span class="string">"custName"</span>).as(String.class), <span class="string">"传智%"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造分页参数</span></span><br><span class="line"><span class="comment"> * Pageable : 接口</span></span><br><span class="line"><span class="comment"> * PageRequest实现了Pageable接口，调用构造方法的形式构造</span></span><br><span class="line"><span class="comment"> * 第一个参数：页码（从0开始）</span></span><br><span class="line"><span class="comment"> * 第二个参数：每页查询条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询，封装为Spring Data Jpa 内部的page bean</span></span><br><span class="line"><span class="comment"> * 此重载的findAll方法为分页方法需要两个参数</span></span><br><span class="line"><span class="comment"> * 第一个参数：查询条件Specification</span></span><br><span class="line"><span class="comment"> * 第二个参数：分页参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Page&lt;Customer&gt; page = customerDao.findAll(spec,pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Spring Data JPA中的分页查询，是其内部自动实现的封装过程，返回的是一个Spring Data JPA提供的pageBean对象。其中的方法说明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//获取总页数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTotalPages</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">//获取总记录数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getTotalElements</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取列表数据</span></span><br><span class="line">List&lt;T&gt; getContent();</span><br></pre></td></tr></table></figure><h2 id="CriteriaBuilder-中的比较方法对应关系"><a href="#CriteriaBuilder-中的比较方法对应关系" class="headerlink" title="CriteriaBuilder 中的比较方法对应关系"></a>CriteriaBuilder 中的比较方法对应关系</h2><p>CriteriaBuilder 中的主要常用比较方法对应的关系如下所示：<br><img src="https://img-blog.csdnimg.cn/20200309165708392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="SpringDataJpa中的多表操作"><a href="#SpringDataJpa中的多表操作" class="headerlink" title="SpringDataJpa中的多表操作"></a>SpringDataJpa中的多表操作</h1><h2 id="JPA中的一对多"><a href="#JPA中的一对多" class="headerlink" title="JPA中的一对多"></a>JPA中的一对多</h2><p>我们采用的示例为客户和联系人。</p><p> 客户：指的是一家公司，我们记为A。<br> 联系人：指的是A公司中的员工。</p><p> 在不考虑兼职的情况下，公司和员工的关系即为一对多。</p><h3 id="表关系建立"><a href="#表关系建立" class="headerlink" title="表关系建立"></a>表关系建立</h3><p>在一对多关系中，我们习惯把一的一方称之为主表，把多的一方称之为从表。在数据库中建立一对多的关系，需要使用数据库的外键约束。</p><p>什么是外键？<br>指的是从表中有一列，取值参照主表的主键，这一列就是外键。</p><p>一对多数据库关系的建立，如下图所示 ：<br><img src="https://img-blog.csdnimg.cn/20200309185649593.png" alt="在这里插入图片描述"></p><h3 id="实体类关系建立以及映射配置"><a href="#实体类关系建立以及映射配置" class="headerlink" title="实体类关系建立以及映射配置"></a>实体类关系建立以及映射配置</h3><p>两张表的sql语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建客户表*/</span></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">cst_customer</span> <span class="params">(</span></span></span><br><span class="line">  cust_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)',</span><br><span class="line">  cust_name varchar(32) NOT NULL COMMENT '客户名称(公司名称)',</span><br><span class="line">  cust_source varchar(32) DEFAULT NULL COMMENT '客户信息来源',</span><br><span class="line">  cust_industry varchar(32) DEFAULT NULL COMMENT '客户所属行业',</span><br><span class="line">  cust_level varchar(32) DEFAULT NULL COMMENT '客户级别',</span><br><span class="line">  cust_address varchar(128) DEFAULT NULL COMMENT '客户联系地址',</span><br><span class="line">  cust_phone varchar(64) DEFAULT NULL COMMENT '客户联系电话',</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`cust_id`)</span></span></span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建联系人表*/</span></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">cst_linkman</span> <span class="params">(</span></span></span><br><span class="line">  lkm_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)',</span><br><span class="line">  lkm_name varchar(16) DEFAULT NULL COMMENT '联系人姓名',</span><br><span class="line">  lkm_gender char(1) DEFAULT NULL COMMENT '联系人性别',</span><br><span class="line">  lkm_phone varchar(16) DEFAULT NULL COMMENT '联系人办公电话',</span><br><span class="line">  lkm_mobile varchar(16) DEFAULT NULL COMMENT '联系人手机',</span><br><span class="line">  lkm_email varchar(64) DEFAULT NULL COMMENT '联系人邮箱',</span><br><span class="line">  lkm_position varchar(16) DEFAULT NULL COMMENT '联系人职位',</span><br><span class="line">  lkm_memo varchar(512) DEFAULT NULL COMMENT '联系人备注',</span><br><span class="line">  lkm_cust_id bigint(32) NOT NULL COMMENT '客户id(外键)',</span><br><span class="line">  PRIMARY KEY (`lkm_id`),</span><br><span class="line">  KEY `FK_cst_linkman_lkm_cust_id` (`lkm_cust_id`),</span><br><span class="line">  CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">3</span> DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>在实体类中，由于客户是少的一方，它应该包含多个联系人，所以实体类要体现出客户中有多个联系人的信息，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户的实体类</span></span><br><span class="line"><span class="comment"> * 明确使用的注解都是JPA规范的</span></span><br><span class="line"><span class="comment"> * 所以导包都要导入javax.persistence包下的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Entity<span class="comment">//表示当前类是一个实体类</span></span><br><span class="line">@Table(name=<span class="string">"cst_customer"</span>)<span class="comment">//建立当前实体类和表之间的对应关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line"></span><br><span class="line">@Id<span class="comment">//表明当前私有属性是主键</span></span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY)<span class="comment">//指定主键的生成策略</span></span><br><span class="line">@Column(name=<span class="string">"cust_id"</span>)<span class="comment">//指定和数据库表中的cust_id列对应</span></span><br><span class="line"><span class="keyword">private</span> Long custId;</span><br><span class="line">@Column(name=<span class="string">"cust_name"</span>)<span class="comment">//指定和数据库表中的cust_name列对应</span></span><br><span class="line"><span class="keyword">private</span> String custName;</span><br><span class="line">@Column(name=<span class="string">"cust_source"</span>)<span class="comment">//指定和数据库表中的cust_source列对应</span></span><br><span class="line"><span class="keyword">private</span> String custSource;</span><br><span class="line">@Column(name=<span class="string">"cust_industry"</span>)<span class="comment">//指定和数据库表中的cust_industry列对应</span></span><br><span class="line"><span class="keyword">private</span> String custIndustry;</span><br><span class="line">@Column(name=<span class="string">"cust_level"</span>)<span class="comment">//指定和数据库表中的cust_level列对应</span></span><br><span class="line"><span class="keyword">private</span> String custLevel;</span><br><span class="line">@Column(name=<span class="string">"cust_address"</span>)<span class="comment">//指定和数据库表中的cust_address列对应</span></span><br><span class="line"><span class="keyword">private</span> String custAddress;</span><br><span class="line">@Column(name=<span class="string">"cust_phone"</span>)<span class="comment">//指定和数据库表中的cust_phone列对应</span></span><br><span class="line"><span class="keyword">private</span> String custPhone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置客户和联系人的一对多关系</span></span><br><span class="line">  @OneToMany(targetEntity=LinkMan.class)</span><br><span class="line">@JoinColumn(name=<span class="string">"lkm_cust_id"</span>,referencedColumnName=<span class="string">"cust_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;LinkMan&gt; linkmans = <span class="keyword">new</span> HashSet&lt;LinkMan&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getCustId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustId</span><span class="params">(Long custId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custId = custId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustName</span><span class="params">(String custName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custName = custName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustSource</span><span class="params">(String custSource)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custSource = custSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustIndustry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custIndustry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustIndustry</span><span class="params">(String custIndustry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custIndustry = custIndustry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custLevel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustLevel</span><span class="params">(String custLevel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custLevel = custLevel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustAddress</span><span class="params">(String custAddress)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custAddress = custAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custPhone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustPhone</span><span class="params">(String custPhone)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custPhone = custPhone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Set&lt;LinkMan&gt; getLinkmans() &#123;</span><br><span class="line"><span class="keyword">return</span> linkmans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLinkmans</span><span class="params">(Set&lt;LinkMan&gt; linkmans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.linkmans = linkmans;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Customer [custId="</span> + custId + <span class="string">", custName="</span> + custName + <span class="string">", custSource="</span> + custSource</span><br><span class="line">+ <span class="string">", custIndustry="</span> + custIndustry + <span class="string">", custLevel="</span> + custLevel + <span class="string">", custAddress="</span> + custAddress</span><br><span class="line">+ <span class="string">", custPhone="</span> + custPhone + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于联系人是多的一方，在实体类中要体现出，每个联系人只能对应一个客户，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 联系人的实体类（数据模型）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Entity</span><br><span class="line">@Table(name=<span class="string">"cst_linkman"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkMan</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY)</span><br><span class="line">@Column(name=<span class="string">"lkm_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Long lkmId;</span><br><span class="line">@Column(name=<span class="string">"lkm_name"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmName;</span><br><span class="line">@Column(name=<span class="string">"lkm_gender"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmGender;</span><br><span class="line">@Column(name=<span class="string">"lkm_phone"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmPhone;</span><br><span class="line">@Column(name=<span class="string">"lkm_mobile"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmMobile;</span><br><span class="line">@Column(name=<span class="string">"lkm_email"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmEmail;</span><br><span class="line">@Column(name=<span class="string">"lkm_position"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmPosition;</span><br><span class="line">@Column(name=<span class="string">"lkm_memo"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmMemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多对一关系映射：多个联系人对应客户</span></span><br><span class="line">@ManyToOne(targetEntity=Customer.class)</span><br><span class="line">@JoinColumn(name=<span class="string">"lkm_cust_id"</span>,referencedColumnName=<span class="string">"cust_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Customer customer;<span class="comment">//用它的主键，对应联系人表中的外键</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getLkmId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmId</span><span class="params">(Long lkmId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmId = lkmId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmName</span><span class="params">(String lkmName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmName = lkmName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmGender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmGender</span><span class="params">(String lkmGender)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmGender = lkmGender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmPhone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmPhone</span><span class="params">(String lkmPhone)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmPhone = lkmPhone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmMobile;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmMobile</span><span class="params">(String lkmMobile)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmMobile = lkmMobile;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmEmail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmEmail</span><span class="params">(String lkmEmail)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmEmail = lkmEmail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmPosition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmPosition</span><span class="params">(String lkmPosition)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmPosition = lkmPosition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmMemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmMemo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmMemo</span><span class="params">(String lkmMemo)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmMemo = lkmMemo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> customer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.customer = customer;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"LinkMan [lkmId="</span> + lkmId + <span class="string">", lkmName="</span> + lkmName + <span class="string">", lkmGender="</span> + lkmGender + <span class="string">", lkmPhone="</span></span><br><span class="line">+ lkmPhone + <span class="string">", lkmMobile="</span> + lkmMobile + <span class="string">", lkmEmail="</span> + lkmEmail + <span class="string">", lkmPosition="</span> + lkmPosition</span><br><span class="line">+ <span class="string">", lkmMemo="</span> + lkmMemo + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射的注解说明"><a href="#映射的注解说明" class="headerlink" title="映射的注解说明"></a>映射的注解说明</h3><p>@OneToMany:<br>       作用：建立一对多的关系映射<br>    属性：<br>        targetEntityClass：指定多的多方的类的字节码<br>        mappedBy：指定从表实体类中引用主表对象的名称。<br>        cascade：指定要使用的级联操作<br>        fetch：指定是否采用延迟加载<br>        orphanRemoval：是否使用孤儿删除</p><p>@ManyToOne<br>    作用：建立多对一的关系<br>    属性：<br>        targetEntityClass：指定一的一方实体类字节码<br>        cascade：指定要使用的级联操作<br>        fetch：指定是否采用延迟加载<br>        optional：关联是否可选。如果设置为false，则必须始终存在非空关系。</p><p>@JoinColumn<br> 作用：用于定义主键字段和外键字段的对应关系。<br>     属性：<br>        name：指定外键字段的名称<br>        referencedColumnName：指定引用主表的主键字段名称<br>        unique：是否唯一。默认值不唯一<br>        nullable：是否允许为空。默认值允许。<br>        insertable：是否允许插入。默认值允许。<br>        updatable：是否允许更新。默认值允许。<br>        columnDefinition：列的定义信息。</p><h3 id="一对多的操作"><a href="#一对多的操作" class="headerlink" title="一对多的操作"></a>一对多的操作</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations=<span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneToManyTest</span> &#123;</span></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> LinkManDao linkManDao;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存操作</span></span><br><span class="line"><span class="comment"> * 需求:</span></span><br><span class="line"><span class="comment"> * 保存一个客户和一个联系人</span></span><br><span class="line"><span class="comment"> * 要求：</span></span><br><span class="line"><span class="comment"> * 创建一个客户对象和一个联系人对象</span></span><br><span class="line"><span class="comment"> *  建立客户和联系人之间关联关系（双向一对多的关联关系）</span></span><br><span class="line"><span class="comment"> *  先保存客户，再保存联系人</span></span><br><span class="line"><span class="comment"> * 问题：</span></span><br><span class="line"><span class="comment"> *当我们建立了双向的关联关系之后，先保存主表，再保存从表时：</span></span><br><span class="line"><span class="comment"> *会产生2条insert和1条update.</span></span><br><span class="line"><span class="comment"> * 而实际开发中我们只需要2条insert。  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Test</span><br><span class="line">@Transactional  <span class="comment">//开启事务</span></span><br><span class="line">@Rollback(<span class="literal">false</span>)<span class="comment">//设置为不回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Customer c = <span class="keyword">new</span> Customer();</span><br><span class="line">c.setCustName(<span class="string">"TBD云集中心"</span>);</span><br><span class="line">c.setCustLevel(<span class="string">"VIP客户"</span>);</span><br><span class="line">c.setCustSource(<span class="string">"网络"</span>);</span><br><span class="line">c.setCustIndustry(<span class="string">"商业办公"</span>);</span><br><span class="line">c.setCustAddress(<span class="string">"昌平区北七家镇"</span>);</span><br><span class="line">c.setCustPhone(<span class="string">"010-84389340"</span>);</span><br><span class="line"></span><br><span class="line">LinkMan l = <span class="keyword">new</span> LinkMan();</span><br><span class="line">l.setLkmName(<span class="string">"TBD联系人"</span>);</span><br><span class="line">l.setLkmGender(<span class="string">"male"</span>);</span><br><span class="line">l.setLkmMobile(<span class="string">"13811111111"</span>);</span><br><span class="line">l.setLkmPhone(<span class="string">"010-34785348"</span>);</span><br><span class="line">l.setLkmEmail(<span class="string">"98354834@qq.com"</span>);</span><br><span class="line">l.setLkmPosition(<span class="string">"老师"</span>);</span><br><span class="line">l.setLkmMemo(<span class="string">"还行吧"</span>);</span><br><span class="line"></span><br><span class="line">c.getLinkMans().add(l);</span><br><span class="line">l.setCustomer(c);</span><br><span class="line">customerDao.save(c);</span><br><span class="line">linkManDao.save(l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过保存的案例，我们可以发现在设置了双向关系之后，会发送两条insert语句，一条多余的update语句，那我们的解决是思路很简单，就是一的一方放弃维护权。<br>所以，我们只需要在从表配置他们的映射关系即可，否则会出现多余的update语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *放弃外键维护权的配置将如下配置改为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">//@OneToMany(targetEntity=LinkMan.class)</span></span><br><span class="line"><span class="comment">//@JoinColumn(name="lkm_cust_id",referencedColumnName="cust_id")</span></span><br><span class="line"><span class="comment">//设置为</span></span><br><span class="line">@OneToMany(mappedBy=<span class="string">"customer"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;LinkMan&gt; linkmans = <span class="keyword">new</span> HashSet&lt;LinkMan&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">@Transactional</span><br><span class="line">@Rollback(<span class="literal">false</span>)<span class="comment">//设置为不回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">customerDao.<span class="keyword">delete</span>(<span class="number">1l</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作的说明如下：</p><p>删除从表数据：可以随时任意删除。</p><p>删除主表数据：</p><p>若有从表数据<br>  1、在默认情况下，它会把外键字段置为null，然后删除主表数据。如果在数据库的表结构上，外键字段有非空约束，默认情况就会报错了。<br>  2、如果配置了放弃维护关联关系的权利，则不能删除（与外键字段是否允许为null，没有关系）因为在删除时，它根本不会去更新从表的外键字段了。<br>  3、如果还想删除，使用级联删除引用</p><p>若没有从表数据引用：随便删</p><p>在实际开发中，级联删除请慎用！(在一对多的情况下)</p><h4 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h4><p>级联操作：指操作一个对象同时操作它的关联对象<br><strong><em>使用方法：只需要在操作主体的注解上配置cascade</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cascade:配置级联操作</span></span><br><span class="line"><span class="comment"> * CascadeType.MERGE级联更新</span></span><br><span class="line"><span class="comment"> * CascadeType.PERSIST级联保存：</span></span><br><span class="line"><span class="comment"> * CascadeType.REFRESH 级联刷新：</span></span><br><span class="line"><span class="comment"> * CascadeType.REMOVE级联删除：</span></span><br><span class="line"><span class="comment"> * CascadeType.ALL包含所有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@OneToMany(mappedBy=<span class="string">"customer"</span>,cascade=CascadeType.ALL)</span><br></pre></td></tr></table></figure><h2 id="JPA中的多对多操作"><a href="#JPA中的多对多操作" class="headerlink" title="JPA中的多对多操作"></a>JPA中的多对多操作</h2><p>我们采用的示例为用户和角色。</p><p> 用户：指的是咱们班的每一个同学。<br> 角色：指的是咱们班同学的身份信息。</p><p> 比如A同学，它是我的学生，其中有个身份就是学生，还是家里的孩子，那么他还有个身份是子女。</p><p> 同时B同学，它也具有学生和子女的身份。</p><p> 那么任何一个同学都可能具有多个身份。同时学生这个身份可以被多个同学所具有。</p><p> 所以我们说，用户和角色之间的关系是多对多。</p><h3 id="表关系建立-1"><a href="#表关系建立-1" class="headerlink" title="表关系建立"></a>表关系建立</h3><p>多对多的表关系建立靠的是中间表，其中用户表和中间表的关系是一对多，角色表和中间表的关系也是一对多，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200311110814429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="实体类关系建立以及映射配置-1"><a href="#实体类关系建立以及映射配置-1" class="headerlink" title="实体类关系建立以及映射配置"></a>实体类关系建立以及映射配置</h3><p>一个用户可以具有多个角色，所以在用户实体类中应该包含多个角色的信息，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@Entity(targetEntity=Role.class)</span><br><span class="line">@Table(name=<span class="string">"sys_user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line"></span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY)</span><br><span class="line">@Column(name=<span class="string">"user_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Long userId;</span><br><span class="line">@Column(name=<span class="string">"user_code"</span>)</span><br><span class="line"><span class="keyword">private</span> String userCode;</span><br><span class="line">@Column(name=<span class="string">"user_name"</span>)</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line">@Column(name=<span class="string">"user_password"</span>)</span><br><span class="line"><span class="keyword">private</span> String userPassword;</span><br><span class="line">@Column(name=<span class="string">"user_state"</span>)</span><br><span class="line"><span class="keyword">private</span> String userState;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多对多关系映射</span></span><br><span class="line">@ManyToMany(mappedBy=<span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;SysRole&gt; roles = <span class="keyword">new</span> HashSet&lt;SysRole&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userId = userId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userCode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserCode</span><span class="params">(String userCode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userCode = userCode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userName = userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userPassword;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserPassword</span><span class="params">(String userPassword)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userPassword = userPassword;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserState</span><span class="params">(String userState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userState = userState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Set&lt;SysRole&gt; getRoles() &#123;</span><br><span class="line"><span class="keyword">return</span> roles;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(Set&lt;SysRole&gt; roles)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.roles = roles;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"SysUser [userId="</span> + userId + <span class="string">", userCode="</span> + userCode + <span class="string">", userName="</span> + userName + <span class="string">", userPassword="</span></span><br><span class="line">+ userPassword + <span class="string">", userState="</span> + userState + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个角色可以赋予多个用户，所以在角色实体类中应该包含多个用户的信息，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 角色的数据模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Entity</span><br><span class="line">@Table(name=<span class="string">"sys_role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysRole</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line"></span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY)</span><br><span class="line">@Column(name=<span class="string">"role_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Long roleId;</span><br><span class="line">@Column(name=<span class="string">"role_name"</span>)</span><br><span class="line"><span class="keyword">private</span> String roleName;</span><br><span class="line">@Column(name=<span class="string">"role_memo"</span>)</span><br><span class="line"><span class="keyword">private</span> String roleMemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多对多关系映射</span></span><br><span class="line">@ManyToMany(targetEntity = User.class)</span><br><span class="line">@JoinTable(name=<span class="string">"user_role_rel"</span>,<span class="comment">//中间表的名称</span></span><br><span class="line">  <span class="comment">//中间表user_role_rel字段关联sys_role表的主键字段role_id</span></span><br><span class="line">  joinColumns=&#123;@JoinColumn(name=<span class="string">"role_id"</span>,referencedColumnName=<span class="string">"role_id"</span>)&#125;,</span><br><span class="line">  <span class="comment">//中间表user_role_rel的字段关联sys_user表的主键user_id</span></span><br><span class="line">  inverseJoinColumns=&#123;@JoinColumn(name=<span class="string">"user_id"</span>,referencedColumnName=<span class="string">"user_id"</span>)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">private</span> Set&lt;SysUser&gt; users = <span class="keyword">new</span> HashSet&lt;SysUser&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getRoleId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> roleId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleId</span><span class="params">(Long roleId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.roleId = roleId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRoleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> roleName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleName</span><span class="params">(String roleName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.roleName = roleName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRoleMemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> roleMemo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleMemo</span><span class="params">(String roleMemo)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.roleMemo = roleMemo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Set&lt;SysUser&gt; getUsers() &#123;</span><br><span class="line"><span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsers</span><span class="params">(Set&lt;SysUser&gt; users)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.users = users;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"SysRole [roleId="</span> + roleId + <span class="string">", roleName="</span> + roleName + <span class="string">", roleMemo="</span> + roleMemo + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射注解说明"><a href="#映射注解说明" class="headerlink" title="映射注解说明"></a>映射注解说明</h3><p>@ManyToMany<br>    作用：用于映射多对多关系<br>    属性：<br>        cascade：配置级联操作。<br>        fetch：配置是否采用延迟加载。<br>        targetEntity：配置目标的实体类。映射多对多的时候不用写。</p><p>@JoinTable<br>    作用：针对中间表的配置<br>    属性：<br>        nam：配置中间表的名称<br>        joinColumns：中间表的外键字段关联当前实体类所对应表的主键字段<br>        inverseJoinColumn：中间表的外键字段关联对方表的主键字段</p><p>@JoinColumn<br>    作用：用于定义主键字段和外键字段的对应关系。<br>    属性：<br>        name：指定外键字段的名称<br>        referencedColumnName：指定引用主表的主键字段名称<br>        unique：是否唯一。默认值不唯一<br>        nullable：是否允许为空。默认值允许。<br>        insertable：是否允许插入。默认值允许。<br>        updatable：是否允许更新。默认值允许。<br>        columnDefinition：列的定义信息。</p><h3 id="多对多的操作"><a href="#多对多的操作" class="headerlink" title="多对多的操作"></a>多对多的操作</h3><h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   @Autowired</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> RoleDao roleDao;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：</span></span><br><span class="line"><span class="comment"> * 保存用户和角色</span></span><br><span class="line"><span class="comment"> * 要求：</span></span><br><span class="line"><span class="comment"> * 创建2个用户和3个角色</span></span><br><span class="line"><span class="comment"> * 让1号用户具有1号和2号角色(双向的)</span></span><br><span class="line"><span class="comment"> * 让2号用户具有2号和3号角色(双向的)</span></span><br><span class="line"><span class="comment"> *  保存用户和角色</span></span><br><span class="line"><span class="comment"> * 问题：</span></span><br><span class="line"><span class="comment"> *  在保存时，会出现主键重复的错误，因为都是要往中间表中保存数据造成的。</span></span><br><span class="line"><span class="comment"> * 解决办法：</span></span><br><span class="line"><span class="comment"> * 让任意一方放弃维护关联关系的权利</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Test</span><br><span class="line">@Transactional  <span class="comment">//开启事务</span></span><br><span class="line">@Rollback(<span class="literal">false</span>)<span class="comment">//设置为不回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">SysUser u1 = <span class="keyword">new</span> SysUser();</span><br><span class="line">u1.setUserName(<span class="string">"用户1"</span>);</span><br><span class="line">SysRole r1 = <span class="keyword">new</span> SysRole();</span><br><span class="line">r1.setRoleName(<span class="string">"角色1"</span>);</span><br><span class="line"><span class="comment">//建立关联关系</span></span><br><span class="line">u1.getRoles().add(r1);</span><br><span class="line">r1.getUsers().add(u1);</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line">roleDao.save(r1);</span><br><span class="line">userDao.save(u1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多对多（保存）中，如果双向都设置关系，意味着双方都维护中间表，都会往中间表插入数据，中间表的2个字段又作为联合主键，所以报错，主键重复，解决保存失败的问题：只需要在任意一方放弃对中间表的维护权即可，推荐在被动的一方放弃，配置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放弃对中间表的维护权，解决保存中主键冲突的问题</span></span><br><span class="line">@ManyToMany(mappedBy=<span class="string">"roles"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;SysUser&gt; users = <span class="keyword">new</span> HashSet&lt;SysUser&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除操作</span></span><br><span class="line"><span class="comment"> * 在多对多的删除时，双向级联删除根本不能配置</span></span><br><span class="line"><span class="comment"> * 禁用</span></span><br><span class="line"><span class="comment"> *如果配了的话，如果数据之间有相互引用关系，可能会清空所有数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Test</span><br><span class="line">@Transactional</span><br><span class="line">@Rollback(<span class="literal">false</span>)<span class="comment">//设置为不回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao.<span class="keyword">delete</span>(<span class="number">1l</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象导航查询"><a href="#对象导航查询" class="headerlink" title="对象导航查询"></a>对象导航查询</h3><p>对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。例如：我们通过ID查询方式查出一个客户，可以调用Customer类中的getLinkMans()方法来获取该客户的所有联系人。对象导航查询的使用要求是：两个对象之间必须存在关联关系。</p><p>查询一个客户，获取该客户下的所有联系人</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line"><span class="comment">//由于是在java代码中测试，为了解决no session问题，将操作配置到同一个事务中</span></span><br><span class="line">@Transactional </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Customer customer = customerDao.findOne(<span class="number">5l</span>);</span><br><span class="line">Set&lt;LinkMan&gt; linkMans = customer.getLinkMans();<span class="comment">//对象导航查询</span></span><br><span class="line"><span class="keyword">for</span>(LinkMan linkMan : linkMans) &#123;</span><br><span class="line"> System.out.println(linkMan);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询一个联系人，获取该联系人的所有客户</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> LinkManDao linkManDao;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkMan linkMan = linkManDao.findOne(<span class="number">4l</span>);</span><br><span class="line">Customer customer = linkMan.getCustomer(); <span class="comment">//对象导航查询</span></span><br><span class="line">System.out.println(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象导航查询的问题分析"><a href="#对象导航查询的问题分析" class="headerlink" title="对象导航查询的问题分析"></a>对象导航查询的问题分析</h4><p><strong><em>问题1：我们查询客户时，要不要把联系人查询出来？</em></strong></p><p>分析：如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的，不使用时又会白白的浪费了服务器内存。</p><p>解决：采用延迟加载的思想。通过配置的方式来设定当我们在需要使用时，发起真正的查询。（并且在多的一方进行查询，默认会立即加载直接查出一的一方的数据，而在一的一方查询，则会采用延迟加载的方式对多的一方进行查询，即用的时候才会发送sql语句进行查询。）<br>配置方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在客户对象的@OneToMany注解中添加fetch属性</span></span><br><span class="line"><span class="comment"> * FetchType.EAGER：立即加载</span></span><br><span class="line"><span class="comment"> * FetchType.LAZY：延迟加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@OneToMany(mappedBy=<span class="string">"customer"</span>,fetch=FetchType.EAGER)</span><br><span class="line"><span class="keyword">private</span> Set&lt;LinkMan&gt; linkMans = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong><em>问题2：我们查询联系人时，要不要把客户查询出来？</em></strong></p><p>分析：例如：查询联系人详情时，肯定会看看该联系人的所属客户。如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的话，一个对象不会消耗太多的内存。而且多数情况下我们都是要使用的。</p><p>解决： 采用立即加载的思想。通过配置的方式来设定，只要查询从表实体，就把主表实体对象同时查出来</p><p>配置方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在联系人对象的@ManyToOne注解中添加fetch属性</span></span><br><span class="line"><span class="comment"> * FetchType.EAGER：立即加载</span></span><br><span class="line"><span class="comment"> * FetchType.LAZY：延迟加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@ManyToOne(targetEntity=Customer.class,fetch=FetchType.EAGER)</span><br><span class="line">@JoinColumn(name=<span class="string">"cst_lkm_id"</span>,referencedColumnName=<span class="string">"cust_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Customer customer;</span><br></pre></td></tr></table></figure><h3 id="specifiction的多表查询"><a href="#specifiction的多表查询" class="headerlink" title="specifiction的多表查询"></a>specifiction的多表查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specification的多表查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Specification&lt;LinkMan&gt; spec = <span class="keyword">new</span> Specification&lt;LinkMan&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> Predicate toPredicate(Root&lt;LinkMan&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123;</span><br><span class="line"><span class="comment">//Join代表链接查询，通过root对象获取</span></span><br><span class="line"><span class="comment">//创建的过程中，第一个参数为关联对象的属性名称，第二个参数为连接查询的方式（left，inner，right）</span></span><br><span class="line"><span class="comment">//JoinType.LEFT : 左外连接,JoinType.INNER：内连接,JoinType.RIGHT：右外连接</span></span><br><span class="line">Join&lt;LinkMan, Customer&gt; join = root.join(<span class="string">"customer"</span>,JoinType.INNER);</span><br><span class="line"><span class="keyword">return</span> cb.like(join.get(<span class="string">"custName"</span>).as(String.class),<span class="string">"传智播客1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">List&lt;LinkMan&gt; <span class="built_in">list</span> = linkManDao.findAll(spec);</span><br><span class="line"><span class="keyword">for</span> (LinkMan linkMan : <span class="built_in">list</span>) &#123;</span><br><span class="line">System.out.println(linkMan);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学springdatajpa之前，我觉得非常有必要复习一下Jpa规范和orm思想。&lt;/p&gt;
&lt;h1 id=&quot;JPA入门&quot;&gt;&lt;a href=&quot;#JPA入门&quot; class=&quot;headerlink&quot; title=&quot;JPA入门&quot;&gt;&lt;/a&gt;JPA入门&lt;/h1&gt;&lt;h2 id=&quot;orm概
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Springboot中对mvc进行扩展</title>
    <link href="https://youngyang.top/2020/07/04/Springboot%E4%B8%AD%E5%AF%B9mvc%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/"/>
    <id>https://youngyang.top/2020/07/04/Springboot中对mvc进行扩展/</id>
    <published>2020-07-04T12:11:14.692Z</published>
    <updated>2020-07-04T12:08:10.233Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br>声明：本篇文章所有的内容都是基于<strong><em>springboot2.2.5</em></strong>的。</p><p>关于springboot对mvc的自动配置见我的另一篇博客：<a href="https://blog.csdn.net/qq_42013590/article/details/104879704" target="_blank" rel="noopener">https://blog.csdn.net/qq_42013590/article/details/104879704</a></p><p>对于已经有的自动配置显然很多时候并不能满足我们的需求，那么我们如何实现对mvc的扩展呢？</p><p><strong>观看其他博客结合看源码发现：<br>1）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置<br> 2）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（如：ViewResolver），sprngboot就会将用户配置的和自己默认的组合起来；<br> 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</strong></p><h1 id="实现WebMvcConfigurer接口"><a href="#实现WebMvcConfigurer接口" class="headerlink" title="实现WebMvcConfigurer接口"></a>实现WebMvcConfigurer接口</h1><p>springboot官方对于mvc的扩展时，建议我们实现WebMvcConfigurer接口，并且要将该实现类加入到容器中。</p><p>在以前比如 springboot1.x.x 的时候，我们可以继承WebMvcConfigurerAdapter这个抽象类来完成对mvc的扩展，但是这个类值·全部是对WebMvcConfigurer的空实现，远吗如下：<br><img src="https://img-blog.csdnimg.cn/20200319153243942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>对于在springboot 2.2.5版本已经废弃了这个类，idea中提示：<br><img src="https://img-blog.csdnimg.cn/20200319153343212.png" alt="在这里插入图片描述"><br>所以我们可以直接实现WebMvcConfigurer接口，反正WebMvcConfigurerAdapter也只是全部空实现。</p><p>并且WebMvcConfigurer接口中的方法全是default方法（java8之后支持在接口中定义default和static方法），所以我们可以只重写我们需要重写的方法：<br><img src="https://img-blog.csdnimg.cn/20200319154607545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们可以复写这个接口中的default方法实现扩展，比如：<br><img src="https://img-blog.csdnimg.cn/20200319155144587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中编写的我自己的登录拦截器如下所示：<br><img src="https://img-blog.csdnimg.cn/2020031916020254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="将组件加入到容器中替代默认配置"><a href="#将组件加入到容器中替代默认配置" class="headerlink" title="将组件加入到容器中替代默认配置"></a>将组件加入到容器中替代默认配置</h2><p>比如国际化需要的组件LocaleResolver：<br><img src="https://img-blog.csdnimg.cn/20200319155750729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以观察他的注解，只有<strong>容器中没有LocaleResolver这个组建的时候才帮我们自动配置</strong>，如果我们不想使用springboot的自动配置，我们可以写一个LocaleResolver并加入到容器中，这样默认的就会失效。</p><p><strong>步骤一：编写一个自己的LocaleResolver</strong><br>这个解析器的功能就是从get方式的请求中获取参数，在进行国际化，如下：<br><img src="https://img-blog.csdnimg.cn/20200319160245164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>步骤二：将国际化解析器加入到容器中</strong><br><img src="https://img-blog.csdnimg.cn/20200319163117609.png" alt="在这里插入图片描述"><br>这样就会自动替代springboot帮我们默认实现的。</p><h2 id="加入容器中一起生效"><a href="#加入容器中一起生效" class="headerlink" title="加入容器中一起生效"></a>加入容器中一起生效</h2><p>对于可以有多个生效的组件，我们只要将我们DIY的加入到容器中即可，例如ViewResolver，查看WebMvcAutoConfiguger：<br><img src="https://img-blog.csdnimg.cn/20200319162216134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>源码也是非常的体贴，还帮我们写了注释，ContentNegotiatingViewResolver会使用所有其他的视图解析器去定位一个视图，所以他应该有一个高的优先级，也就是会先加载他，他去帮我们调用其他的视图解析器。，之后debug的时候也可以看到。</p><p><strong>第一步：编写我自己ViewResolver：</strong><br><img src="https://img-blog.csdnimg.cn/20200319160952405.png" alt="在这里插入图片描述"><br> <strong>第二步：将自己编写的组件加入到容器中使之生效</strong><br><img src="https://img-blog.csdnimg.cn/20200319163742139.png" alt="在这里插入图片描述"><br><strong>第三步：debug查看我们的视图解析器是否生效</strong><br>DispaterServlet是web的入口，所有的请求都要经过它，其中的核心方法就是doService方法，doService()方法调用的是doDispater()方法，在这里设置一个断点，查看是否生效：<br><img src="https://img-blog.csdnimg.cn/20200319164053875.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200319164140114.png" alt="在这里插入图片描述"><br>可以观察到我们自己编写的ViewResolver已经加载进来了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;br&gt;声明：本篇文章所有的内容都是基于&lt;strong&gt;&lt;em&gt;springboot2.2.5&lt;/em&gt;&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;关于springboot对mvc的自动配置见我的另一篇博客：&lt;a href=&quot;https://blog.csdn.net
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>springboot中的日志框架</title>
    <link href="https://youngyang.top/2020/07/04/springboot%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"/>
    <id>https://youngyang.top/2020/07/04/springboot中的日志框架/</id>
    <published>2020-07-04T12:11:14.690Z</published>
    <updated>2020-07-04T12:08:10.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h1><p>在项目的开发中，日志是必不可少的一个记录事件的组件，所以也会相应的在项目中实现和构建我们所需要的日志框架。</p><p>而市面上常见的日志框架有很多，比如：JCL(Jakarta Commons Logging)、SLF4J、Jboss-logging、jUL(java.util.logging)、log4j、log4j2、logback等等，我们该如何选择呢？</p><p>通常情况下，<strong><em>日志是由一个抽象层+实现层的组合来搭建的</em></strong>。<br><img src="https://img-blog.csdnimg.cn/20200314115440271.png" alt="在这里插入图片描述"><br>而SpringBoot机智的选择了SLF4J+Logback的组合，这个组合是当下比较合适的一组（log4j2其实很厉害，但是太厉害还不能很好地整合）。</p><h1 id="SLF4J框架"><a href="#SLF4J框架" class="headerlink" title="SLF4J框架"></a>SLF4J框架</h1><p>SLF4J框架是一个常用的日志抽象层。<br>官网是最好的学习助手。<br>来到slf4j的官网的用户手册，我们可以在下边看到这张图：<br><img src="https://img-blog.csdnimg.cn/20200314115918774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>首先SLF4J是一个日志门面，我们如果使用需要再另外找到一个日志实现框架，比如log4j、logback、log4j2、jcl、jul等等。</p><p>并且slf4j和log4j以及logback是同一个人写的，先有的log4j，但是作者觉得这个框架功能并不是很理想，并且在log4j的基础上进行改进的话改进要很大，所以作者干脆一不做二不休又编写了另一个框架，也就是大名鼎鼎的Logback。</p><p>假如我们使用slf4j+logback，因为logback已经知道了slf4j的存在，所以可以完美搭配。但如果slf4j想要搭配其他框架的话，就要导入一个中间的过渡jar包，因为其他框架在编写之前并不知道slf4j的存在。</p><p>各种框架的过渡jar包如下所示：<br><img src="https://img-blog.csdnimg.cn/20200314120555427.png" alt="在这里插入图片描述"><br>这些jar包，往上实现了slf4j，往下内部又调用了log4j，jcl或者jul等等的方法，所以称之为过渡包。</p><p><strong>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件</strong></p><h1 id="遗留问题的解决"><a href="#遗留问题的解决" class="headerlink" title="遗留问题的解决"></a>遗留问题的解决</h1><p>在我们的项目中，可能同时使用到了许多框架，比如spring、mybatis、hibernate等等。但是这些框架底层使用到了许多不同的日志框架，比如spring的默认日志框架是commens-logging。</p><p>不同的框架使用不同的日志框架，这样我们的项目看起来就像是一个日志的杂交系统。</p><p><strong><em>那如何解决这种问题呢？</em></strong></p><p>来看看slf4j的官网告诉我们如何使用吧：<br><img src="https://img-blog.csdnimg.cn/20200314121150178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>slf4j官网的指示很明显，就是再用的时候需要导入一个“偷天换日包”。</p><p>因为如果直接将这些框架所依赖的日志框架jar包排除出去，系统肯定会报错。我们就要使用一个偷天换日包，偷梁换柱包，比如：<br><img src="https://img-blog.csdnimg.cn/20200314121345179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>拿spring举例子，因为spring必须使用commens-logging日志框架，而我们又想使用slf4j+logback的日志组合，那么我们必须要把commens-logging排除出去，但是怎么让系统不报错呢？</p><p>我们使用这些偷天换日包的话，就像jcl-over-slf4j.jar。这个jar的名字很明显就是从JCL想slf4j转化，它内部包的包名，包括类名都和JCL的完全相同，但是这些类中的方法全部是调用的slf4j的方法进行实现，这样我们就可以完美实现slf4j+logback组合，并且令系统不报错。</p><p>这样spring依旧使用JCL作为日志支持，但是他所使用的JCL已经不是原来的JCL了，原来的JCL已经被我们排除出去，使用的是我们导入的偷天换日包，这样就不会报错了。</p><p><strong><em>统一日志记录的思路（SpringBoot实现统一日志记录为slf4j的做法）：</em></strong></p><ol><li>先排除掉其他日志框架</li><li>然后用中间包来替换排除掉的日志框架</li><li>最后再添加目标日志框架</li></ol><h2 id="springboot的日志解决方案"><a href="#springboot的日志解决方案" class="headerlink" title="springboot的日志解决方案"></a>springboot的日志解决方案</h2><p>springboot使用的是<strong><em>slf4j+logback</em></strong>的组合。</p><p><strong><em>按照以前的想法：</em></strong><br>springboot的底层是spring，那么他必然依赖JCL，所以我们要先将原来的JCL排除出去，加入我们的偷天换日包。这个偷天换日包，包名和类名都是各种框架需要的包名和类名，以保证框架不会报错，但是底层实现都是通过slf4j的方法来实现的。这样就能实现slf4j+logback的组合了。</p><p>但是在我使用springboot2.2.5版本的时候发现，框架组合并不是按照原来盗用原来日志框架的包名和类名来实现的，而是通过桥接方式实现，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200314174107763.png" alt="在这里插入图片描述"><br>那么包名不是原来的包名的话，使用到jul的框架依旧会报错，点进这个类发现，虽然包名不是jul的包名，但是通过桥接模式依旧能让我们实现jul–&gt;slf4j的改变。</p><p><strong>在springboot2.0之后：</strong></p><p>在SpringBoot2.x版本的时候，上述的实现方式发生了一些改变，中间引入了”桥接”的概念，没有直接通过模拟类名实现，比如类：SLF4JBridgeHandler，但是其底层的实现方法都是类似的，都是通过排除原有依赖实现。</p><p>比如springboot2.2.5，快速创建一个springboot的web项目，进入pom文件：<br><img src="https://img-blog.csdnimg.cn/20200314122224798.png" alt="在这里插入图片描述"><br>打开项目的依赖图：<br><img src="https://img-blog.csdnimg.cn/20200314122308975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们可以看到，jul-to-slf4j.jar和log4j-to-slf4j.jar等等这些jar包，这些包都是偷天换日包，内部调用的都是slf4j的方法但是包名和类名都不变，这样就可以很好地和slf4j整合在一起了。</p><p>比如我们打开jul-to-slf4j.jar：<br><img src="https://img-blog.csdnimg.cn/20200314174107763.png" alt="在这里插入图片描述"><br>打开这个类，可以看到这个类的注释：<br><img src="https://img-blog.csdnimg.cn/2020031417483942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>大概意思是：这个handler将会把JUL重定向（redirect）到slf4j，但是这个handler仅仅能将JUL桥接到slf4j。</p><p>我觉得这种方式和原来的方式大同小异，都是排除原来依赖的日志jar包，然后导入一个过渡包，实现slf4j+JCL或者slf4j+JUL的整合。</p><p><strong><em>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可。</em></strong></p><h1 id="日志的使用"><a href="#日志的使用" class="headerlink" title="日志的使用"></a>日志的使用</h1><h2 id="springboot日志配置"><a href="#springboot日志配置" class="headerlink" title="springboot日志配置"></a>springboot日志配置</h2><p>那我们在配置好日志之后，如何使用呢？<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//日志的级别；</span></span><br><span class="line"><span class="comment">//由低到高 trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line"><span class="comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span></span><br><span class="line">logger.trace(<span class="string">"这是trace日志..."</span>);</span><br><span class="line">logger.debug(<span class="string">"这是debug日志..."</span>);</span><br><span class="line"><span class="comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span></span><br><span class="line">logger.info(<span class="string">"这是info日志..."</span>);</span><br><span class="line">logger.warn(<span class="string">"这是warn日志..."</span>);</span><br><span class="line">logger.error(<span class="string">"这是error日志..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<br><img src="https://img-blog.csdnimg.cn/20200314182841210.png" alt="在这里插入图片描述"><br>输出只有info，warn和error级别。日志的默认级别是info（也就是root级别），只有info和高于info级别的日志才能输出。</p><p>我们可以在配置文件application.properties中进行配置，如：<br><img src="https://img-blog.csdnimg.cn/2020031418311933.png" alt="在这里插入图片描述"><br>trace是最低级别，这样所有级别的日志信息都能输出出来。</p><p>我们还可以配置哪些东西呢？<br>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">logging.level.com.atguigu=trace</span><br><span class="line">#logging.path=</span><br><span class="line"># 不指定路径在当前项目下生成springboot.<span class="built_in">log</span>日志</span><br><span class="line"># 可以指定完整的路径；</span><br><span class="line">#logging.file=G:/springboot.<span class="built_in">log</span></span><br><span class="line"># 在当前磁盘的根路径下创建spring文件夹和里面的<span class="built_in">log</span>文件夹；使用 spring.<span class="built_in">log</span> 作为默认文件</span><br><span class="line">logging.path=/spring/<span class="built_in">log</span></span><br><span class="line"># 在控制台输出的日志的格式</span><br><span class="line">logging.pattern.console=%d&#123;yyyy‐MM‐dd&#125; [%thread] %‐<span class="number">5l</span>evel %logger&#123;<span class="number">50</span>&#125; ‐ %msg%n</span><br><span class="line"># 指定文件中日志输出的格式</span><br><span class="line">logging.pattern.file=%d&#123;yyyy‐MM‐dd&#125; === [%thread] === %‐<span class="number">5l</span>evel === %logger&#123;<span class="number">50</span>&#125; ==== %msg%n</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200314183341183.png" alt="在这里插入图片描述"><br>像这样配置到application.properties这样，如果这样的话也太low了，我们可以写一个logback的专门的配置文件，那么这个配置文件放到哪里呢？</p><p>再次提到我觉得官网是最好的学习助手。</p><p>来到spring官网没查看springboot2.2.5的使用手册，在logging一栏：<br><img src="https://img-blog.csdnimg.cn/2020031418590245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以我们可以把编写的logback.xml配置文件放到类路径的根目录下。这样springboot就可以自己帮我们加载进行配置了。</p><p>还有在命名为logback.xml之外，还有一个logback-spring.xml，如果这样命名的话就可以使用spriingboot为我们提供的logback的额外功能，官网是这么说的如如下图所示：<img src="https://img-blog.csdnimg.cn/20200314191756666.png" alt="在这里插入图片描述"><br>点进去主要有两个扩展功能：<br><img src="https://img-blog.csdnimg.cn/20200314192323153.png" alt="在这里插入图片描述"><br>那为什么我们改个名字就可以使用springboot为我们提供的额外功能呢？<br><img src="https://img-blog.csdnimg.cn/20200314192521424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>大概内容是这样的：因为标准的logback.xml文件会被日志框架过早的加载，所以你需要去使用logback-spring.xml或者定义一个logging.config。<br>这个拓展在logback的配置扫描下不能使用（logback-spring.xml会被spring扫描到），如果你非要这样使用，那么就会报这样一个错误。</p><p><strong><em>额外特性1：profile配置</em></strong><br><img src="https://img-blog.csdnimg.cn/20200314193209483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>大概意思就是，我们可以定义一个<springProfile></springProfile>标签，里边有个name属性，我们在name属性中指定这个配置在哪个profile中生效，在其他profile不会生效。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;appender name=<span class="string">"stdout"</span> class=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span><br><span class="line">&lt;!‐‐</span><br><span class="line">日志输出格式：</span><br><span class="line">%d表示日期时间，</span><br><span class="line">%thread表示线程名，</span><br><span class="line">%‐<span class="number">5l</span>evel：级别从左显示<span class="number">5</span>个字符宽度</span><br><span class="line">%logger&#123;<span class="number">50</span>&#125; 表示logger名字最长<span class="number">50</span>个字符，否则按照句点分割。</span><br><span class="line">%msg：日志消息，</span><br><span class="line">%n是换行符</span><br><span class="line">‐‐&gt;</span><br><span class="line">&lt;layout class=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span><br><span class="line">&lt;springProfile name=<span class="string">"dev"</span>&gt;</span><br><span class="line">&lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ‐‐‐‐&gt; [%thread] ‐‐‐&gt; %‐<span class="number">5l</span>evel</span><br><span class="line">%logger&#123;<span class="number">50</span>&#125; ‐ %msg%n&lt;/pattern&gt;</span><br><span class="line">&lt;/springProfile&gt;</span><br><span class="line">&lt;springProfile name=<span class="string">"!dev"</span>&gt;</span><br><span class="line">&lt;pattern&gt;%d&#123;yyyy‐MM‐dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %‐<span class="number">5l</span>evel</span><br><span class="line">%logger&#123;<span class="number">50</span>&#125; ‐ %msg%n&lt;/pattern&gt;</span><br><span class="line">&lt;/springProfile&gt;</span><br><span class="line">&lt;/layout&gt;</span><br><span class="line">&lt;/appender&gt;</span><br></pre></td></tr></table></figure><p><strong><em>额外功能2：环境属性</em></strong><br><img src="https://img-blog.csdnimg.cn/20200314193807757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以使用<springProperty></springProperty>标签，这个标签可以允许我们从application.yml中获取值，而并不是直接设一个值scope属性为该值使用的范围，source是获取值得来源，并使用${}的方式获该值。<br>使用方法如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;springProperty scope=<span class="string">"context"</span> name=<span class="string">"fluentHost"</span> source=<span class="string">"myapp.fluentd.host"</span></span><br><span class="line">        defaultValue=<span class="string">"localhost"</span>/&gt;</span><br><span class="line">&lt;appender name=<span class="string">"FLUENT"</span> class=<span class="string">"ch.qos.logback.more.appenders.DataFluentAppender"</span>&gt;</span><br><span class="line">    &lt;remoteHost&gt;$&#123;fluentHost&#125;&lt;/remoteHost&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/appender&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;日志框架&quot;&gt;&lt;a href=&quot;#日志框架&quot; class=&quot;headerlink&quot; title=&quot;日志框架&quot;&gt;&lt;/a&gt;日志框架&lt;/h1&gt;&lt;p&gt;在项目的开发中，日志是必不可少的一个记录事件的组件，所以也会相应的在项目中实现和构建我们所需要的日志框架。&lt;/p&gt;
&lt;p&gt;而
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>springboot的MVC自动配置</title>
    <link href="https://youngyang.top/2020/07/04/springboot%E7%9A%84MVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://youngyang.top/2020/07/04/springboot的MVC自动配置/</id>
    <published>2020-07-04T12:11:14.686Z</published>
    <updated>2020-07-04T12:08:10.316Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br>springboot为我们提供了springmvc的自动配置，所以我们可以直接编写逻辑就能实现功能。（如下内容都是基于springboot2.2.5）</p><p>比如万能的helloworld：<br><img src="https://img-blog.csdnimg.cn/20200315153747721.png" alt="在这里插入图片描述"><br>我们只要写一个controller就能自动映射到。</p><p>访问localhost:8080/hello，如下<br><img src="https://img-blog.csdnimg.cn/20200315153841850.png" alt="在这里插入图片描述"><br>那么springboot是如何帮助我们自动配置的呢？</p><h1 id="springboot对mvc的自动配置"><a href="#springboot对mvc的自动配置" class="headerlink" title="springboot对mvc的自动配置"></a>springboot对mvc的自动配置</h1><p>对于springmvc的自动配置全部在WebMvcAutoConfiguration.class类中。</p><p>ctrl+n搜索类，进入：<br><img src="https://img-blog.csdnimg.cn/20200315154044100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="对静态资源的自动配置"><a href="#对静态资源的自动配置" class="headerlink" title="对静态资源的自动配置"></a>对静态资源的自动配置</h2><p>看到如下关键方法：<br><img src="https://img-blog.csdnimg.cn/20200315154425747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="webjars"><a href="#webjars" class="headerlink" title="webjars"></a>webjars</h3><p>首先webjars是什么呢？<br>看官网的描述：<br><img src="https://img-blog.csdnimg.cn/20200315155118221.png" alt="在这里插入图片描述"><br>其实说白了，就是讲静态资源通过jar包的方式导入进来。</p><p>那么我们看看springboot是如何配置webjars的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">.addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于webjars，会自动帮我们添加一个映射。对于/webjars/**这样的资源回去类路径下的？META-INF/resources/webjars/路径下面去找。<br><img src="https://img-blog.csdnimg.cn/20200315154828716.png" alt="在这里插入图片描述">并且可以设置缓存时间，而缓存时间是从ResourceProperties下面去找的。<br><img src="https://img-blog.csdnimg.cn/20200315154919727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>关于ResourcesProperties我们可以从配置文件的spring.resources前缀的属性注入进来。</p><p>这样在浏览器访问localhost:8080/webjars/<strong>这个路径就会通过根路径的respurces/webjars/</strong>这个路径来寻找。<br>比如：我们导入jquery的一个jar包：<br><img src="https://img-blog.csdnimg.cn/20200315155351961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>只要导入进来，我们就可以通过访问localhost:8080/webjars/jquery/3.3.1/jquery.js来访问了，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200315155507640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="静态资源的位置配置"><a href="#静态资源的位置配置" class="headerlink" title="静态资源的位置配置"></a>静态资源的位置配置</h3><p>那么我们编写的静态资源应该放到哪里才可以被访问到呢，比如下面的ilogin.html<br><img src="https://img-blog.csdnimg.cn/2020031515565130.png" alt="在这里插入图片描述"></p><p>再来看springboot的自动配置：<br><img src="https://img-blog.csdnimg.cn/20200315155749234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那我们点进去看一下这是给我们配置到哪里去了呢？<br><img src="https://img-blog.csdnimg.cn/2020031515582611.png" alt="在这里插入图片描述"><br>经过一路跟踪，终于找到，springboot为我们自动配置的静态资源位置是如下几个：classpath:/MATA-INF/resources/、classpath:/resources/、classpath:/public/、classpath:/static/这几个位置，无论我们把静态资源放到这几个的哪一个都可以访问到：<br><img src="https://img-blog.csdnimg.cn/20200315160111167.png" alt="在这里插入图片描述"><br>通过测试abcd四个html都能被访问到。</p><h2 id="欢迎页的配置"><a href="#欢迎页的配置" class="headerlink" title="欢迎页的配置"></a>欢迎页的配置</h2><p>对于欢迎页的配置，springboot又是如何自动配置的呢？<br>还是进入WebMvcAutoConfiguration.class这个类：<br><img src="https://img-blog.csdnimg.cn/2020031516032831.png" alt="在这里插入图片描述"><br>进入这个构造方法里边，<br><img src="https://img-blog.csdnimg.cn/20200315160407460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200315160433808.png" alt="在这里插入图片描述"><br>观察这个类的注释：支持静态资源和模板文件，但是更喜欢静态资源。</p><p>也就是我们无论是吧index.html页面放到静态资源文件夹下，还是放在templates文件夹下都可以被访问到，但是如果两个路径下都包括index.html，那么优先加载静态资源下的index。</p><h2 id="全面接管springmvc"><a href="#全面接管springmvc" class="headerlink" title="全面接管springmvc"></a>全面接管springmvc</h2><p>如何全面接管springmvc呢，我们只要在一个组件上面加上@EnableWebMvc注解就行。</p><p>这样springboot为我们做的mvc自动配置全部都会失效，只会保留最初始的功能。<br>如下所示：<br><img src="https://img-blog.csdnimg.cn/20200315162509225.png" alt="在这里插入图片描述"><br>这样如果我们在访问webjars，比如：<a href="http://localhost:8080/webjars/jquery/3.3.1/jquery.js" target="_blank" rel="noopener">http://localhost:8080/webjars/jquery/3.3.1/jquery.js</a><br><img src="https://img-blog.csdnimg.cn/20200315162554334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>就不能访问到了。</p><p>为什么只要添加一个注解就不能访问到了呢？<br>可以进这个注解看一下：<br><img src="https://img-blog.csdnimg.cn/20200315162639603.png" alt="在这里插入图片描述"><br>这个注解很简单，就是向容器中导入了一个组件，那我们点进去看一下：<br><img src="https://img-blog.csdnimg.cn/20200315162724412.png" alt="在这里插入图片描述"><br>我们可以看到这个类继承了WrbConfigurationSupport这个类，再看看mvc的自动配置类：<br><img src="https://img-blog.csdnimg.cn/20200315162840580.png" alt="在这里插入图片描述"><br>mvc的自动配置类会判断在没有这个组件的情况下，才会生效</p><p>也就是说我们使用了这个@EnableWebMvc注解，就会使springboot自动配置的mvc失效。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;br&gt;springboot为我们提供了springmvc的自动配置，所以我们可以直接编写逻辑就能实现功能。（如下内容都是基于springboot2.2.5）&lt;/p&gt;
&lt;p&gt;比如万能的helloworld：&lt;br&gt;&lt;img src=&quot;https://img-bl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docke学习内容之二</title>
    <link href="https://youngyang.top/2020/07/04/docke%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E4%B9%8B%E4%BA%8C/"/>
    <id>https://youngyang.top/2020/07/04/docke学习内容之二/</id>
    <published>2020-07-04T12:10:15.182Z</published>
    <updated>2020-07-04T12:08:10.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h1><p>镜像是一种轻量级、可执行的独立软件包，<strong>用来打包软件运行环境和基于运行环境开发的软件</strong>，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><h2 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h2><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><h2 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统是UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel， Linux刚启动时会加载bootfs文件系统，<strong>在Docker镜像的最底层是bootfs</strong>。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。<br><img src="https://img-blog.csdnimg.cn/202001062159462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</strong><br><img src="https://img-blog.csdnimg.cn/20200106220000303.png" alt="在这里插入图片描述"><br>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><h2 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h2><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载。<br><img src="https://img-blog.csdnimg.cn/2020010622011221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>为什么docker镜像要采用这种分层的结构呢？</strong><br>最大的一个好处就是 - <strong>共享资源</strong>。<br>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，<br>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h2 id="镜像的特点"><a href="#镜像的特点" class="headerlink" title="镜像的特点"></a>镜像的特点</h2><p>docker镜像都是只读的。<br>当容器启动时，一个新的可写层被加载到镜像的顶部。<br>这一层通常称做“容器层”，“容器层”之下的都叫“镜像层”。</p><h2 id="docker镜像commit操作补充"><a href="#docker镜像commit操作补充" class="headerlink" title="docker镜像commit操作补充"></a>docker镜像commit操作补充</h2><p>docker commit是提交容器副本使之成为一个新的镜像。<br><strong>命令：docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:标签名</strong></p><p><strong>案例演示：</strong><br>1、从Hub上下载tomcat镜像到本地并运行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br><span class="line">docker run -it -p <span class="number">8888</span>:<span class="number">8080</span> --name mytomcat tomcat</span><br></pre></td></tr></table></figure><p>其中：-p：主机端口：docker端口；-i：交互；-t：终端。<br><img src="https://img-blog.csdnimg.cn/2020010622095457.png" alt="在这里插入图片描述"><br>启动成功后再本地访问8888端口就可以访问到那只cat了。<br><img src="https://img-blog.csdnimg.cn/20200106221311754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、故意删除上一步镜像产生tomcat容器的文档使此容器成为我自己的tomcat容器<br><img src="https://img-blog.csdnimg.cn/20200106221603606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3、将删除doc文档的容器作为一个模板提交到仓库<img src="https://img-blog.csdnimg.cn/20200106221628128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样我们就剩成了一个属于自己的镜像文件并提交到了仓库中。</p><h1 id="docker容器数据卷"><a href="#docker容器数据卷" class="headerlink" title="docker容器数据卷"></a>docker容器数据卷</h1><p>先来看看Docker的理念：</p><ul><li>将应用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</li><li>容器之间希望有可能共享数据</li></ul><p>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，<br>那么当容器删除后，数据自然也就没有了。</p><p>为了能保存docker中的数据我们使用卷，有点类似redis中的RDB(Redis database)和AOF(append only file)持久化。</p><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p><p>特点：<br>1：数据卷可在容器之间共享或重用数据<br>2：卷中的更改可以直接生效<br>3：数据卷中的更改不会包含在镜像的更新中<br>4：数据卷的生命周期一直持续到没有容器使用它为止</p><h2 id="容器内添加数据卷的两种方式"><a href="#容器内添加数据卷的两种方式" class="headerlink" title="容器内添加数据卷的两种方式"></a>容器内添加数据卷的两种方式</h2><h3 id="使用命令添加"><a href="#使用命令添加" class="headerlink" title="使用命令添加"></a>使用命令添加</h3><p><strong>docker run -it -v /宿主机绝对路径目录:/容器内目录 centos /bin/bash</strong><br><img src="https://img-blog.csdnimg.cn/20200106222147346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后在其中一方的目录中进行修改，另一方都可以看到，即实现了数据共享和持久化。<br><img src="https://img-blog.csdnimg.cn/20200106222401460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注：在容器停止退出之后，主机修改数据是否同步？<br>答：在容器重新启动之后依旧会同步。<br><img src="https://img-blog.csdnimg.cn/20200106222508707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>命令中可带权限，如<strong>docker run -it -v /宿主机绝对路径:/容器内目录:ro 镜像名</strong><br>其中：ro代表read only(只读)<br><img src="https://img-blog.csdnimg.cn/20200106222637273.png" alt="在这里插入图片描述"></p><h3 id="使用Docker-File添加"><a href="#使用Docker-File添加" class="headerlink" title="使用Docker File添加"></a>使用Docker File添加</h3><p><strong>步骤：</strong><br><strong>1、根目录下创建/mydocker并进入；</strong><br><strong>2、编写Dockerfile文件；</strong><br>创建Dockerfile文件，并在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷。<br><img src="https://img-blog.csdnimg.cn/20200106223323252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>说明：</strong><br>出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。<br><strong>3、build生成镜像；</strong><br><img src="https://img-blog.csdnimg.cn/20200106223348838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中-f代表file，指定Dockerfile的位置，若不使用-f选项，那么默认的文件是本目录的“Dockerfile”文件。<br>这样就生成了一个新的镜像zzyy/centos。<br><strong>4、run容器</strong><br><img src="https://img-blog.csdnimg.cn/20200106223427321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过上述方法，容器中的卷目录地址已经知道，那么主机中对应的主机目录地址在哪里？<br><img src="https://img-blog.csdnimg.cn/20200106223516621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106223825568.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106223838557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注：</strong><br>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied<br>解决办法：在挂载目录后多加一个–privileged=true参数即可</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为<strong>数据卷容器</strong>。</p><p>以上一步新建的zzyy/centos为模板，创建并运行容器dc01、dc02、dc03，那么他们已经有容器卷/dataVolumeContainer1和/dataVolumeContainer2了。</p><p><strong>容器中的传递共享：</strong></p><p><strong>1、先启动一个父容器dc01，并且在/dataVolumeContainer2内新增内容</strong><br><img src="https://img-blog.csdnimg.cn/2020010622420771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2、dc02和dc03继承自dc01，并且dc02和dc03也在/dataVolumeContainer2新增内容。</strong><br><img src="https://img-blog.csdnimg.cn/20200106224333497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3、回到dc01可以看到02和03各自添加的内容了，证明数据可以共享。</strong></p><p><strong>问题1：删除dc01，并修改dc02之后dc03可否看到？</strong><br>答：可以！<br><img src="https://img-blog.csdnimg.cn/20200106224617612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>问题2：删除dc02后dc03可否访问？</strong><br><img src="https://img-blog.csdnimg.cn/20200106224919738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106224942109.png" alt="在这里插入图片描述"><br><strong>结论：<br>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。</strong></p><h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>Dockerfile是用来构建docker镜像的构建文件，是有一系列命令和参数构成的脚本。</p><p>构建的步骤：<br>1、编写Dockerfile文件；<br>2、docker build；<br>3、docker run。</p><h2 id="Dockerfile构建过程解析"><a href="#Dockerfile构建过程解析" class="headerlink" title="Dockerfile构建过程解析"></a>Dockerfile构建过程解析</h2><h3 id="Dockerfile内容基础知识："><a href="#Dockerfile内容基础知识：" class="headerlink" title="Dockerfile内容基础知识："></a>Dockerfile内容基础知识：</h3><p><img src="https://img-blog.csdnimg.cn/20200107110856372.png" alt="1、"></p><h3 id="docker执行Dockerfile的大致流程"><a href="#docker执行Dockerfile的大致流程" class="headerlink" title="docker执行Dockerfile的大致流程"></a>docker执行Dockerfile的大致流程</h3><p><img src="https://img-blog.csdnimg.cn/20200107111108848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p><ul><li>Dockerfile是软件的原材料</li><li>Docker镜像是软件的交付品</li><li>Docker容器则可以认为是软件的运行态。<br>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。<br><img src="https://img-blog.csdnimg.cn/20200107111238124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</li></ul><p>2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</p><p>3 Docker容器，容器是直接提供服务的。</p><h2 id="Dockerfile的体系结构（保留字指令）"><a href="#Dockerfile的体系结构（保留字指令）" class="headerlink" title="Dockerfile的体系结构（保留字指令）"></a>Dockerfile的体系结构（保留字指令）<img src="https://img-blog.csdnimg.cn/20200107111508611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><p><strong>CMD和ENTRYPOINT镜像案例</strong>：<br>两者都是指定容器启东市要运行的命令。<br>1、Dockerfile中可以有多个CMD命令，但是只有最后一个生效，CMD会被docker run之后的参数替换掉，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p <span class="number">8888</span>:<span class="number">8080</span> tomcat /bash/shell</span><br></pre></td></tr></table></figure><p>2、而ENTRYPOINT会将docker run之后的参数追加到ENTRYPOINT后面。比如若在Dockerfile中是：<code>ENTRYPOINT [ &quot;ls&quot;, &quot;-l&quot; ]</code>，运行指令是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p <span class="number">8888</span>:<span class="number">8080</span> tomcat -a</span><br></pre></td></tr></table></figure><p>那么最后的ENTRYPOINT运行结果为ENTRYPOINT [ “ls”, “-l”,”-a” ]即进行追加。</p><p><strong>ONBUILD指令案例</strong>：<br><img src="https://img-blog.csdnimg.cn/20200107111700649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="案例：自定义tomcat镜像"><a href="#案例：自定义tomcat镜像" class="headerlink" title="案例：自定义tomcat镜像"></a>案例：自定义tomcat镜像</h2><p>Docker Hub中99%的镜像都是通过base镜像（scratch）中安装和配置需要的软件构建出来的。如：<br><img src="https://img-blog.csdnimg.cn/20200107111849313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>1、创建目录</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydocker/dockerfile/tomcat9</span><br></pre></td></tr></table></figure><p><strong>2、在上述目录下 touch c.txt<br>3、将jdk和tomcat安装的压缩包靠近上一步的目录中</strong><br><img src="https://img-blog.csdnimg.cn/20200107113222243.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020010711323214.png" alt="在这里插入图片描述"><br><strong>4、在上一步目录中新建Dockerfile文件</strong>，内容为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM         centos</span><br><span class="line">MAINTAINER    xyy&lt;<span class="number">1274268227</span>@qq.com&gt;</span><br><span class="line">#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下</span><br><span class="line">COPY c.txt /usr/local/cincontainer.txt</span><br><span class="line">#把java与tomcat添加到容器中</span><br><span class="line">ADD jdk<span class="number">-8u</span>171-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat<span class="number">-9.0</span><span class="number">.8</span>.tar.gz /usr/local/</span><br><span class="line">#安装vim编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#设置工作访问时候的WORKDIR路径，登录落脚点</span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">#配置java与tomcat环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1<span class="number">.8</span><span class="number">.0</span>_171</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span></span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span></span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line">#容器运行时监听的端口</span><br><span class="line">EXPOSE  <span class="number">8080</span></span><br><span class="line">#启动时运行tomcat</span><br><span class="line"># ENTRYPOINT [<span class="string">"/usr/local/apache-tomcat-9.0.8/bin/startup.sh"</span> ]</span><br><span class="line"># CMD [<span class="string">"/usr/local/apache-tomcat-9.0.8/bin/catalina.sh"</span>,<span class="string">"run"</span>]</span><br><span class="line">CMD /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span>/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span>/bin/logs/catalina.out</span><br></pre></td></tr></table></figure><p>5、docker build构建镜像文件<br>6、docker run创建并运行容器<br>7、访问本地端口，查看能否访问到那只猫</p><h2 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h2><p><img src="https://img-blog.csdnimg.cn/20200107113609376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker镜像&quot;&gt;&lt;a href=&quot;#docker镜像&quot; class=&quot;headerlink&quot; title=&quot;docker镜像&quot;&gt;&lt;/a&gt;docker镜像&lt;/h1&gt;&lt;p&gt;镜像是一种轻量级、可执行的独立软件包，&lt;strong&gt;用来打包软件运行环境和基于运行环境开发
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker学习内容之一</title>
    <link href="https://youngyang.top/2020/07/04/docker%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E4%B9%8B%E4%B8%80/"/>
    <id>https://youngyang.top/2020/07/04/docker学习内容之一/</id>
    <published>2020-07-04T12:10:15.180Z</published>
    <updated>2020-07-04T12:08:10.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><h2 id="为什么会有docker出现"><a href="#为什么会有docker出现" class="headerlink" title="为什么会有docker出现"></a>为什么会有docker出现</h2><p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验。</p><p>Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，<strong>软件可以带环境安装？</strong>也就是说，<strong>安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题</strong>。<br><img src="https://img-blog.csdnimg.cn/2020010619251885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿我做过的的电商项目的环境来说吧，Java/Tomcat/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p><p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，<strong>开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</strong></p><h2 id="关于docker"><a href="#关于docker" class="headerlink" title="关于docker"></a>关于docker</h2><p>Docker是基于Go语言实现的云开源项目。</p><p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到<strong>“一次封装，到处运行</strong>”。<br><img src="https://img-blog.csdnimg.cn/20200106192641662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</strong></p><h2 id="容器虚拟化技术与虚拟机技术"><a href="#容器虚拟化技术与虚拟机技术" class="headerlink" title="容器虚拟化技术与虚拟机技术"></a>容器虚拟化技术与虚拟机技术</h2><h3 id="虚拟机技术"><a href="#虚拟机技术" class="headerlink" title="虚拟机技术"></a>虚拟机技术</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。<br>它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。<br><img src="https://img-blog.csdnimg.cn/20200106192853747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>虚拟机的缺点：</strong><br>        1    资源占用多               2    冗余步骤多                 3    启动慢</p><h3 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h3><p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p><p><strong>Linux 容器不是模拟一个完整的操作系统</strong>，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。<br><img src="https://img-blog.csdnimg.cn/20200106193143427.png" alt="在这里插入图片描述"><br><strong>比较了 Docker 和传统虚拟化方式的不同之处：</strong><br>1、传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；<br>2、而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。<br>3、每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p><h3 id="为什么docker比虚拟机快"><a href="#为什么docker比虚拟机快" class="headerlink" title="为什么docker比虚拟机快"></a>为什么docker比虚拟机快</h3><p>(1)docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>(2)docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。<br><img src="https://img-blog.csdnimg.cn/202001062029425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106202953816.png" alt="在这里插入图片描述"></p><h2 id="docker的优势"><a href="#docker的优势" class="headerlink" title="docker的优势"></a>docker的优势</h2><p><strong>1、更快速的应用交付和部署</strong><br>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。<br><strong>2、更便捷的升级和扩缩容</strong><br>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。<br><strong>3、更简单的系统运维</strong><br>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。<br><strong>4、更高效的计算资源利用</strong><br>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p><h2 id="docker的三大基本组成"><a href="#docker的三大基本组成" class="headerlink" title="docker的三大基本组成"></a>docker的三大基本组成</h2><p>docker的整体架构图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200106195139668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>1、镜像（image）</strong>：Docker 镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建 Docker 容器，<strong>一个镜像可以创建很多容器</strong>。（镜像和容器我觉得和java中的类和对象相似，类就是创建对象的模板，并且一个类可以创建多个对象。）<br><strong>2、容器（container）</strong>：Docker 利用容器（Container）独立运行的一个或一组应用。<strong>容器是用镜像创建的运行实例。</strong></p><p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p><strong>可以把容器看做是一个简易版的 Linux 环境</strong>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。<br><strong>3、仓库（repository）</strong>：仓库（Repository）是集中存放镜像文件的场所。</p><p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云" target="_blank" rel="noopener">https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云</a> 、网易云 等。</p><p><strong>总结：</strong><br>我们需要正确的理解仓储/镜像/容器这几个概念。Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器。至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。</p><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>Docker支持以下的CentOS版本：CentOS 7 (64-bit)，CentOS 6.5 (64-bit) 或更高的版本。</p><p>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</p><p><strong>如何查看自己的内核：</strong><br>uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。<br><img src="https://img-blog.csdnimg.cn/20200106194238941.png" alt="在这里插入图片描述"><br><strong>查看已安装的CentOS版本信息（CentOS6.8有，CentOS7无该命令）：</strong><br><img src="https://img-blog.csdnimg.cn/20200106194327871.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200106194330561.png" alt="在这里插入图片描述"></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可以去docker的官网下载安装包：<a href="http://www.docker.com" target="_blank" rel="noopener">http://www.docker.com</a><br>docker的仓库：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>centos 6和centos 7的安装步骤略有不同，我是centos 7.3，所以是centos 7的安装教程。<br>1、安装gcc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure><p>2、如果原来安装过docker，需要卸载掉旧版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><p>3、安装需要的软件包</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>4、设置stable镜像仓库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http:<span class="comment">//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure><p>5、更新yum软件包索引</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>6、安装DOCKER CE</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure><p>7、启动docker</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>8、测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>9、去阿里云配置镜像加速<br>阿里云官网的容器镜像服务栏中找到镜像加速器，根据提示设置即可：<br><img src="https://img-blog.csdnimg.cn/20200106202449834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>10、卸载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syatemctl stop docker</span><br><span class="line">yum -y remove docker-ce</span><br><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure><h1 id="docker的常用命令"><a href="#docker的常用命令" class="headerlink" title="docker的常用命令"></a>docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>1、docker images</strong>：列出本地主机上的镜像。<br><img src="https://img-blog.csdnimg.cn/20200106210229594.png" alt="在这里插入图片描述"><br>上图中各个选项说明:<br>REPOSITORY：表示镜像的仓库源<br>TAG：镜像的标签<br>IMAGE ID：镜像ID<br>CREATED：镜像创建时间<br>SIZE：镜像大小<br> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。<br> 选项说明：<br> -a：列出本地所有的镜像（含中间映像层）；<br> -q：只显示镜像ID；<br> –digests：显示镜像的摘要信息<br> –no-trunc：显示完整的镜像信息<br> <strong>2、docker search 镜像名字</strong>：从dockerHub上查找响应的镜像。<br>  <strong>3、docker pull 镜像名字:TAG</strong>：下载镜像，若不指定TAG标签，则默认下载latest镜像。<br>  <strong>4、docker rmi 镜像名字id</strong>：删除镜像<br>  删除单个：docker rmi -f 镜像ID；<br>  删除多个：docker rmi -f 镜像名1:TAG1 镜像名2:TAG2；<br>  删除全部：docker rmi -f $(docker images -qa)；</p><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>有镜像才能生成容器实例，首先先从镜像仓库pull镜像文件，如：docker pull centos。<br><strong>1、新建并启动容器:docker run [options] image [commends]</strong></p><p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号<br>–name=”容器新名字”: 为容器指定一个名称；<br>-d: 后台运行容器，并返回容器ID，也即启动守护式容器；<br><strong>-i：以交互模式运行容器，通常与 -t 同时使用；<br>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</strong><br>-P: 随机端口映射；<br>-p: 指定端口映射，有以下四种格式<br>      ip:hostPort:containerPort<br>      ip::containerPort<br>      <strong>hostPort:containerPort</strong><br>      containerPort</p><p><strong>启动交互式容器：</strong><br>使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。<br>docker run -it centos /bin/bash <img src="https://img-blog.csdnimg.cn/20200106212545439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2、列出当前所有正在运行的容器：docker ps [options]</strong></p><p>OPTIONS说明（常用）：<br>-a :列出当前所有正在运行的容器+历史上运行过的<br>-l :显示最近创建的容器。<br>-n：显示最近n个创建的容器。<br>-q :静默模式，只显示容器编号。<br>–no-trunc :不截断输出。<br><strong>3、退出容器</strong><br>退出容器有两种方式：<br>1、exit：容器停止并退出。<br>2、ctrl+Q+P：容器不停止退出<br><strong>4、启动容器：docker start 容器ID或者容器名<br>5、重启容器：docker restart 容器ID或者容器名<br>6、停止容器：docker stop 容器ID或者容器名<br>7、强制停止容器：docker kill 容器ID或者容器名<br>8、删除已停止的容器：docker rm 容器ID</strong><br>一次性删除多个容器：docker rm -f $(docker ps -qa)</p><p><strong>重要命令总结：</strong><br><strong>1、启动守护式容器：docker run -d 容器名</strong></p><p>使用镜像centos:latest以后台模式启动一个容器<br>docker run -d centos<br>问题：然后docker ps -a 进行查看, 会发现容器已经退出<br>很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.<br>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p><p>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如<br>service nginx start<br>但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,<br>这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.<br>所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行。<br><strong>2、查看容器日志：docker logs -f -t -tail容器ID</strong><br>其中：</p><ul><li>-t 是加入时间戳</li><li>-f 跟随最新的日志打印</li><li>–tail 数字 显示最后多少条</li><li>如：首先启动守护式容器：docker run -d centos /bin/sh -c “while true;do echo hello zzyy;sleep 2;done”<br><img src="https://img-blog.csdnimg.cn/20200106213545344.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106213622451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><em>3、查看容器内运行的进程：docker top 容器ID<br>4、查看容器内部细节：docker inspect 容器ID<br>5、进入正在运行的容器并以命令行交互：*</em><br>1、docker exec -it 容器ID basnshell<br><img src="https://img-blog.csdnimg.cn/20200106213846640.png" alt="在这里插入图片描述"><br>2、重新进入：docker attach 容器ID<br>上述两种方式的区别：<br>attach直接进入容器启动命令的终端，不会启动新的进程；<br>exec是在容器中打开新的终端，并且可以启动新的进程。</li><li><em>6、从容器内拷贝文件到主机上：docker cp 容器ID:容器内路径 目的主机路径*</em></li></ul><p><strong>总结：</strong><br><img src="https://img-blog.csdnimg.cn/20200106214131826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像<br>build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像<br>commit    Create a new image from a container changes   # 提交当前容器为新的镜像<br>cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中<br>create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器<br>diff      Inspect changes on a container’s filesystem   # 查看 docker 容器变化<br>events    Get real time events from the server          # 从 docker 服务获取容器实时事件<br>exec      Run a command in an existing container        # 在已存在的容器上运行命令<br>export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]<br>history   Show the history of an image                  # 展示一个镜像形成历史<br>images    List images                                   # 列出系统当前镜像<br>import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]<br>info      Display system-wide information               # 显示系统相关信息<br>inspect   Return low-level information on a container   # 查看容器详细信息<br>kill      Kill a running container                      # kill 指定 docker 容器<br>load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]<br>login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器<br>logout    Log out from a Docker registry server          # 从当前 Docker registry 退出<br>logs      Fetch the logs of a container                 # 输出当前容器日志信息<br>port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口<br>pause     Pause all processes within a container        # 暂停容器<br>ps        List containers                               # 列出容器列表<br>pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像<br>push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器<br>restart   Restart a running container                   # 重启运行的容器<br>rm        Remove one or more containers                 # 移除一个或者多个容器<br>rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]<br>run       Run a command in a new container              # 创建一个新的容器并运行一个命令<br>save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]<br>search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像<br>start     Start a stopped containers                    # 启动容器<br>stop      Stop a running containers                     # 停止容器<br>tag       Tag an image into a repository                # 给源中镜像打标签<br>top       Lookup the running processes of a container   # 查看容器中运行的进程信息<br>unpause   Unpause a paused container                    # 取消暂停容器<br>version   Show the docker version information           # 查看 docker 版本号<br>wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker简介&quot;&gt;&lt;a href=&quot;#docker简介&quot; class=&quot;headerlink&quot; title=&quot;docker简介&quot;&gt;&lt;/a&gt;docker简介&lt;/h1&gt;&lt;h2 id=&quot;为什么会有docker出现&quot;&gt;&lt;a href=&quot;#为什么会有docker出现&quot; c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java 8之流式计算</title>
    <link href="https://youngyang.top/2020/07/04/Java%208%E4%B9%8B%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    <id>https://youngyang.top/2020/07/04/Java 8之流式计算/</id>
    <published>2020-07-04T12:10:15.164Z</published>
    <updated>2020-07-04T12:08:11.484Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。用周阳大神的话说就是：SQL就是JAVA，JAVA就是SQL。使用java.util.stream包中的Stream接口即可完成SQL中的计算、order by、where等操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。流式操作实现了集合的过滤、排序、映射等功能。</p><h1 id="四大内置核心函数式接口"><a href="#四大内置核心函数式接口" class="headerlink" title="四大内置核心函数式接口"></a>四大内置核心函数式接口</h1><p>大部分函数式接口都不用我们自己写，Java 8都给我们写好了，这些接口都在java.util.function包里，下面简单介绍其中的几个。而在讲到Java 8中利用Stream的流式计算的时候，就不得不提及到java.util.function包中的四大函数式接口，分别是<strong>Function</strong>函数接口、<strong>Predicate</strong>函数式接口、<strong>Consumer</strong>函数式接口和<strong>Supplier</strong>函数式接口。</p><h2 id="Function函数型函数式接口"><a href="#Function函数型函数式接口" class="headerlink" title="Function函数型函数式接口"></a>Function函数型函数式接口</h2><p> Function接口为函数型接口，该接口的抽象方法接收一个参数并且做一些处理然后返回返回一个参数。其中T为接收参数类型，R为返回参数类型。<br> 源码如下：其中的抽象方法为 <strong>R apply(T t)</strong><img src="https://img-blog.csdnimg.cn/20191115170254736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Predicate断言型函数式接口"><a href="#Predicate断言型函数式接口" class="headerlink" title="Predicate断言型函数式接口"></a>Predicate断言型函数式接口</h2><p>Predicate 用于做判断操作，所以抽象方法返回的是Boolean。<br>源码如下：抽象方法为： <strong>boolean test(T t)</strong><br><img src="https://img-blog.csdnimg.cn/20191115170814909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Consumer消费型函数式接口"><a href="#Consumer消费型函数式接口" class="headerlink" title="Consumer消费型函数式接口"></a>Consumer<strong>消费型函数式接口</strong></h2><p>Consumer表示执行在单个参数上面的操作，但没有返回值的（正如消费有去无回）。<br>该类的源码如下：抽象方法为：<strong>void accept(T t)</strong><br><img src="https://img-blog.csdnimg.cn/20191115171119346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Supplier供给型函数式接口"><a href="#Supplier供给型函数式接口" class="headerlink" title="Supplier供给型函数式接口"></a>Supplier<strong>供给型函数式接口</strong></h2><p>该接口不接受任何参数，返回一个任意泛型的值。<br>该类的源码如下：<strong>T get()</strong><br><img src="https://img-blog.csdnimg.cn/20191115171253184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/20191115171323494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1><p>流(Stream) 到底是什么呢？<br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！”</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、Stream 自己不会存储元素。<br>2、Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。<br>3、Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>1、创建一个Stream：一个数据源（数组、集合）。（如list.stream()将List转换为Stream）<br>2、中间操作：一个中间操作，处理数据源数据。<br>3、终止操作：一个终止操作，执行中间操作链，产生结果。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.juc.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String  userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：请按照给出数据，找出同时满足</span></span><br><span class="line"><span class="comment"> *      偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序</span></span><br><span class="line"><span class="comment"> *      最后只输出一个用户名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">11</span>,<span class="string">"a"</span>,<span class="number">23</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">12</span>,<span class="string">"b"</span>,<span class="number">24</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">13</span>,<span class="string">"c"</span>,<span class="number">22</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">14</span>,<span class="string">"d"</span>,<span class="number">28</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">16</span>,<span class="string">"e"</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; <span class="built_in">list</span> = Arrays.asList(u1,u2,u3,u4,u5);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span>.stream().filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getId() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;).filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getAge() &gt; <span class="number">24</span>;</span><br><span class="line">        &#125;).<span class="built_in">map</span>(f -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> f.getUserName().toUpperCase();</span><br><span class="line">        &#125;).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    R apply(T t);</span></span><br><span class="line">        Function&lt;String,Integer&gt; function = t -&gt; &#123;<span class="keyword">return</span> t.length();&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">"abc"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean test(T t);</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = t -&gt; &#123;<span class="keyword">return</span> t.startsWith(<span class="string">"a"</span>);&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void accept(T t);</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = t -&gt; &#123;System.out.println(t);&#125;;</span><br><span class="line">        consumer.accept(<span class="string">"java1018"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    T get();</span></span><br><span class="line">        Supplier&lt;String&gt; supplier =  () -&gt; &#123;<span class="keyword">return</span> UUID.randomUUID().toString();&#125;;</span><br><span class="line">        System.out.println(supplier.get());;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 8 引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。用周阳大神的话说就是：SQL就是JAVA，JAVA就是SQL。使用java.util.stream包中的Stream接口即可完成SQL中的计算、order 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ConcurrentModifcationException详解</title>
    <link href="https://youngyang.top/2020/07/04/ConcurrentModifcationException%E8%AF%A6%E8%A7%A3/"/>
    <id>https://youngyang.top/2020/07/04/ConcurrentModifcationException详解/</id>
    <published>2020-07-04T12:10:07.372Z</published>
    <updated>2020-07-04T12:08:09.986Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解为什么会产生ConcurrentModifcationException，以及底层代码分析，并且避免产生该异常的方法。</p><p>再讲ConcurrentModifcationException的时候，非常必要的说道集合的迭代器，不同的迭代器会产生不同的效果。</p><h1 id="Java中的迭代器"><a href="#Java中的迭代器" class="headerlink" title="Java中的迭代器"></a>Java中的迭代器</h1><h2 id="快速失败（fail—fast）"><a href="#快速失败（fail—fast）" class="headerlink" title="快速失败（fail—fast）"></a>快速失败（fail—fast）</h2><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出<strong>ConcurrentModificationException</strong>。</p><p>执行该操作的迭代器称为快速失败迭代器，因为迭代器很快就完全失败，而不会冒着在将来某个时间任意发生不确定行为的风险。迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败操作会尽最大努力抛出ConcurrentModificationException。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>场景：<strong>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。不光是多线程，在单线程时也可能发生该异常。</strong></p><p>多线程下发生该异常，代码如下：<br><img src="https://img-blog.csdnimg.cn/20200328134945803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在遍历整个list集合的时候，向里边添加元素，因为改变了list的结构，modCount会发生改变，故发生该异常。<br><img src="https://img-blog.csdnimg.cn/20200328135103235.png" alt="在这里插入图片描述"><br>单线程下发生该异常：<br><img src="https://img-blog.csdnimg.cn/20200328135200996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为在for循环遍历时候删除元素，同样改变了list的结构导致modCount发生改变，所以会抛出异常。<br><img src="https://img-blog.csdnimg.cn/2020032813521648.png" alt="在这里插入图片描述"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个<strong>modCount</strong>变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>例如我们查看ArrayList的关于iterator（）方法，是new了一个Itr对象。<br><img src="https://img-blog.csdnimg.cn/20200328131032502.png" alt="在这里插入图片描述"><br>那我们进来看看这是一个什么对象呢？这是AbstractList类的一个成员，查看他的next方法。<img src="https://img-blog.csdnimg.cn/20200328131741627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在next方法内部查看是否还有剩余元素的时候，会首先调用checkForComodification（）方法，那么这个方法是干什么的呢？<br><img src="https://img-blog.csdnimg.cn/20200328131947797.png" alt="在这里插入图片描述"><br>这个方法很简单，就是查看modCount变量是否的等于expectedModcount，如果这个值和期待的不相同的话就会抛出ConcurrentModificationException。</p><p>那么这个modCount是干什么的呢？</p><p>还是查看AbstractList中的注释：<br><img src="https://img-blog.csdnimg.cn/20200328131429570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>对于英语0级的我们，我还是去百度翻一下吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">此列表在结构上被修改的次数。结构修改是那些改变列表大小的修改，</span><br><span class="line">或者以其他方式干扰列表，使得正在进行的迭代可能产生不正确的结果。</span><br><span class="line"></span><br><span class="line">此字段由迭代器和列表迭代器方法返回的迭代器和列表迭代器实现使用。</span><br><span class="line">如果此字段的值意外更改，则迭代器（或列表迭代器）将抛出ConcurrentModificationException</span><br><span class="line">以响应下一个、删除、上一个、设置或添加操作。</span><br><span class="line">这提供了快速失败的行为，而不是迭代过程中并发修改时的不确定行为。</span><br><span class="line"></span><br><span class="line">子类使用此字段是可选的。如果子类希望提供快速失败的迭代器（和列表</span><br><span class="line">迭代器），那么它只需在其add（<span class="keyword">int</span>，E）和remove（<span class="keyword">int</span>）方法（以及</span><br><span class="line">它重写的导致列表结构修改的任何其他方法）中增加这个字段。</span><br><span class="line">对add（<span class="keyword">int</span>，E）或remove（<span class="keyword">int</span>）的单个调用必须向该字段添加不超过一个，否则迭代器（和列表迭代器）将抛出虚假的ConcurrentModificationExceptions。</span><br><span class="line">如果实现不希望提供失败快速迭代器，则可以忽略此字段。</span><br></pre></td></tr></table></figure><p>也就是说在对list的结构进行改变（list大小发生改变）的时候，modCount就会发生改变，旨在记录改变的次数。</p><p>所以综上所述：在对java.util包下的集合类进行并发修改的时候，一边改变数组的结构，一遍进行遍历，由于modCount发生了改变，所以就会跑异常。</p><h2 id="安全失败（fail—safe）"><a href="#安全失败（fail—safe）" class="headerlink" title="安全失败（fail—safe）"></a>安全失败（fail—safe）</h2><p>采用安全-失败机制的集合容器，在<strong>遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历</strong>。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>java.util.concurrent包下的容器都是安全失败，可以在多线程或者单线程下并发使用，并发修改。</p><p>如多线程下：<br><img src="https://img-blog.csdnimg.cn/20200328135623859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在单线程下：<br><img src="https://img-blog.csdnimg.cn/20200328135517905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><p>同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>众所周知，使用java.util.concurrent包下的集合类比如对应ArrayList的CopyOnWriteArrayList类就可以避免该异常的出现，那么是什么原理呢？</p><p>让我们来看看他的源码，来到iterator()方法：<br><img src="https://img-blog.csdnimg.cn/20200328133105324.png" alt="在这里插入图片描述"><br>这个方法调用的是COWIterator对象来完成遍历，并且把当前的list也就是底层存储数据的数组数据，和要返回的元素的索引传过来。来到COWIterator类的next()方法。<br><img src="https://img-blog.csdnimg.cn/20200328133451264.png" alt="在这里插入图片描述"><br>看到上边的注释了吧，unchecked就是不用检查，直接遍历，所以也就不会产生这个异常了。</p><p>这是因为他遍历的是拷贝的数据快照，所以并不需要考虑并发修改的问题。</p><p>但是也有一个缺点：就是在遍历的时候他为了避免产生并发修改异常，所以拷贝出一份快照用于遍历，在遍历期间修改（添加，修改，删除）的数据遍历不到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要讲解为什么会产生ConcurrentModifcationException，以及底层代码分析，并且避免产生该异常的方法。&lt;/p&gt;
&lt;p&gt;再讲ConcurrentModifcationException的时候，非常必要的说道集合的迭代器，不同的迭代器会产生不同的效果
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>activeMQ入门</title>
    <link href="https://youngyang.top/2020/07/04/activeMQ%E5%85%A5%E9%97%A8/"/>
    <id>https://youngyang.top/2020/07/04/activeMQ入门/</id>
    <published>2020-07-04T12:10:03.130Z</published>
    <updated>2020-07-04T12:08:11.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要使用消息中间件？"><a href="#为什么要使用消息中间件？" class="headerlink" title="为什么要使用消息中间件？"></a>为什么要使用消息中间件？</h1><h2 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h2><p>假设你有个系统A，这个系统A会产出一个核心数据，现在下游有系统B和系统C需要这个数据。<br>那简单，系统A就是直接调用系统B和系统C的接口发送数据给他们就好了。</p><p>整个过程，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191217123156135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是现在要是来了系统D、系统E、系统F、系统G，等等，十来个其他系统慢慢的都需要这份核心数据呢？如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191217123225235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>大家可别以为这是开玩笑，一个大规模系统，往往会拆分为几十个甚至上百个子系统，每个子系统又对应N多个服务，这些系统与系统之间有着错综复杂的关系网络。</p><p>如果某个系统产出一份核心数据，可能下游无数的其他系统都需要这份数据来实现各种业务逻辑。此时如果你要是采取上面那种模式来设计系统架构，那么绝对你负责系统A的同学要被烦死了。</p><p>先是来一个人找他要求发送数据给一个新的系统H，系统A的同学要修改代码然后在那个代码里加入调用新系统H的流程。一会那个系统B是个陈旧老系统要下线了，告诉系统A的同学：别给我发送数据了，接着系统A再次修改代码不再给这个系统B。<br><strong>然后如果要是某个上游或者下游系统突然宕机了呢？</strong><br>系统A的调用代码里是不是会抛异常？那系统A的同学会收到报警说异常了，结果他还要去care是下游哪个系统宕机了。所以在实际的系统架构设计中，如果全部采取这种系统耦合的方式，在某些场景下绝对是不合适的，系统耦合度太严重。并且互相耦合起来并不是核心链路的调用，而是一些非核心的场景（比如上述的数据消费）导致了系统耦合，这样会严重的影响上下游系统的开发和维护效率。</p><p><strong>因此在上述系统架构中，就可以采用MQ中间件来实现系统解耦。</strong><br>系统A就把自己的一份核心数据发到MQ里，下游哪个系统感兴趣自己去消费即可，不需要了就取消数据的消费，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191217123600178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><p>假设你有一个系统调用链路，是系统A调用系统B，一般耗时20ms；系统B调用系统C，一般耗时200ms；系统C调用系统D，一般耗时2s，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20191217123647654.png" alt="在这里插入图片描述"><br><strong>现在最大的问题就是：</strong><br>用户一个请求过来巨慢无比，因为走完一个链路，需要耗费：<br>20ms + 200ms + 2000ms（2s） = 2220ms，</p><p>也就是2秒多的时间。但是实际上，链路中的系统A调用系统B，系统B调用系统C，这两个步骤起来也就220ms。就因为引入了系统C调用系统D这个步骤，导致最终链路执行时间是2秒多，直接将链路调用性能降低了10倍，这就是导致链路执行过慢的罪魁祸首。</p><p>那此时我们可以思考一下，是不是可以将系统D从链路中抽离出去做成异步调用呢？其实很多的业务场景是可以允许异步调用的。</p><p>这样，实现思路就是系统A -&gt; 系统B -&gt; 系统C，直接就耗费220ms后直接成功了。然后系统C就是发送个消息到MQ中间件里，由系统D消费到消息之后慢慢的异步来执行这个耗时2s的业务处理。通过这种方式直接将核心链路的执行性能提升了10倍。整个过程，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191217123928544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><p>假设你有一个系统，平时正常的时候每秒可能就几百个请求，系统部署在8核16G的机器的上，正常处理都是OK的，每秒几百请求是可以轻松抗住的，但是如下图所示，在高峰期一下子来了每秒钟几千请求，弹指一挥间出现了流量高峰，此时你的选择是要搞10台机器，抗住这个瞬时高峰吗？<br><img src="https://img-blog.csdnimg.cn/2019121712402454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>假设瞬时高峰每天就那么半个小时，其它时间基本为每秒就几百请求，如果你线上部署了很多台机器，那么每台机器就处理每秒几十个请求就可以了，这不是有点浪费机器资源吗？大部分时候，每秒几百请求，一台机器就足够了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那半个小时有用，别的时候都是浪费资源的。</p><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://img-blog.csdnimg.cn/20191217124255634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、采用异步处理模式<br><img src="https://img-blog.csdnimg.cn/2019121712442112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/201912171244327.png" alt="在这里插入图片描述"><br>2、应用系统间解耦<br>发送者和接受者无需了解对方，只需发送或者接收消息即可。并且发送者和接受者无需同时在线。</p><h1 id="activeMQ安装"><a href="#activeMQ安装" class="headerlink" title="activeMQ安装"></a>activeMQ安装</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>去官网<a href="http://activemq.apache.org/，下载最新安装包，我使用的是5.15.10版本。" target="_blank" rel="noopener">http://activemq.apache.org/，下载最新安装包，我使用的是5.15.10版本。</a><br>将安装包apache-activemq-5.15.10-bin.tar下载到根目录的/opt下。</p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-activemq<span class="number">-5.15</span><span class="number">.10</span>-bin.tar</span><br></pre></td></tr></table></figure><p>对其进行解压，并把挤压后的文件放到根目录的/myactivemq/文件夹下。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /myactivemq/apache-activemq<span class="number">-5.15</span><span class="number">.10</span>/bin</span><br></pre></td></tr></table></figure><p>进入activemq目录下的bin目录，使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./activemq start</span><br></pre></td></tr></table></figure><p>启动activeMQ。<br>也可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./activemq status</span><br></pre></td></tr></table></figure><p>查看activeMQ启动状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./activemq stop</span><br></pre></td></tr></table></figure><p>关闭。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在启动ActiveMQ之后，ActiveMQ会开放两个端口，一个是后台端口61616，另一个是前台端口8161.我们可以使用ip+端口号进行访问，如<a href="http://192.168.0.119:8161进行访问。能看到如下画面，即启动成功。" target="_blank" rel="noopener">http://192.168.0.119:8161进行访问。能看到如下画面，即启动成功。</a><br><img src="https://img-blog.csdnimg.cn/20191217195602857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="Java编码实现ActiveMQ通信"><a href="#Java编码实现ActiveMQ通信" class="headerlink" title="Java编码实现ActiveMQ通信"></a>Java编码实现ActiveMQ通信</h1><h2 id="建立maven工程"><a href="#建立maven工程" class="headerlink" title="建立maven工程"></a>建立maven工程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.rocket&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;test_activemq&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF<span class="number">-8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">1.8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.targer&gt;<span class="number">1.8</span>&lt;/maven.compiler.targer&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--activemq需要的jav包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.15</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.16</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--下面是junit/log4等通用配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.7</span><span class="number">.25</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.16</span><span class="number">.18</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>ActiveMQ中的目的地有两种：<strong>queue和topic</strong>，其中队列是点对点的传输，只能有一个接收方，而topic可以有多个接收方，只要再发布消息之前订阅了该topic就可以接收到，并且实现了“负载均衡”，即多个接受者间隔接受。<br><img src="https://img-blog.csdnimg.cn/20191217194057953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="点对点传输"><a href="#点对点传输" class="headerlink" title="点对点传输"></a>点对点传输</h2><p>在点对点传输下，目的地为队列queue。</p><h3 id="生产者编码"><a href="#生产者编码" class="headerlink" title="生产者编码"></a>生产者编码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.activemq.<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ClassName JmsProduce</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsProduce</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final String URL = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final String queue_name = <span class="string">"queue01"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(URL);</span><br><span class="line">        <span class="comment">//利用工厂获取connection，并开始连接</span></span><br><span class="line">        Connection connection = factory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line"><span class="comment">//创建会话session，两个参数：事务和签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//创建目的地Destination</span></span><br><span class="line">        Queue <span class="built_in">queue</span> = session.createQueue(queue_name);</span><br><span class="line">        <span class="comment">//创建生产者</span></span><br><span class="line">        MessageProducer producer = session.createProducer(<span class="built_in">queue</span>);</span><br><span class="line"><span class="comment">//生产者发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">"mag..."</span> + i);</span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">"生产者生产数据成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行生产者代码之后ActiveMQ控制台如下所示：<br><img src="https://img-blog.csdnimg.cn/20191217194919499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="消费者编码"><a href="#消费者编码" class="headerlink" title="消费者编码"></a>消费者编码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ</span></span><br><span class="line"><span class="comment"> * JMS（Java Message Service）的生产者编码</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConsumer</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String ACTIVE_MQ = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String QUEUE_NAME = <span class="string">"queue01"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws JMSException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者01"</span>);</span><br><span class="line">        ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVE_MQ);</span><br><span class="line">        Connection connection = factory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Queue <span class="built_in">queue</span> = session.createQueue(QUEUE_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(<span class="built_in">queue</span>);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       同步阻塞方式receive()</span></span><br><span class="line"><span class="comment">        while (true) &#123;</span></span><br><span class="line"><span class="comment">            TextMessage message = (TextMessage) consumer.receive();</span></span><br><span class="line"><span class="comment">            if (null != message) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println("消费者受到消息，内容是：" + message.getText());</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        consumer.close();</span></span><br><span class="line"><span class="comment">        session.close();</span></span><br><span class="line"><span class="comment">        connection.close();*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//监听器方式</span></span><br><span class="line">        consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onMessage(Message message) &#123;</span><br><span class="line">                <span class="keyword">if</span> (null != message &amp;&amp; message instanceof TextMessage) &#123;</span><br><span class="line">                    TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"msg-----"</span> + textMessage.getText());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.in.read();</span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者消息的接受存在两种方式，一种是同步阻塞方式，另一种是监听器方式。<br>同步阻塞方式中有receive()和receive(long time)两个方法，没有消息阻塞在这里或者没有消息超过一定时间之后退出。监听器方式为设置一个监听器，监听是否有消息传送过来。</p><h2 id="基于发布订阅"><a href="#基于发布订阅" class="headerlink" title="基于发布订阅"></a>基于发布订阅</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ</span></span><br><span class="line"><span class="comment"> * JMS（Java Message Service）的生产者编码</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsProduceTopic</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String ACTIVE_URL = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String TOPIC_NAME = <span class="string">"topic-01"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接工厂，按照指定的url地址，采用默认用户名和密码</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVE_URL);</span><br><span class="line">        <span class="comment">//通过连接工厂创建连接，并启动访问</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line">        <span class="comment">//创建回话session，两个参数：事务和签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//常见目的地（队列或queue者主题topic）</span></span><br><span class="line">        Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">        <span class="comment">//创建生产者</span></span><br><span class="line">        MessageProducer producer = session.createProducer(topic);</span><br><span class="line">        <span class="comment">//使用MessageProducer生产3条消息发送到MQ的队列里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建消息</span></span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">"msg------"</span> + i);</span><br><span class="line">            <span class="comment">//通过生产者MessageProducer发送给MQ</span></span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ</span></span><br><span class="line"><span class="comment"> * JMS（Java Message Service）的消费者编码</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConsumerTopic</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String ACTIVEMQ_URL = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String TOPIC_NAME = <span class="string">"topic-01"</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JMSException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者TOPIC-3"</span>);</span><br><span class="line">        ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">        Connection connection = factory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line">        <span class="comment">//监听器方式</span></span><br><span class="line">        consumer.setMessageListener((message) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (null != message &amp;&amp; message instanceof TextMessage) &#123;</span><br><span class="line">                TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"msg-----"</span> + textMessage.getText());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.in.read();</span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="queue和topic两种模式的对比"><a href="#queue和topic两种模式的对比" class="headerlink" title="queue和topic两种模式的对比"></a>queue和topic两种模式的对比</h2><p><img src="https://img-blog.csdnimg.cn/20191217201149319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要使用消息中间件？&quot;&gt;&lt;a href=&quot;#为什么要使用消息中间件？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用消息中间件？&quot;&gt;&lt;/a&gt;为什么要使用消息中间件？&lt;/h1&gt;&lt;h2 id=&quot;系统解耦&quot;&gt;&lt;a href=&quot;#系统解耦&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL性能优化之索引优化分析</title>
    <link href="https://youngyang.top/2019/11/13/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>https://youngyang.top/2019/11/13/MySQL性能优化之索引优化分析/</id>
    <published>2019-11-13T15:24:41.137Z</published>
    <updated>2019-11-13T15:30:59.492Z</updated>
    
    <content type="html"><![CDATA[<p>数据库中索引的重要性毋庸置疑，系统的性能下降可能包含很多原因，其中就包括SQL慢，执行时间长或者等待时间长，其原因包括查询语句写的烂、索引失效、关联太多join（设计缺陷或不得已的需求）、服务器调优及各个参数设置（缓冲\线程数等 ）等原因。其中很大的原因就是索引方面有待优化。<br>本篇文章围绕在开发过程中的索引优化展开描述。</p><a id="more"></a><p>首先在电视剧期间插播几条广告（关于join的一些知识）：<br><img src="https://img-blog.csdnimg.cn/20191108112420209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h1><p><img src="https://img-blog.csdnimg.cn/20191108110701886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>索引也可以简单理解为：排好序的快速查找数据结构</p><p>在数据本身之外,数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，<br>这样就可以在这些数据结构的基础上实现高级查找算法,这种数据结构就是索引。<br><img src="https://img-blog.csdnimg.cn/20191108110803208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上，如windows中在安装目录下的/data/mysql下或者在linux系统中/var/lib/mysql下，有frm、myd和myi等文件，其中myi文件就是表索引文件。</p><p>==我们平时所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。== 其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然,除了B+树这种类型的索引之外，还有哈希索引(hash index)等。</p><h1 id="索引的优劣势"><a href="#索引的优劣势" class="headerlink" title="索引的优劣势"></a>索引的优劣势</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>1、类似大学图书馆建书目索引，提高数据检索效率，降低数据库的IO成本。<br>2、通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗。</p><h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><p>1、实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录，所以索引列也是要占用空间的。<br>2、虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表INSERT，UPDATE和DELETE。<br>更新（增删改）表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。<br>3、索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句。</p><h1 id="MySQL的索引分类"><a href="#MySQL的索引分类" class="headerlink" title="MySQL的索引分类"></a>MySQL的索引分类</h1><p>1、单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。<br>2、唯一索引：索引列的值必须唯一，但允许有空值。<br>3、复合索引：即一个索引包含多个列。</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="1、创建索引："><a href="#1、创建索引：" class="headerlink" title="1、创建索引："></a>1、创建索引：</h2><p>第一种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE] <span class="function">INDEX  indexName ON <span class="title">mytable</span><span class="params">(columnname(length))</span></span>;</span><br></pre></td></tr></table></figure><p>如果是CHAR,VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。<br>第二种：使用alter添加索引（4种）：<br><img src="https://img-blog.csdnimg.cn/20191108113824837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2、删除索引"><a href="#2、删除索引" class="headerlink" title="2、删除索引"></a>2、删除索引</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX [indexName] ON mytable;</span><br></pre></td></tr></table></figure><h2 id="3、查看索引"><a href="#3、查看索引" class="headerlink" title="3、查看索引"></a>3、查看索引</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM table_name;</span><br></pre></td></tr></table></figure><h1 id="MySQL的BTree索引结构"><a href="#MySQL的BTree索引结构" class="headerlink" title="MySQL的BTree索引结构"></a>MySQL的BTree索引结构</h1><p><img src="https://img-blog.csdnimg.cn/20191108113942561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191108114200110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="那些情况需要和不要创建索引"><a href="#那些情况需要和不要创建索引" class="headerlink" title="那些情况需要和不要创建索引"></a>那些情况需要和不要创建索引</h1><h2 id="需要"><a href="#需要" class="headerlink" title="需要"></a>需要</h2><p><img src="https://img-blog.csdnimg.cn/20191108114447101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="不要"><a href="#不要" class="headerlink" title="不要"></a>不要</h2><p><img src="https://img-blog.csdnimg.cn/20191108114519703.png" alt="在这里插入图片描述"></p><h1 id="MySQL性能分析"><a href="#MySQL性能分析" class="headerlink" title="MySQL性能分析"></a>MySQL性能分析</h1><p><strong>MySQL Query Optimizer</strong><br><img src="https://img-blog.csdnimg.cn/20191108114731832.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191108115010434.png" alt="在这里插入图片描述"><br>MySQL的性能分析主要包括如下几部分：<br><img src="https://img-blog.csdnimg.cn/20191108115132445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h3 id="慢查询日志是什么"><a href="#慢查询日志是什么" class="headerlink" title="慢查询日志是什么"></a>慢查询日志是什么</h3><p><img src="https://img-blog.csdnimg.cn/2019110811530616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="那我们应该怎么玩慢查询日志呢？"><a href="#那我们应该怎么玩慢查询日志呢？" class="headerlink" title="那我们应该怎么玩慢查询日志呢？"></a>那我们应该怎么玩慢查询日志呢？</h3><h4 id="首先需要开启"><a href="#首先需要开启" class="headerlink" title="首先需要开启"></a>首先需要开启</h4><p><img src="https://img-blog.csdnimg.cn/2019110811540590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>开启命令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global slow_query_log = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>那么开启慢查询日志后，什么样的SQL参会记录到慢查询里面？<br><img src="https://img-blog.csdnimg.cn/20191108115519611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="查询并设置慢的阙值时间"><a href="#查询并设置慢的阙值时间" class="headerlink" title="查询并设置慢的阙值时间"></a>查询并设置慢的阙值时间</h4><p><img src="https://img-blog.csdnimg.cn/20191108115943872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>注：</strong>但是设置之后查询long_query_time发现并没有变化，其实已经设置成功了，但是需要重新连接或者新开一个回话才能看到修改值。</p><h4 id="慢查询日志案例："><a href="#慢查询日志案例：" class="headerlink" title="慢查询日志案例："></a>慢查询日志案例：</h4><p><img src="https://img-blog.csdnimg.cn/20191108120651436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="日志分析工具mysqldumpshow"><a href="#日志分析工具mysqldumpshow" class="headerlink" title="日志分析工具mysqldumpshow"></a>日志分析工具mysqldumpshow</h4><p><img src="https://img-blog.csdnimg.cn/20191108120522944.png" alt="在这里插入图片描述"><br>工作中常用参考：<br><img src="https://img-blog.csdnimg.cn/2019110812055433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="使用explain慢SQL分析"><a href="#使用explain慢SQL分析" class="headerlink" title="使用explain慢SQL分析"></a>使用explain慢SQL分析</h2><p>在捕获到查询慢的SQL之后需要对其进行分析，从而完成对SQL的优化。<br>对于explain的介绍、如何使用explain以及各个字段的具体含义在我的另一篇博客中做了详细的介绍，链接：<a href="https://mp.csdn.net/postedit/103010613" target="_blank" rel="noopener">https://mp.csdn.net/postedit/103010613</a>。</p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>从explain的分析中可以看到索引的使用情况，如何有效的使用到所建立的索引，和如何保证索引不失效十分重要。下面分析索引失效的相关内容：</p><p>1、全值匹配我最爱<br>如：<img src="https://img-blog.csdnimg.cn/20191111171102489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.最佳左前缀法则：如果索引了多例，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。<br><img src="https://img-blog.csdnimg.cn/201911111712291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描。<br><img src="https://img-blog.csdnimg.cn/20191111171253160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.存储引擎不能使用索引中范围条件右边的列<br><img src="https://img-blog.csdnimg.cn/20191111171309488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>5.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select*。<br><img src="https://img-blog.csdnimg.cn/20191111171333978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019111117140444.png" alt="在这里插入图片描述"><br>6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描。<br><img src="https://img-blog.csdnimg.cn/20191111171424261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>7.is null,is not null 也无法使用索引。<br><img src="https://img-blog.csdnimg.cn/20191111171442205.png" alt="在这里插入图片描述"><br>8.like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作。<br>    问题：解决like’%字符串%’索引不被使用的方法？？<br>    答：<br>    1、可以使用主键索引<br>    2、使用覆盖索引，查询字段必须是建立覆盖索引字段<br>    3、当覆盖索引指向的字段是varchar(380)及380以上的字段时，覆盖索引会失效！</p><p>9.字符串不加单引号索引失效。<br><img src="https://img-blog.csdnimg.cn/20191111171534879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>10.少用or,用它连接时会索引失效。<br><img src="https://img-blog.csdnimg.cn/20191111171616610.png" alt="在这里插入图片描述"><br>11、小总结<br><img src="https://img-blog.csdnimg.cn/20191111171648940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> KK%相当于=常量     %KK和%KK% 相当于范围。<br>  <img src="https://img-blog.csdnimg.cn/20191111171712984.png" alt="KK%相当于=常量     %KK和%KK% 相当于范围"><br>  12、一般性建议：<br><img src="https://img-blog.csdnimg.cn/2019111117175731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库中索引的重要性毋庸置疑，系统的性能下降可能包含很多原因，其中就包括SQL慢，执行时间长或者等待时间长，其原因包括查询语句写的烂、索引失效、关联太多join（设计缺陷或不得已的需求）、服务器调优及各个参数设置（缓冲\线程数等 ）等原因。其中很大的原因就是索引方面有待优化。&lt;br&gt;本篇文章围绕在开发过程中的索引优化展开描述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://youngyang.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://youngyang.top/tags/mysql/"/>
    
      <category term="性能优化" scheme="https://youngyang.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="索引" scheme="https://youngyang.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql锁机制</title>
    <link href="https://youngyang.top/2019/11/13/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://youngyang.top/2019/11/13/MySQL锁机制/</id>
    <published>2019-11-13T15:20:00.514Z</published>
    <updated>2019-11-13T15:30:34.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql锁机制概述"><a href="#mysql锁机制概述" class="headerlink" title="mysql锁机制概述"></a>mysql锁机制概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://img-blog.csdnimg.cn/20191111174054371.png" alt="在这里插入图片描述"></p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="从数据操作的类型（读、写）分："><a href="#从数据操作的类型（读、写）分：" class="headerlink" title="从数据操作的类型（读、写）分："></a>从数据操作的类型（读、写）分：</h3><p>1、读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>2、写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</p><h3 id="从对数据操作的颗粒度分："><a href="#从对数据操作的颗粒度分：" class="headerlink" title="从对数据操作的颗粒度分："></a>从对数据操作的颗粒度分：</h3><p>从对数据操作的颗粒度分为：表锁和行锁。</p><a id="more"></a><h2 id="三锁分析"><a href="#三锁分析" class="headerlink" title="三锁分析"></a>三锁分析</h2><h3 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h3><p>特点：偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低。<br><img src="https://img-blog.csdnimg.cn/20191111183019315.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111183023542.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111183243776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111183255597.png" alt="在这里插入图片描述"><br><strong>表锁分析</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111183547292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111183614682.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111183618447.png" alt="在这里插入图片描述"></p><h3 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h3><p>特点：偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>补充：InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）;二是采用了行级锁。<br>由于行锁支持事务，复习老知识如下：</p><p>事务（Transation）及其ACID属性：<br><img src="https://img-blog.csdnimg.cn/20191111183747833.png" alt="在这里插入图片描述"><br>并发事务处理带来的问题：<br><strong>更新丢失</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111183834775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>脏读</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184004509.png" alt="在这里插入图片描述"><br><strong>不可重复读</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184027722.png" alt="在这里插入图片描述"><br><strong>幻读</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184046371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>事务隔离级别</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184108781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>常见问题<strong>如何锁定一行</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184154913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111184310177.png" alt="在这里插入图片描述"><br><strong>行锁分析</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184335255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111184349397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>优化建议：<br><img src="https://img-blog.csdnimg.cn/20191111184429843.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql锁机制概述&quot;&gt;&lt;a href=&quot;#mysql锁机制概述&quot; class=&quot;headerlink&quot; title=&quot;mysql锁机制概述&quot;&gt;&lt;/a&gt;mysql锁机制概述&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191111174054371.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;锁的分类&quot;&gt;&lt;a href=&quot;#锁的分类&quot; class=&quot;headerlink&quot; title=&quot;锁的分类&quot;&gt;&lt;/a&gt;锁的分类&lt;/h2&gt;&lt;h3 id=&quot;从数据操作的类型（读、写）分：&quot;&gt;&lt;a href=&quot;#从数据操作的类型（读、写）分：&quot; class=&quot;headerlink&quot; title=&quot;从数据操作的类型（读、写）分：&quot;&gt;&lt;/a&gt;从数据操作的类型（读、写）分：&lt;/h3&gt;&lt;p&gt;1、读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。&lt;br&gt;2、写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。&lt;/p&gt;
&lt;h3 id=&quot;从对数据操作的颗粒度分：&quot;&gt;&lt;a href=&quot;#从对数据操作的颗粒度分：&quot; class=&quot;headerlink&quot; title=&quot;从对数据操作的颗粒度分：&quot;&gt;&lt;/a&gt;从对数据操作的颗粒度分：&lt;/h3&gt;&lt;p&gt;从对数据操作的颗粒度分为：表锁和行锁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://youngyang.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://youngyang.top/tags/mysql/"/>
    
      <category term="锁" scheme="https://youngyang.top/tags/%E9%94%81/"/>
    
  </entry>
  
</feed>
