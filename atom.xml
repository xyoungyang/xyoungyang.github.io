<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://youngyang.top/"/>
  <updated>2019-11-13T15:30:59.492Z</updated>
  <id>https://youngyang.top/</id>
  
  <author>
    <name>youngyang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL性能优化之索引优化分析</title>
    <link href="https://youngyang.top/2019/11/13/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/"/>
    <id>https://youngyang.top/2019/11/13/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90/</id>
    <published>2019-11-13T15:24:41.137Z</published>
    <updated>2019-11-13T15:30:59.492Z</updated>
    
    <content type="html"><![CDATA[<p>数据库中索引的重要性毋庸置疑，系统的性能下降可能包含很多原因，其中就包括SQL慢，执行时间长或者等待时间长，其原因包括查询语句写的烂、索引失效、关联太多join（设计缺陷或不得已的需求）、服务器调优及各个参数设置（缓冲\线程数等 ）等原因。其中很大的原因就是索引方面有待优化。<br>本篇文章围绕在开发过程中的索引优化展开描述。</p><a id="more"></a><p>首先在电视剧期间插播几条广告（关于join的一些知识）：<br><img src="https://img-blog.csdnimg.cn/20191108112420209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h1><p><img src="https://img-blog.csdnimg.cn/20191108110701886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>索引也可以简单理解为：排好序的快速查找数据结构</p><p>在数据本身之外,数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，<br>这样就可以在这些数据结构的基础上实现高级查找算法,这种数据结构就是索引。<br><img src="https://img-blog.csdnimg.cn/20191108110803208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以文件形式存储在硬盘上，如windows中在安装目录下的/data/mysql下或者在linux系统中/var/lib/mysql下，有frm、myd和myi等文件，其中myi文件就是表索引文件。</p><p>==我们平时所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉树)结构组织的索引。== 其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然,除了B+树这种类型的索引之外，还有哈希索引(hash index)等。</p><h1 id="索引的优劣势"><a href="#索引的优劣势" class="headerlink" title="索引的优劣势"></a>索引的优劣势</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>1、类似大学图书馆建书目索引，提高数据检索效率，降低数据库的IO成本。<br>2、通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗。</p><h2 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h2><p>1、实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录，所以索引列也是要占用空间的。<br>2、虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表INSERT，UPDATE和DELETE。<br>更新（增删改）表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。<br>3、索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句。</p><h1 id="MySQL的索引分类"><a href="#MySQL的索引分类" class="headerlink" title="MySQL的索引分类"></a>MySQL的索引分类</h1><p>1、单值索引：即一个索引只包含单个列，一个表可以有多个单列索引。<br>2、唯一索引：索引列的值必须唯一，但允许有空值。<br>3、复合索引：即一个索引包含多个列。</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="1、创建索引："><a href="#1、创建索引：" class="headerlink" title="1、创建索引："></a>1、创建索引：</h2><p>第一种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE] <span class="function">INDEX  indexName ON <span class="title">mytable</span><span class="params">(columnname(length))</span></span>;</span><br></pre></td></tr></table></figure><p>如果是CHAR,VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定length。<br>第二种：使用alter添加索引（4种）：<br><img src="https://img-blog.csdnimg.cn/20191108113824837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2、删除索引"><a href="#2、删除索引" class="headerlink" title="2、删除索引"></a>2、删除索引</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX [indexName] ON mytable;</span><br></pre></td></tr></table></figure><h2 id="3、查看索引"><a href="#3、查看索引" class="headerlink" title="3、查看索引"></a>3、查看索引</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM table_name;</span><br></pre></td></tr></table></figure><h1 id="MySQL的BTree索引结构"><a href="#MySQL的BTree索引结构" class="headerlink" title="MySQL的BTree索引结构"></a>MySQL的BTree索引结构</h1><p><img src="https://img-blog.csdnimg.cn/20191108113942561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191108114200110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="那些情况需要和不要创建索引"><a href="#那些情况需要和不要创建索引" class="headerlink" title="那些情况需要和不要创建索引"></a>那些情况需要和不要创建索引</h1><h2 id="需要"><a href="#需要" class="headerlink" title="需要"></a>需要</h2><p><img src="https://img-blog.csdnimg.cn/20191108114447101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="不要"><a href="#不要" class="headerlink" title="不要"></a>不要</h2><p><img src="https://img-blog.csdnimg.cn/20191108114519703.png" alt="在这里插入图片描述"></p><h1 id="MySQL性能分析"><a href="#MySQL性能分析" class="headerlink" title="MySQL性能分析"></a>MySQL性能分析</h1><p><strong>MySQL Query Optimizer</strong><br><img src="https://img-blog.csdnimg.cn/20191108114731832.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191108115010434.png" alt="在这里插入图片描述"><br>MySQL的性能分析主要包括如下几部分：<br><img src="https://img-blog.csdnimg.cn/20191108115132445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><h3 id="慢查询日志是什么"><a href="#慢查询日志是什么" class="headerlink" title="慢查询日志是什么"></a>慢查询日志是什么</h3><p><img src="https://img-blog.csdnimg.cn/2019110811530616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="那我们应该怎么玩慢查询日志呢？"><a href="#那我们应该怎么玩慢查询日志呢？" class="headerlink" title="那我们应该怎么玩慢查询日志呢？"></a>那我们应该怎么玩慢查询日志呢？</h3><h4 id="首先需要开启"><a href="#首先需要开启" class="headerlink" title="首先需要开启"></a>首先需要开启</h4><p><img src="https://img-blog.csdnimg.cn/2019110811540590.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>开启命令：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global slow_query_log = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>那么开启慢查询日志后，什么样的SQL参会记录到慢查询里面？<br><img src="https://img-blog.csdnimg.cn/20191108115519611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="查询并设置慢的阙值时间"><a href="#查询并设置慢的阙值时间" class="headerlink" title="查询并设置慢的阙值时间"></a>查询并设置慢的阙值时间</h4><p><img src="https://img-blog.csdnimg.cn/20191108115943872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>注：</strong>但是设置之后查询long_query_time发现并没有变化，其实已经设置成功了，但是需要重新连接或者新开一个回话才能看到修改值。</p><h4 id="慢查询日志案例："><a href="#慢查询日志案例：" class="headerlink" title="慢查询日志案例："></a>慢查询日志案例：</h4><p><img src="https://img-blog.csdnimg.cn/20191108120651436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="日志分析工具mysqldumpshow"><a href="#日志分析工具mysqldumpshow" class="headerlink" title="日志分析工具mysqldumpshow"></a>日志分析工具mysqldumpshow</h4><p><img src="https://img-blog.csdnimg.cn/20191108120522944.png" alt="在这里插入图片描述"><br>工作中常用参考：<br><img src="https://img-blog.csdnimg.cn/2019110812055433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="使用explain慢SQL分析"><a href="#使用explain慢SQL分析" class="headerlink" title="使用explain慢SQL分析"></a>使用explain慢SQL分析</h2><p>在捕获到查询慢的SQL之后需要对其进行分析，从而完成对SQL的优化。<br>对于explain的介绍、如何使用explain以及各个字段的具体含义在我的另一篇博客中做了详细的介绍，链接：<a href="https://mp.csdn.net/postedit/103010613" target="_blank" rel="noopener">https://mp.csdn.net/postedit/103010613</a>。</p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>从explain的分析中可以看到索引的使用情况，如何有效的使用到所建立的索引，和如何保证索引不失效十分重要。下面分析索引失效的相关内容：</p><p>1、全值匹配我最爱<br>如：<img src="https://img-blog.csdnimg.cn/20191111171102489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2.最佳左前缀法则：如果索引了多例，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。<br><img src="https://img-blog.csdnimg.cn/201911111712291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描。<br><img src="https://img-blog.csdnimg.cn/20191111171253160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4.存储引擎不能使用索引中范围条件右边的列<br><img src="https://img-blog.csdnimg.cn/20191111171309488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>5.尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select*。<br><img src="https://img-blog.csdnimg.cn/20191111171333978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2019111117140444.png" alt="在这里插入图片描述"><br>6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描。<br><img src="https://img-blog.csdnimg.cn/20191111171424261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>7.is null,is not null 也无法使用索引。<br><img src="https://img-blog.csdnimg.cn/20191111171442205.png" alt="在这里插入图片描述"><br>8.like以通配符开头（’$abc…’）mysql索引失效会变成全表扫描操作。<br>    问题：解决like’%字符串%’索引不被使用的方法？？<br>    答：<br>    1、可以使用主键索引<br>    2、使用覆盖索引，查询字段必须是建立覆盖索引字段<br>    3、当覆盖索引指向的字段是varchar(380)及380以上的字段时，覆盖索引会失效！</p><p>9.字符串不加单引号索引失效。<br><img src="https://img-blog.csdnimg.cn/20191111171534879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>10.少用or,用它连接时会索引失效。<br><img src="https://img-blog.csdnimg.cn/20191111171616610.png" alt="在这里插入图片描述"><br>11、小总结<br><img src="https://img-blog.csdnimg.cn/20191111171648940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> KK%相当于=常量     %KK和%KK% 相当于范围。<br>  <img src="https://img-blog.csdnimg.cn/20191111171712984.png" alt="KK%相当于=常量     %KK和%KK% 相当于范围"><br>  12、一般性建议：<br><img src="https://img-blog.csdnimg.cn/2019111117175731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据库中索引的重要性毋庸置疑，系统的性能下降可能包含很多原因，其中就包括SQL慢，执行时间长或者等待时间长，其原因包括查询语句写的烂、索引失效、关联太多join（设计缺陷或不得已的需求）、服务器调优及各个参数设置（缓冲\线程数等 ）等原因。其中很大的原因就是索引方面有待优化。&lt;br&gt;本篇文章围绕在开发过程中的索引优化展开描述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://youngyang.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://youngyang.top/tags/mysql/"/>
    
      <category term="性能优化" scheme="https://youngyang.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="索引" scheme="https://youngyang.top/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql锁机制</title>
    <link href="https://youngyang.top/2019/11/13/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://youngyang.top/2019/11/13/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2019-11-13T15:20:00.514Z</published>
    <updated>2019-11-13T15:30:34.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql锁机制概述"><a href="#mysql锁机制概述" class="headerlink" title="mysql锁机制概述"></a>mysql锁机制概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://img-blog.csdnimg.cn/20191111174054371.png" alt="在这里插入图片描述"></p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="从数据操作的类型（读、写）分："><a href="#从数据操作的类型（读、写）分：" class="headerlink" title="从数据操作的类型（读、写）分："></a>从数据操作的类型（读、写）分：</h3><p>1、读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。<br>2、写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。</p><h3 id="从对数据操作的颗粒度分："><a href="#从对数据操作的颗粒度分：" class="headerlink" title="从对数据操作的颗粒度分："></a>从对数据操作的颗粒度分：</h3><p>从对数据操作的颗粒度分为：表锁和行锁。</p><a id="more"></a><h2 id="三锁分析"><a href="#三锁分析" class="headerlink" title="三锁分析"></a>三锁分析</h2><h3 id="表锁（偏读）"><a href="#表锁（偏读）" class="headerlink" title="表锁（偏读）"></a>表锁（偏读）</h3><p>特点：偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低。<br><img src="https://img-blog.csdnimg.cn/20191111183019315.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111183023542.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111183243776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111183255597.png" alt="在这里插入图片描述"><br><strong>表锁分析</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111183547292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111183614682.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111183618447.png" alt="在这里插入图片描述"></p><h3 id="行锁（偏写）"><a href="#行锁（偏写）" class="headerlink" title="行锁（偏写）"></a>行锁（偏写）</h3><p>特点：偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>补充：InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）;二是采用了行级锁。<br>由于行锁支持事务，复习老知识如下：</p><p>事务（Transation）及其ACID属性：<br><img src="https://img-blog.csdnimg.cn/20191111183747833.png" alt="在这里插入图片描述"><br>并发事务处理带来的问题：<br><strong>更新丢失</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111183834775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>脏读</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184004509.png" alt="在这里插入图片描述"><br><strong>不可重复读</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184027722.png" alt="在这里插入图片描述"><br><strong>幻读</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184046371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>事务隔离级别</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184108781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>常见问题<strong>如何锁定一行</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184154913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111184310177.png" alt="在这里插入图片描述"><br><strong>行锁分析</strong>：<br><img src="https://img-blog.csdnimg.cn/20191111184335255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111184349397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>优化建议：<br><img src="https://img-blog.csdnimg.cn/20191111184429843.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mysql锁机制概述&quot;&gt;&lt;a href=&quot;#mysql锁机制概述&quot; class=&quot;headerlink&quot; title=&quot;mysql锁机制概述&quot;&gt;&lt;/a&gt;mysql锁机制概述&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191111174054371.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;锁的分类&quot;&gt;&lt;a href=&quot;#锁的分类&quot; class=&quot;headerlink&quot; title=&quot;锁的分类&quot;&gt;&lt;/a&gt;锁的分类&lt;/h2&gt;&lt;h3 id=&quot;从数据操作的类型（读、写）分：&quot;&gt;&lt;a href=&quot;#从数据操作的类型（读、写）分：&quot; class=&quot;headerlink&quot; title=&quot;从数据操作的类型（读、写）分：&quot;&gt;&lt;/a&gt;从数据操作的类型（读、写）分：&lt;/h3&gt;&lt;p&gt;1、读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。&lt;br&gt;2、写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。&lt;/p&gt;
&lt;h3 id=&quot;从对数据操作的颗粒度分：&quot;&gt;&lt;a href=&quot;#从对数据操作的颗粒度分：&quot; class=&quot;headerlink&quot; title=&quot;从对数据操作的颗粒度分：&quot;&gt;&lt;/a&gt;从对数据操作的颗粒度分：&lt;/h3&gt;&lt;p&gt;从对数据操作的颗粒度分为：表锁和行锁。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://youngyang.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://youngyang.top/tags/mysql/"/>
    
      <category term="锁" scheme="https://youngyang.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化之explain</title>
    <link href="https://youngyang.top/2019/07/17/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8Bexplain/"/>
    <id>https://youngyang.top/2019/07/17/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8Bexplain/</id>
    <published>2019-07-17T09:43:54.000Z</published>
    <updated>2019-11-13T15:36:16.390Z</updated>
    
    <content type="html"><![CDATA[<p>在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。</p><a id="more"></a><h1 id="explain是什么"><a href="#explain是什么" class="headerlink" title="explain是什么"></a>explain是什么</h1><p>使用EXPLAIN关键字可以模拟优化器执行SQL语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是结构的性能瓶颈。</p><h1 id="explain能干什么"><a href="#explain能干什么" class="headerlink" title="explain能干什么"></a>explain能干什么</h1><p><img src="https://img-blog.csdnimg.cn/20191108121101440.png" alt="在这里插入图片描述"></p><h1 id="explain怎么玩"><a href="#explain怎么玩" class="headerlink" title="explain怎么玩"></a>explain怎么玩</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain + SQL语句</span><br></pre></td></tr></table></figure><p>包含的信息：<br><img src="https://img-blog.csdnimg.cn/20191108121336390.png" alt="在这里插入图片描述"><br>①id：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序<br><img src="https://img-blog.csdnimg.cn/20191108121709276.png" alt="在这里插入图片描述"><br>②select_type：查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询<br>select_type种类：<br><img src="https://img-blog.csdnimg.cn/20191108121742190.png" alt="在这里插入图片描述"><br>select_type各字段代表的含义：<br><img src="https://img-blog.csdnimg.cn/20191108121936141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>③table：显示这一行的数据是关于哪张表的。<br>④type种类（重要）：显示查询使用了何种类型，从最好到最差依次是：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL<br><img src="https://img-blog.csdnimg.cn/20191111151347727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>⑤possible_keys：显示可能应用在这张表中的索引,一个或多个。查询涉及的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。<br>⑥key（重要）：实际使用的索引。如果为null则没有使用索引。（查询中若使用了覆盖索引，则索引和查询的select字段重叠，在Extra中显示Using index）<br>⑦key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。（key_len显示的值为索引最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的）<br>⑧ref：显示索引哪一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值<br>⑨rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。<br>⑩Extra（重要）：包含不适合在其他列中显示但十分重要的额外信息。<br><img src="https://img-blog.csdnimg.cn/20191111152036632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://youngyang.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://youngyang.top/tags/mysql/"/>
    
      <category term="性能优化" scheme="https://youngyang.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="explain" scheme="https://youngyang.top/tags/explain/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化之查询截取分析</title>
    <link href="https://youngyang.top/2019/07/17/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90/"/>
    <id>https://youngyang.top/2019/07/17/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90/</id>
    <published>2019-07-17T09:22:45.000Z</published>
    <updated>2019-11-13T15:36:44.175Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL在查询数据的时候需要对响应的SQL语句进行优化，以提高速度和效率。</p><a id="more"></a><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="永远小表驱动大表"><a href="#永远小表驱动大表" class="headerlink" title="永远小表驱动大表"></a>永远小表驱动大表</h2><p>案例：<br><img src="https://img-blog.csdnimg.cn/2019111117225492.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111172305469.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191111172310517.png" alt="在这里插入图片描述"></p><h2 id="order-by关键字优化"><a href="#order-by关键字优化" class="headerlink" title="order by关键字优化"></a>order by关键字优化</h2><p>1、ORDER BY子句，尽量使用Index方式排序，避免使用FileSort方式排序。<br>2、尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀。<br>3、如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序。</p><p><strong>双路排序</strong>：MySQL4.1之前是使用双路排序，字面意思是两次扫描磁盘，最终得到数据。读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据传输。</p><p>取一批数据，要对磁盘进行两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二张改进的算法，就是单路排序。<br><strong>单路排序</strong>：从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，<br>它的效率更快一些，避免了第二次读取数据，并且把随机IO变成顺序IO，但是它会使用更多的空间，因为它把每一行都保存在内存中了。<br><strong>结论及引申出的问题</strong>：由于单路是后出来的，总体而言好过双路。但是用单路有问题：<br><img src="https://img-blog.csdnimg.cn/2019111117281881.png" alt="在这里插入图片描述"><br>优化策略：1、增大sort_buffer_size参数的设置。2、增大max_length_for_sort_data参数的设置。<br><img src="https://img-blog.csdnimg.cn/20191111172857472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>小总结：<br><img src="https://img-blog.csdnimg.cn/20191111172919262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="GROUP-BY关键字优化"><a href="#GROUP-BY关键字优化" class="headerlink" title="GROUP BY关键字优化"></a>GROUP BY关键字优化</h2><p>group by的优化和order by的优化有很多相似之处：<br>1、group by实质是先排序后进行分组，遵照索引建的最佳左前缀。<br>2、当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置。<br>3、where高于having,能写在where限定的条件就不要去having限定了。</p><h1 id="show-profile"><a href="#show-profile" class="headerlink" title="show profile"></a>show profile</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>show profile：是mysql提供可以用来分析当前会话中语句执行的资源消耗情况，可以用于SQL的调优测量。<br>默认情况下，参数处于关闭状态，并保存最近15次的运行结果。</p><h2 id="使用及分析步骤"><a href="#使用及分析步骤" class="headerlink" title="使用及分析步骤"></a>使用及分析步骤</h2><h3 id="1-是否支持，看看当前的SQL版本是否支持"><a href="#1-是否支持，看看当前的SQL版本是否支持" class="headerlink" title="1.是否支持，看看当前的SQL版本是否支持"></a>1.是否支持，看看当前的SQL版本是否支持</h3><p><img src="https://img-blog.csdnimg.cn/20191111173318258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-开启功能，默认是关闭，使用前需要开启"><a href="#2-开启功能，默认是关闭，使用前需要开启" class="headerlink" title="2.开启功能，默认是关闭，使用前需要开启"></a>2.开启功能，默认是关闭，使用前需要开启</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> profiling = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="3-运行SQL"><a href="#3-运行SQL" class="headerlink" title="3.运行SQL"></a>3.运行SQL</h3><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user;</span><br></pre></td></tr></table></figure><h3 id="4-查看结果"><a href="#4-查看结果" class="headerlink" title="4.查看结果"></a>4.查看结果</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profiles;</span><br></pre></td></tr></table></figure><h3 id="5-诊断SQL"><a href="#5-诊断SQL" class="headerlink" title="5.诊断SQL"></a>5.诊断SQL</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show profile cpu,block io <span class="keyword">for</span> query 上一步前面的问题SQL 数字号码；</span><br></pre></td></tr></table></figure><h3 id="6-日常开发需要注意的结论"><a href="#6-日常开发需要注意的结论" class="headerlink" title="6.日常开发需要注意的结论"></a>6.日常开发需要注意的结论</h3><p>1、converting HEAP to MyISAM：查询结果太大，内存都不够用了往磁盘上搬了。<br>2、Creating tmp table：创建临时表。<br>    会先拷贝数据到临时表，用完再删除。如：<br><img src="https://img-blog.csdnimg.cn/20191111173758860.png" alt="在这里插入图片描述"><br>3、Copying to tmp table on disk 把内存中临时表复制到磁盘，危险！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL在查询数据的时候需要对响应的SQL语句进行优化，以提高速度和效率。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://youngyang.top/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://youngyang.top/tags/mysql/"/>
    
      <category term="性能优化" scheme="https://youngyang.top/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL逻辑架构</title>
    <link href="https://youngyang.top/2019/07/13/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/"/>
    <id>https://youngyang.top/2019/07/13/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</id>
    <published>2019-07-13T01:23:22.000Z</published>
    <updated>2019-11-13T15:35:40.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL总体概览"><a href="#MySQL总体概览" class="headerlink" title="MySQL总体概览"></a>MySQL总体概览</h1><p><img src="https://img-blog.csdnimg.cn/20191108103653857.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20191108103640296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20191108105813554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong><img src="https://img-blog.csdnimg.cn/20191108105833580.png" alt="加粗样式"></strong><br><strong>了解：</strong><br>1.Connectors<br>指的是不同语言中与SQL的交互<br>2 Management Serveices &amp; Utilities：<br>系统管理和控制工具<br>3 Connection Pool: 连接池<br>管理缓冲用户连接，线程处理等需要缓存的需求。<br>负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，<br>接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。<br>4 SQL Interface: SQL接口。<br>接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface<br>5 Parser: 解析器。<br>SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。<br>在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。<br>主要功能：<br>a . 将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。<br>b.  如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的<br>6 Optimizer: 查询优化器。<br>SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果<br>他使用的是“选取-投影-联接”策略进行查询。<br>       用一个例子就可以理解： select uid,name from user where gender = 1;<br>       这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤<br>       这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤<br>       将这两个查询条件联接起来生成最终查询结果<br>7 Cache和Buffer： 查询缓存。<br>他的主要功能是将客户端提交 给MySQL 的 Select 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。<br>如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等<br>8 、存储引擎接口<br>存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL 可插拔存储引擎的特色。<br>     从图2还可以看出，MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。<br>    注意：存储引擎是基于表的，而不是数据库。</p><h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><h2 id="查看提供的引擎"><a href="#查看提供的引擎" class="headerlink" title="查看提供的引擎"></a>查看提供的引擎</h2><p><img src="https://img-blog.csdnimg.cn/20191108110055368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="查看自己的MySQL已提供什么存储引擎"></p><h2 id="MyISAM和InnoDB对比"><a href="#MyISAM和InnoDB对比" class="headerlink" title="MyISAM和InnoDB对比"></a>MyISAM和InnoDB对比</h2><p> <img src="https://img-blog.csdnimg.cn/20191108110246628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL总体概览&quot;&gt;&lt;a href=&quot;#MySQL总体概览&quot; class=&quot;headerlink&quot; title=&quot;MySQL总体概览&quot;&gt;&lt;/a&gt;MySQL总体概览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191108103653857.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;)&lt;img src=&quot;https://img-blog.csdnimg.cn/20191108103640296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="https://youngyang.top/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Java之JUC</title>
    <link href="https://youngyang.top/2019/04/24/Java%E4%B9%8BJUC/"/>
    <id>https://youngyang.top/2019/04/24/Java%E4%B9%8BJUC/</id>
    <published>2019-04-24T09:47:40.000Z</published>
    <updated>2020-07-04T12:42:45.190Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。下面一起来看看它怎么使用。</p><a id="more"></a><h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p><p>线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p><p>例如：<br>使用QQ，查看进程一定有一个QQ.exe的进程，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。</p><p>大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。</p><p>word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个线程：容灾备份，语法检查。</p><h2 id="线程的状态（Thread-State）"><a href="#线程的状态（Thread-State）" class="headerlink" title="线程的状态（Thread.State）"></a>线程的状态（Thread.State）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">//线程刚创建</span></span><br><span class="line">    NEW,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在JVM中正在运行的线程</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待状态</span></span><br><span class="line">    WAITING,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用sleep() join() wait()方法可能导致线程处于等待状态</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//线程执行完毕，已经退出</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="wait和sleep"><a href="#wait和sleep" class="headerlink" title="wait和sleep"></a>wait和sleep</h2><p>wait和sleep功能都是当前线程暂停，有什么区别？<br>wait放开手去睡，放开手里的锁；sleep握紧手去睡，醒了手里还有锁。</p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>这是我自己的理解：<br>1）并行是指两个或者多个事件在<strong>同一时刻</strong>发生；而并发是指两个或多个事件在<strong>同一时间间隔</strong>发生。<br>2）并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</p><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><p>1）继承Thread类<br>如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> <span class="title">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure><p>但是，java是单继承，资源宝贵，要用接口方式。<br>2）实现Runnable接口<br>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法会创建新的类，所以使用第三种方法，即：直接new接口，使用匿名内部类的方式。<br>3）利用Thread的带参数构造方法<img src="https://img-blog.csdnimg.cn/20191112155846815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第一个参数：传递一个Runnable的实现类；第二个参数：线程名称。<br>如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line"> <span class="comment">//函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;, <span class="string">"your thread name"</span>).start();</span><br></pre></td></tr></table></figure><p><strong>补充</strong>：另外Runnable中只有一个抽象方法，是一个函数式接口（@FunctionalInterface），所以此处可以使用lambda表达式进行简化。简化结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123; &#123;<span class="comment">//函数体&#125;&#125;, "your thread name").start();</span></span><br></pre></td></tr></table></figure><p>接口里是否能有实现方法？<br>答：接口里在java 8后容许有接口的实现，default方法默认实现，并且可以有多个default方法。<br>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x/y;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>另外接口中还可以呀静态方法的实现（静态方法必须用类去调用，不可以使用对象实例），并且可以有多个，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h1><p>在高内聚低耦合前提下，多线程的模板：<strong>线程 操作 资源类</strong>。<br>实现步骤：首先创建资源类，再在资源类中创建同步方法或者同步代码块。</p><p>使用synchronized创建同步方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">30</span>;</span><br><span class="line"><span class="comment">//同步方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"卖出"</span>+(number--)+<span class="string">"\t 还剩number);</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   /*同步代码块</span></span><br><span class="line"><span class="string">  synchronized(this) &#123;</span></span><br><span class="line"><span class="string">  if(number &gt; 0) &#123;</span></span><br><span class="line"><span class="string">    System.out.println(Thread.currentThread().getName()+"</span>卖出<span class="string">"+(number--)+"</span>\t 还剩number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;*/</span><br><span class="line">&#125; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> &#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="comment">//3个人同事卖30张票</span></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; i++)ticket.sale();&#125;, <span class="string">"AA"</span>).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; i++)ticket.sale();&#125;, <span class="string">"BB"</span>).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; i++)ticket.sale();&#125;, <span class="string">"CC"</span>).start();</span><br><span class="line">&#125;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用lock类创建如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.guigu.juc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/11/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> &#123;</span><span class="comment">//资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1000</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了第"</span> + (number--) + <span class="string">"张票，还剩下"</span> + number + <span class="string">"张！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws Exception </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//Lambda Express</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) ticket.saleTicket();</span><br><span class="line">        &#125;, <span class="string">"a"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) ticket.saleTicket();</span><br><span class="line">        &#125;, <span class="string">"b"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) ticket.saleTicket();</span><br><span class="line">        &#125;, <span class="string">"c"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p><strong>案例</strong>：<br>要求：现在两个线程 可以操作初始值为零的一个变量，实现一个线程对该变量加1，一个线程对该变量减1，交替执行10轮。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareDataOne</span>//资源类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;<span class="comment">//初始值为零的一个变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> throws InterruptedException </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="comment">//1判断</span></span><br><span class="line">     <span class="keyword">if</span>(number !=<span class="number">0</span> ) &#123;</span><br><span class="line">       <span class="keyword">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//2干活</span></span><br><span class="line">     ++number;</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+number);</span><br><span class="line">     <span class="comment">//3通知</span></span><br><span class="line">     <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> throws InterruptedException </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="comment">// 1判断</span></span><br><span class="line">     <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2干活</span></span><br><span class="line">     --number;</span><br><span class="line">     System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">     <span class="comment">// 3通知</span></span><br><span class="line">     <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  * 笔记：Java里面如何进行工程级别的多线程编写</span></span><br><span class="line"><span class="comment"> * 1 多线程变成模板（套路）-----上</span></span><br><span class="line"><span class="comment"> *     1.1  线程    操作    资源类  </span></span><br><span class="line"><span class="comment"> *     1.2  高内聚  低耦合</span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *     2.1  判断</span></span><br><span class="line"><span class="comment"> *     2.2  干活</span></span><br><span class="line"><span class="comment"> *     2.3  通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyWaitDemoOne</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     ShareDataOne sd = <span class="keyword">new</span> ShareDataOne();</span><br><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面案例是两个线程，如果换成4个线程会导致错误，虚假唤醒。<br>原因：在java多线程判断时，不能用if，程序出事出在了判断上面，突然有一添加的线程进到if了，突然中断了交出控制权，没有进行验证，而是直接走下去了，加了两次，甚至多次。</p><p>中断和虚假唤醒是可能产生的，所以要用loop循环，if只判断一次，while是只要唤醒就要拉回来再判断一次。if换成while。</p><h1 id="线程间定制化调用通信"><a href="#线程间定制化调用通信" class="headerlink" title="线程间定制化调用通信"></a>线程间定制化调用通信</h1><p>synchronized不能够实现线程间的定制化调用通信，若要实现线程间的定制化调用通信，则需要用到<strong>java.util.concurrent.locks.Lock</strong>类和<strong>java.util.concurrent.locks.Condition</strong>类。<br><strong>案例</strong>：<br>要求：多线程之间按顺序调用，实现A-&gt;B-&gt;C<br>三个线程启动，要求如下：AA打印5次，BB打印10次，CC打印15次；接着AA打印5次，BB打印10次，CC打印15次；如此反复来10轮。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;<span class="comment">//1:A 2:B 3:C </span></span><br><span class="line">  <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> </span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//1 判断</span></span><br><span class="line">       <span class="keyword">while</span>(number != <span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">//A 就要停止</span></span><br><span class="line">          c1.await();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2 干活</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+i+<span class="string">"\t totalLoopNumber: "</span>+totalLoopNumber);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3 通知</span></span><br><span class="line">       number = <span class="number">2</span>;</span><br><span class="line">       c2.signal();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> </span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//1 判断</span></span><br><span class="line">       <span class="keyword">while</span>(number != <span class="number">2</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">//A 就要停止</span></span><br><span class="line">          c2.await();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2 干活</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+i+<span class="string">"\t totalLoopNumber: "</span>+totalLoopNumber);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3 通知</span></span><br><span class="line">       number = <span class="number">3</span>;</span><br><span class="line">       c3.signal();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> </span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//1 判断</span></span><br><span class="line">       <span class="keyword">while</span>(number != <span class="number">3</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">//A 就要停止</span></span><br><span class="line">          c3.await();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2 干活</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">15</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+i+<span class="string">"\t totalLoopNumber: "</span>+totalLoopNumber);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3 通知</span></span><br><span class="line">       number = <span class="number">1</span>;</span><br><span class="line">       c1.signal();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadOrderAccess</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     ShareResource sr = <span class="keyword">new</span> ShareResource();</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          sr.print5(i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">"AA"</span>).start();</span><br><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          sr.print10(i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">"BB"</span>).start();</span><br><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          sr.print15(i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">"CC"</span>).start();     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多线程的8锁"><a href="#多线程的8锁" class="headerlink" title="多线程的8锁"></a>多线程的8锁</h1><p>多线程的8锁问题（两个方法不说明情况下都为普通同步方法（非静态））：<br>1 标准访问，先打印短信还是邮件<br>2 停4秒在短信方法内，先打印短信还是邮件<br>3 普通的hello方法，是先打短信还是hello<br>4 现在有两部手机，先打印短信还是邮件<br>5 两个静态同步方法，1部手机，先打印短信还是邮件<br>6 两个静态同步方法，2部手机，先打印短信还是邮件<br>7 1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件<br>8 1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件<br><strong>运行答案</strong>：<br>1、短信<br>2、短信<br>3、Hello<br>4、邮件<br>5、短信<br>6、短信<br>7、邮件<br>8、邮件</p><p>相应代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span>  synchronized <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> throws Exception</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   TimeUnit.SECONDS.sleep(<span class="number">4</span>);<span class="comment">//睡眠4秒钟</span></span><br><span class="line">   System.out.println(<span class="string">"------sendSMS"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> throws Exception</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"------sendEmail"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"------getHello"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock_8</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws Exception</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">   Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     phone.sendSMS();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;, <span class="string">"AA"</span>).start();</span><br><span class="line">   </span><br><span class="line">   Thread.sleep(<span class="number">100</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     phone.sendEmail();</span><br><span class="line">     <span class="comment">//phone.getHello();</span></span><br><span class="line">     <span class="comment">//phone2.sendEmail();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;, <span class="string">"BB"</span>).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8锁总结</strong>：（重要）</p><p>分析8锁问题，我觉得唯一需要掌握的核心是各种锁所锁的是哪个对象。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span></span><br><span class="line"><span class="xml">其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</span></span><br><span class="line"><span class="xml">锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">加个普通方法后发现和同步锁无关</span></span><br><span class="line"><span class="xml">换成两个对象后，不是同一把锁了，情况立刻变化。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</span></span><br><span class="line"><span class="xml">具体表现为以下3种形式。</span></span><br><span class="line"><span class="xml">对于普通同步方法，锁是当前实例对象。</span></span><br><span class="line"><span class="xml">对于静态同步方法，锁是当前类的Class对象。</span></span><br><span class="line"><span class="xml">对于同步方法块，锁是Synchonized括号里配置的对象</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，</span></span><br><span class="line"><span class="xml">可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，</span></span><br><span class="line"><span class="xml">所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">所有的静态同步方法用的也是同一把锁——类对象本身，</span></span><br><span class="line"><span class="xml">这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</span></span><br><span class="line"><span class="xml">但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，</span></span><br><span class="line"><span class="xml">而不管是同一个实例对象的静态同步方法之间，</span></span><br><span class="line"><span class="xml">还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</span></span><br></pre></td></tr></table></figure><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>在使用集合，如ArrayList、HashSet、HashMap的时候很容易出现线程安全问题，并发修改异常就会报并发修改异常（java.util.ConcurrentModificationException）。</p><p>知识回顾：<br>1、ArrayList的底层是一个object的数组；HashSet的底层是HashMap，但是HashSet的add方法是放一个数据进去，所以将此数据作为HashMap的key，其value是一个固定的Object类型值；HashMap底层是Node节点和链表。<br>2、HashMap的构造方法：<br>        1、new HashMap();构造一个默认的初始容量为16，和默认的负载因子为0.75的HashMap。<br>        2、new HashMap(<strong>int initialCapacity, float loadFactor</strong>);构造一个默认的初始容量为initialCapacity，和默认的负载因子为loadFactor的HashMap。</p><p>在ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常。<br>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="built_in">list</span>.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(<span class="built_in">list</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>ArrayList的底层其实是一个Object类型的数组（Object [ ]）,在上述过程中，很多线程既对list读又对list写，所以出现了ConcurrentModificationException异常。<br>查看ArrayList源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add方法并没有加synchronized，线程不安全。</p><p>提出三种解决方案如下：</p><p><strong>解决方案1</strong>、使用Vector代替ArrayList<br><img src="https://img-blog.csdnimg.cn/20191113212753653.png" alt="在这里插入图片描述"><br>Vector和ArrayList两个类都实现了List接口，但是观察Vector源码如下可发现加了synchronized，所以是线程安全的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized boolean <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>弊端</strong>：虽然Vector相对ArrayList来说加了synchronized，保证了线程安全，保持了数据的一致性，但是因为加了锁降低了高并发的效率。</p><p><strong>解决方案2</strong>、使用集合工具类Collections<br>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="built_in">list</span> = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><p>Collections提供了方法synchronizedList保证list是同步线程安全的。<br>那HashMap，HashSet是线程安全的吗？也不是，所以有同样的线程安全方法。<br><img src="https://img-blog.csdnimg.cn/20191113213852140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解决方案3、使用java.util.concurrent包中的CopyOnWriteArrayList类。<br><img src="https://img-blog.csdnimg.cn/20191113214018864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>查看CopyOnWriteArrayList中add方法的源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    final ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyOnWriteArrayList类虽然也用lock加了锁，但是他在add方法中复制出一份数组数据供本线程进行add写操作，原来的数据供其他线程读操作，在写完之后用类中的setArray()方法在将新生成的数组赋值给原数组。此类用到了<strong><em>读写分离</em></strong>的思想，读写互不干扰，但是应该注意，其底层是读写不同的数组，而不是同时读写相同的一个数组。</p><p>同样的：    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//线程不安全</span></span><br><span class="line"> Set&lt;String&gt; <span class="built_in">set</span> = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();<span class="comment">//线程安全</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//线程不安全</span></span><br><span class="line">Map&lt;String,String&gt; <span class="built_in">map</span> = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="comment">//线程安全</span></span><br></pre></td></tr></table></figure><h1 id="获得多线程的第三种方法"><a href="#获得多线程的第三种方法" class="headerlink" title="获得多线程的第三种方法"></a>获得多线程的第三种方法</h1><p>前面介绍了两种获得多线程的方法：继承Thread类和实现Runnable接口。传统的是继承thread类和实现runnable接口，这两种方法，java 5以后又有实现JUC中的callable接口和java的线程池获得。</p><p>第三种方法：实现函数式接口Callable，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mythread</span> <span class="title">implements</span> <span class="title">Callable</span>&lt;Integer&gt;&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> throws Exception</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callable接口与runnable接口的区别？</p><p> 答：（1）是否有返回值<br>       （2）是否抛异常<br>       （3）落地方法不一样，一个是run，一个是call<br> <strong>用法</strong>：<br>获得多线程的时候需要向Thread的构造方法中传一个Runnable接口的实现类，如new Thread(Runnable r,String name);但是实现Callable接口的类并不是Runnable的实现类，所以不能直接传给Thread构造方法。<br>但是Runnable在JUC包中有一个子接口RunnableFuture，而RunnableFuture在JUC中又有一个子接口FutureTask，FutureTask有一个构造方法FutureTask(Callable<V> callable) ，所以用上述的Callable实现类即可获得多线程。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mythread</span> <span class="title">implements</span> <span class="title">Callable</span>&lt;Integer&gt;&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> throws Exception</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> &#123;</span></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Mythread());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Callable相对于Runnable接口的优势在于会有一个返回值。那我们如何获取这个返回值呢？<br><img src="https://img-blog.csdnimg.cn/20191113222449767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>原理</strong>：<br>在主线程中需要执行比较耗时的操作，但又不想阻塞主线程时，可以把这些作业交给FutureTask对象在后台完成，当主线程将来需要时，就可以通过FutureTask对象获得后台作业的计算结果或者执行状态。</p><p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。 所以建议<strong>get方法放到最后</strong>。</p><p>同一个Callable实现类中的call方法只计算一次，利用同一个Callable实现类获取多线程时，其中的代码只执行一次。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mythread</span> <span class="title">implements</span> <span class="title">Callable</span>&lt;Integer&gt;&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> throws Exception</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> &#123;</span></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Mythread());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码的执行结果为：<br><img src="https://img-blog.csdnimg.cn/20191113223517266.png" alt="在这里插入图片描述"></p><h1 id="JUC中强大的辅助类"><a href="#JUC中强大的辅助类" class="headerlink" title="JUC中强大的辅助类"></a>JUC中强大的辅助类</h1><p>这里讲解三个JUC中的强大辅助类，分别是CountDownLatch、CyclicBarrier和Semaphore，这三个辅助类用于进一步控制线程的调度问题，其中CountDownLatch使用减法计数的方式控制某个线程在多个线程之后进行，而CyclicBarrier用加法计数的形式控制某个线程在多个线程之后进行，Semaphore能够控制线程的并发数量。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><strong>原理</strong>： CountDownLatch主要有await()和countDown()两个方法，当一个或多个线程调用await()方法时，这些线程会阻塞。其它线程调用countDown()方法会将计数器减1(调用countDown方法的线程不会阻塞)，当计数器的值变为0时，因await()方法阻塞的线程会被唤醒，继续执行。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</span></span><br><span class="line"><span class="comment"> * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</span></span><br><span class="line"><span class="comment"> * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 解释：6个同学陆续离开教室后值班同学才可以关门。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws InterruptedException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//6个上自习的同学，各自离开教室的时间不一致</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+<span class="string">"\t 号同学离开教室"</span>);</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">          &#125;, String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">"\t****** 班长关门走人，main线程是班长"</span>);         </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><strong>原理</strong>：CyclicBarrier 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是， 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CyclicBarrier</span></span><br><span class="line"><span class="comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span></span><br><span class="line"><span class="comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span></span><br><span class="line"><span class="comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span></span><br><span class="line"><span class="comment"> * 被屏障拦截的线程才会继续干活。</span></span><br><span class="line"><span class="comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 集齐7颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="comment">//CyclicBarrier(int parties, Runnable barrierAction) </span></span><br><span class="line">     </span><br><span class="line">     CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUMBER, ()-&gt;&#123;System.out.println(<span class="string">"*****集齐7颗龙珠就可以召唤神龙"</span>);&#125;) ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 星龙珠被收集 "</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125; </span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><strong>原理</strong>：在信号量上我们定义两种操作：</p><ul><li>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</li><li>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</li><li></li><li>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</li></ul><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);<span class="comment">//模拟3个停车位</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//模拟6部汽车</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> </span><br><span class="line">          &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 抢到了车位"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t------- 离开"</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;finally &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h1><p>正常情况下应该保证只有一个设备在进行写操作，也就是等一个线程写完之后其他的写线程才能执行，否则就会出错。未加锁控制的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t 正在写"</span>+key);</span><br><span class="line">        <span class="comment">//暂停一会儿线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace(); &#125;</span><br><span class="line">        <span class="built_in">map</span>.put(key,value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t 写完了"</span>+key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Object result = null;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t 正在读"</span>+key);</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace(); &#125;</span><br><span class="line">        result = <span class="built_in">map</span>.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t 读完了"</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            final <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.put(num+<span class="string">""</span>,num+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            final <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.get(num+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUC中locks.Losk类虽然可以控制线程的安全保证相同的时间只有一个操作执行，但是这也规定了相同时间只能有一个操作不管是写还是读，降低了并发性能。在正常情况下，我们应该保证读写分离，即只有一个线程在写，读操作不做限制可以有多个线程在读，所以使用locks.ReadWriteLock。</p><p>改良后代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写"</span> + key);</span><br><span class="line">            <span class="comment">//暂停一会儿线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写完了"</span> + key);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        Object result = null;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读"</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">map</span>.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读完了"</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            final <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(num + <span class="string">""</span>, num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            final <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。下面一起来看看它怎么使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://youngyang.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="https://youngyang.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentModifcationException详解</title>
    <link href="https://youngyang.top/2019/04/22/ConcurrentModifcationException%E8%AF%A6%E8%A7%A3/"/>
    <id>https://youngyang.top/2019/04/22/ConcurrentModifcationException%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T14:33:24.905Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解为什么会产生ConcurrentModifcationException，以及底层代码分析，并且避免产生该异常的方法。</p><p>再讲ConcurrentModifcationException的时候，非常必要的说道集合的迭代器，不同的迭代器会产生不同的效果。</p><a id="more"></a><h1 id="Java中的迭代器"><a href="#Java中的迭代器" class="headerlink" title="Java中的迭代器"></a>Java中的迭代器</h1><h2 id="快速失败（fail—fast）"><a href="#快速失败（fail—fast）" class="headerlink" title="快速失败（fail—fast）"></a>快速失败（fail—fast）</h2><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出<strong>ConcurrentModificationException</strong>。</p><p>执行该操作的迭代器称为快速失败迭代器，因为迭代器很快就完全失败，而不会冒着在将来某个时间任意发生不确定行为的风险。迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败操作会尽最大努力抛出ConcurrentModificationException。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>场景：<strong>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。不光是多线程，在单线程时也可能发生该异常。</strong></p><p>多线程下发生该异常，代码如下：<br><img src="https://img-blog.csdnimg.cn/20200328134945803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在遍历整个list集合的时候，向里边添加元素，因为改变了list的结构，modCount会发生改变，故发生该异常。<br><img src="https://img-blog.csdnimg.cn/20200328135103235.png" alt="在这里插入图片描述"><br>单线程下发生该异常：<br><img src="https://img-blog.csdnimg.cn/20200328135200996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为在for循环遍历时候删除元素，同样改变了list的结构导致modCount发生改变，所以会抛出异常。<br><img src="https://img-blog.csdnimg.cn/2020032813521648.png" alt="在这里插入图片描述"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个<strong>modCount</strong>变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><p>例如我们查看ArrayList的关于iterator（）方法，是new了一个Itr对象。<br><img src="https://img-blog.csdnimg.cn/20200328131032502.png" alt="在这里插入图片描述"><br>那我们进来看看这是一个什么对象呢？这是AbstractList类的一个成员，查看他的next方法。<img src="https://img-blog.csdnimg.cn/20200328131741627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在next方法内部查看是否还有剩余元素的时候，会首先调用checkForComodification（）方法，那么这个方法是干什么的呢？<br><img src="https://img-blog.csdnimg.cn/20200328131947797.png" alt="在这里插入图片描述"><br>这个方法很简单，就是查看modCount变量是否的等于expectedModcount，如果这个值和期待的不相同的话就会抛出ConcurrentModificationException。</p><p>那么这个modCount是干什么的呢？</p><p>还是查看AbstractList中的注释：<br><img src="https://img-blog.csdnimg.cn/20200328131429570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>对于英语0级的我们，我还是去百度翻一下吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">此列表在结构上被修改的次数。结构修改是那些改变列表大小的修改，</span><br><span class="line">或者以其他方式干扰列表，使得正在进行的迭代可能产生不正确的结果。</span><br><span class="line"></span><br><span class="line">此字段由迭代器和列表迭代器方法返回的迭代器和列表迭代器实现使用。</span><br><span class="line">如果此字段的值意外更改，则迭代器（或列表迭代器）将抛出ConcurrentModificationException</span><br><span class="line">以响应下一个、删除、上一个、设置或添加操作。</span><br><span class="line">这提供了快速失败的行为，而不是迭代过程中并发修改时的不确定行为。</span><br><span class="line"></span><br><span class="line">子类使用此字段是可选的。如果子类希望提供快速失败的迭代器（和列表</span><br><span class="line">迭代器），那么它只需在其add（<span class="keyword">int</span>，E）和remove（<span class="keyword">int</span>）方法（以及</span><br><span class="line">它重写的导致列表结构修改的任何其他方法）中增加这个字段。</span><br><span class="line">对add（<span class="keyword">int</span>，E）或remove（<span class="keyword">int</span>）的单个调用必须向该字段添加不超过一个，否则迭代器（和列表迭代器）将抛出虚假的ConcurrentModificationExceptions。</span><br><span class="line">如果实现不希望提供失败快速迭代器，则可以忽略此字段。</span><br></pre></td></tr></table></figure><p>也就是说在对list的结构进行改变（list大小发生改变）的时候，modCount就会发生改变，旨在记录改变的次数。</p><p>所以综上所述：在对java.util包下的集合类进行并发修改的时候，一边改变数组的结构，一遍进行遍历，由于modCount发生了改变，所以就会跑异常。</p><h2 id="安全失败（fail—safe）"><a href="#安全失败（fail—safe）" class="headerlink" title="安全失败（fail—safe）"></a>安全失败（fail—safe）</h2><p>采用安全-失败机制的集合容器，在<strong>遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历</strong>。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>java.util.concurrent包下的容器都是安全失败，可以在多线程或者单线程下并发使用，并发修改。</p><p>如多线程下：<br><img src="https://img-blog.csdnimg.cn/20200328135623859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在单线程下：<br><img src="https://img-blog.csdnimg.cn/20200328135517905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p><p>同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>众所周知，使用java.util.concurrent包下的集合类比如对应ArrayList的CopyOnWriteArrayList类就可以避免该异常的出现，那么是什么原理呢？</p><p>让我们来看看他的源码，来到iterator()方法：<br><img src="https://img-blog.csdnimg.cn/20200328133105324.png" alt="在这里插入图片描述"><br>这个方法调用的是COWIterator对象来完成遍历，并且把当前的list也就是底层存储数据的数组数据，和要返回的元素的索引传过来。来到COWIterator类的next()方法。<br><img src="https://img-blog.csdnimg.cn/20200328133451264.png" alt="在这里插入图片描述"><br>看到上边的注释了吧，unchecked就是不用检查，直接遍历，所以也就不会产生这个异常了。</p><p>这是因为他遍历的是拷贝的数据快照，所以并不需要考虑并发修改的问题。</p><p>但是也有一个缺点：就是在遍历的时候他为了避免产生并发修改异常，所以拷贝出一份快照用于遍历，在遍历期间修改（添加，修改，删除）的数据遍历不到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲解为什么会产生ConcurrentModifcationException，以及底层代码分析，并且避免产生该异常的方法。&lt;/p&gt;
&lt;p&gt;再讲ConcurrentModifcationException的时候，非常必要的说道集合的迭代器，不同的迭代器会产生不同的效果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://youngyang.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="https://youngyang.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Your password does not satisfy the current policy requirements</title>
    <link href="https://youngyang.top/2019/04/22/ERROR%201819%20(HY000)_%20Your%20password%20does%20not%20satisfy%20the%20current%20policy%20requirements/"/>
    <id>https://youngyang.top/2019/04/22/ERROR%201819%20(HY000)_%20Your%20password%20does%20not%20satisfy%20the%20current%20policy%20requirements/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2019-10-31T04:34:42.958Z</updated>
    
    <content type="html"><![CDATA[<p>在linux中部署项目，搭建数据库环境的时候，需要专门设置一个user来管理响应的数据库。这是我在初步使用mysql，向mysql中user表插入用户时遇到的问题。</p><a id="more"></a><p>密码策略问题异常信息：<br>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</p><p>如下图：<img src="https://img-blog.csdnimg.cn/20191024103619380.png" alt="在这里插入图片描述"><br>解决办法：</p><h4 id="1、查看-mysql-初始的密码策略，"><a href="#1、查看-mysql-初始的密码策略，" class="headerlink" title="1、查看 mysql 初始的密码策略，"></a>1、查看 mysql 初始的密码策略，</h4><p>输入语句 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE <span class="string">'validate_password%'</span>;</span><br></pre></td></tr></table></figure><p>进行查看，<br>如下图：<br><img src="https://img-blog.csdnimg.cn/20191024103903746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2、首先需要设置密码的验证强度等级"><a href="#2、首先需要设置密码的验证强度等级" class="headerlink" title="2、首先需要设置密码的验证强度等级"></a>2、首先需要设置密码的验证强度等级</h4><p>设置 validate_password_policy 的全局参数为 LOW 即可，输入设值语句 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global validate_password_policy=LOW;</span><br></pre></td></tr></table></figure><p>进行设值，如下图：<img src="https://img-blog.csdnimg.cn/20191024104114414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3、设置密码长度"><a href="#3、设置密码长度" class="headerlink" title="3、设置密码长度"></a>3、设置密码长度</h4><p>当前密码长度为 8 ，如果不介意的话就不用修改了，此处设置为 4 位的密码，设置 validate_password_length 的全局参数为 6 即可，<br>输入设值语句<br><code>set global validate_password_length=4;</code>进行设值，如下图：<br><img src="https://img-blog.csdnimg.cn/20191024104332805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4-设置密码"><a href="#4-设置密码" class="headerlink" title="4.设置密码"></a>4.设置密码</h4><p>现在就可以为mysql的用户设置密码了，只要满足4位长度即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user <span class="string">'mmall'</span>@<span class="string">'localhost'</span> identified by <span class="string">'mmall'</span>;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20191024105338293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>至此，用户就添加成功了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在linux中部署项目，搭建数据库环境的时候，需要专门设置一个user来管理响应的数据库。这是我在初步使用mysql，向mysql中user表插入用户时遇到的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://youngyang.top/categories/linux/"/>
    
      <category term="mysql" scheme="https://youngyang.top/categories/linux/mysql/"/>
    
    
      <category term="linux" scheme="https://youngyang.top/tags/linux/"/>
    
      <category term="mysql" scheme="https://youngyang.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>JMS（Java Message Service）</title>
    <link href="https://youngyang.top/2019/04/22/JMS%EF%BC%88Java%20Message%20Service%EF%BC%89/"/>
    <id>https://youngyang.top/2019/04/22/JMS%EF%BC%88Java%20Message%20Service%EF%BC%89/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T12:54:53.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>JMS是Java EE中的一部分，好比是盘子和点心的关系，JMS是Java EE中的额一个组成部分。<br><img src="https://img-blog.csdnimg.cn/20191217201717408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191217201745254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><h1 id="JMS的组成"><a href="#JMS的组成" class="headerlink" title="JMS的组成"></a>JMS的组成</h1><p>JMS有四部分组成。分别为：</p><p>JMS privider： 实现JMS接口与规范的消息中间件，也就是我们的MQ服务器。<br>JMS producer：消息生产者，创建与发送JMS消息的客户端应用。<br>JMS consumer：消息的消费者，接受与处理JMS消息的客户端应用。<br>JMS message：JMS的消息。</p><h2 id="JMS-message的组成"><a href="#JMS-message的组成" class="headerlink" title="JMS message的组成"></a>JMS message的组成</h2><p>JMS message由三部分组成：消息头、消息头和消息属性。</p><h3 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h3><p>在JMS message中包含很多消息头，如下所示：<br><img src="https://img-blog.csdnimg.cn/20191217203129546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>几个比较重要的消息头如下：</p><p>1、<strong>JMSdestination</strong>：message发送的目的地，比如queue和topic。<br>2、<strong>JMSDeliveryMode</strong>:主要是指定消息的持久或者非持久化。<br><img src="https://img-blog.csdnimg.cn/20191217203559742.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191217203319377.png" alt="在这里插入图片描述"><br>3、JMSExpiration：消息存活时间。<br><img src="https://img-blog.csdnimg.cn/20191217203702484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4、JMSPriority：消息优先级。<br><img src="https://img-blog.csdnimg.cn/20191217203801226.png" alt="在这里插入图片描述"></p><p>5、JMSMessageID：唯一识别每个消息的标志，由MQ产生。</p><h3 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h3><p>消息体顾名思义作用就是<strong>封装具体消息的数据</strong>。<br>那么消息的数据到底有多少种格式呢，有五种。其中最常用的为<strong>TextMessage</strong>和<strong>MapMessage</strong>两种。<br>1、TextMessage：普通的字符串消息，包含一个string。<br>2、MapMessage：一个map类型的消息，key为stirng类型，而value 为<strong>java的基本类型</strong>。如下：<br><img src="https://img-blog.csdnimg.cn/20191217204358515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果MapMessage中的value放的是char类型数据，则创键方式如下所示：<br><img src="https://img-blog.csdnimg.cn/20191217204259849.png" alt="在这里插入图片描述"><br>3、BytesMessage：二进制数组消息，包含一个byte[]。<br>4、StreamMessage：java数据流消息，用标准流操作来顺序的填充或读取。<br>5、ObjectMessage：对象消息，包含一个可序列化的java对象。</p><p><strong><em>注意：</em></strong><br>    发送和接受的消息体类型必须是一致对应的。如发送的是TextMessage，则接收方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> onMessage(Message message) &#123;</span><br><span class="line">               <span class="keyword">if</span> (null != message &amp;&amp; message instanceof TextMessage) &#123;</span><br><span class="line">                   TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       System.out.println(<span class="string">"msg-----"</span> + textMessage.getText());</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h3 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h3><p>如果需要使用消息头以外的值，那么可以使用消息属性（一种加强型的api），可用于识别/去重/重点标注等操作。<br><img src="https://img-blog.csdnimg.cn/20191217211429786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="JMS的可靠性"><a href="#JMS的可靠性" class="headerlink" title="JMS的可靠性"></a>JMS的可靠性</h1><h2 id="persistent：持久性"><a href="#persistent：持久性" class="headerlink" title="persistent：持久性"></a>persistent：持久性</h2><h3 id="基于队列queue"><a href="#基于队列queue" class="headerlink" title="基于队列queue"></a>基于队列queue</h3><p>1、非持久化：<br><img src="https://img-blog.csdnimg.cn/20191217212023194.png" alt="在这里插入图片描述"><br>2、持久化<br><img src="https://img-blog.csdnimg.cn/20191217212047638.png" alt="在这里插入图片描述"><br>3、默认情况下ActiveMQ是持久化的，即向MQ中发送消息之后即使MQ服务器宕机挂掉然后重新启动之后，消费者也可以从MQ中取到原来发送的消息；而如果使用上述方法设置消息非持久化，那么在重新启动之后就不能取到原来的数据，原来的数据就会被丢失。</p><h3 id="基于主题topic发布订阅"><a href="#基于主题topic发布订阅" class="headerlink" title="基于主题topic发布订阅"></a>基于主题topic发布订阅</h3><p> <strong>持久的发布主题生产者：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.durable;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ</span></span><br><span class="line"><span class="comment"> * JMS（Java Message Service）的生产者编码</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurableJmsProduceTopic</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String ACTIVE_URL = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String TOPIC_NAME = <span class="string">"topic-01"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接工厂，按照指定的url地址，采用默认用户名和密码</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVE_URL);</span><br><span class="line">        <span class="comment">//通过连接工厂创建连接</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建回话session，两个参数：事务和签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//常见目的地（队列或queue者主题topic）</span></span><br><span class="line">        Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">        <span class="comment">//创建生产者</span></span><br><span class="line">        MessageProducer producer = session.createProducer(topic);</span><br><span class="line">        <span class="comment">//设置持久化的topic生产者</span></span><br><span class="line">        producer.setDeliveryMode(DeliveryMode.PERSISTENT);</span><br><span class="line">        connection.start();</span><br><span class="line">        <span class="comment">//使用MessageProducer生产3条消息发送到MQ的队列里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建消息</span></span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">"msg------"</span> + i);</span><br><span class="line">            <span class="comment">//通过生产者MessageProducer发送给MQ</span></span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>持久的发布主题消费者：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.durable;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ</span></span><br><span class="line"><span class="comment"> * JMS（Java Message Service）的生产者编码</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurableJmsConsumerTopic</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String ACTIVEMQ_URL = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String TOPIC_NAME = <span class="string">"topic-01"</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JMSException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">"订阅者z3"</span>);</span><br><span class="line">        ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">        Connection connection = factory.createConnection();</span><br><span class="line">        connection.setClientID(<span class="string">"z3"</span>);</span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">        TopicSubscriber durableSubscriber = session.createDurableSubscriber(topic, <span class="string">"remark.."</span>);</span><br><span class="line"></span><br><span class="line">        connection.start();</span><br><span class="line"></span><br><span class="line">        Message message = durableSubscriber.receive();</span><br><span class="line">        <span class="keyword">while</span> (null != message) &#123;</span><br><span class="line">            TextMessage textMessage = (TextMessage) message;</span><br><span class="line">            System.out.println(textMessage.getText());</span><br><span class="line">            message = durableSubscriber.receive();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>持久化的表现：</strong><br>持久性的订阅者首先启动进行订阅，就算中途离线关掉了系统，也会在下次连接上线后收到消息。</p><h2 id="transaction：事务"><a href="#transaction：事务" class="headerlink" title="transaction：事务"></a>transaction：事务</h2><p>无论是在生产者还是消费者的时候都要创建一个session会话，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure><p>其中第一个参数就是事务，false代表关闭事务，true代表使用事务。</p><p>如果生产者和消费者都设置为false，那么在producer.send(message)之后，消息就会直接传到队列中，consumer.receive之后消息就会直接取出来；<br>如果生产者和消费者都设置为true，那么必须手动session.commit()进行提交，出错之候可以session.rollback()。如果不commit，那么：producer.send()之后，消息不会发送到消息队列中，并且因为没有commit，consumer.receive()会多次消费同一条消息。</p><h2 id="acknowledge-签收模式"><a href="#acknowledge-签收模式" class="headerlink" title="acknowledge 签收模式"></a>acknowledge 签收模式</h2><p>签收模式的效果如何与事务的开启与否有着密切的关系，主要常用的签收模式包括两种：自动签收AUTO_ACKNOWLEDGE和手动签收CLIENT_ACKNOWLEDGE。</p><p><strong>1、在事务为false的时候，签收模式为：AUTO_ACKNOWLEDGE</strong><br>在此模式下，为自动签收。不用任何操作就会签收，不会出现二次消费的情况<br><strong>2、在事务为false的时候，签收模式为：CLIENT_ACKNOWLEDGE</strong><br>在此模式下消息不会自动签收，必须使用message.acknowledge()手动对消息进行签收，否则会出现二次消费。<br><strong>3、在事务为true的时候，签收模式为：AUTO_ACKNOWLEDGE</strong><br>在此模式下，并且调用session.commit()进行事务提交的情况下为自动签收。若事务不提交，则会出现二次消费的情况。<br><strong>4、在事务为true的时候，签收模式为：CLIENT_ACKNOWLEDGE</strong><br>在此模式下，并且调用session.commit()进行事务提交的情况下为手动签收。若事务不提交，则会出现二次消费的情况。即使message.acknowledge()进行消息手动签收也会出现二次消费。</p><p><strong>总结：</strong><br>在事务关闭的情况下，消息是否自动签收取决于签收模式，如AUTO_ACKNOWLEDGE或者CLIENT_ACKNOWLEDGE；在事务开启的情况下，并且调用commit方法，则无论签收模式是什么<strong>都会</strong>自动提交，在事务开启的情况下，若不调用commit方法，则无论签收模式是什么<strong>都不会</strong>自动提交。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="JMS点对点模式总结"><a href="#JMS点对点模式总结" class="headerlink" title="JMS点对点模式总结"></a>JMS点对点模式总结</h2><p><img src="https://img-blog.csdnimg.cn/20191218111916699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="JMS发布订阅模式总结"><a href="#JMS发布订阅模式总结" class="headerlink" title="JMS发布订阅模式总结"></a>JMS发布订阅模式总结</h2><p><img src="https://img-blog.csdnimg.cn/20191218112010364.png" alt="在这里插入图片描述"></p><h3 id="非持久订阅"><a href="#非持久订阅" class="headerlink" title="非持久订阅"></a>非持久订阅</h3><p><img src="https://img-blog.csdnimg.cn/20191218112039889.png" alt="在这里插入图片描述"></p><h3 id="持久订阅"><a href="#持久订阅" class="headerlink" title="持久订阅"></a>持久订阅</h3><p><img src="https://img-blog.csdnimg.cn/20191218112054756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="用哪个"><a href="#用哪个" class="headerlink" title="用哪个"></a>用哪个</h3><p>当所有消息必须被接受，则用持久订阅。当丢失消息能够被容忍，则用非持久订阅。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;是什么&quot;&gt;&lt;a href=&quot;#是什么&quot; class=&quot;headerlink&quot; title=&quot;是什么&quot;&gt;&lt;/a&gt;是什么&lt;/h1&gt;&lt;p&gt;JMS是Java EE中的一部分，好比是盘子和点心的关系，JMS是Java EE中的额一个组成部分。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191217201717408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191217201745254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JMS" scheme="https://youngyang.top/categories/JMS/"/>
    
    
      <category term="JMS" scheme="https://youngyang.top/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>JUC之线程池</title>
    <link href="https://youngyang.top/2019/04/22/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://youngyang.top/2019/04/22/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T12:47:43.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h1><p>线程池做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><a id="more"></a><p>它的主要特点为：线程复用；控制最大并发数；管理线程。</p><p>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h1 id="线程池如何使用"><a href="#线程池如何使用" class="headerlink" title="线程池如何使用"></a>线程池如何使用</h1><p>Java API中为我们提供了许多写好的线程池，这些线程池都是通过Executor框架实现的，用到了Executor接口，Executors工具类，ExecutorService接口，ThreadPoolExecutor类。<br><img src="https://img-blog.csdnimg.cn/20191114204944549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>java API通过Executors工具类为我们提供了一些获取线程池的方法，常用的主要包括newFixedThreadPool(int nThreads)、newSingleThreadExecutor()、newCachedThreadPool()三个方法。</p><p>可通过如下方法获取API中提供的线程池并使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">ExecutorService threadPool1 = Executors.newFixedThreadPool(n);<span class="comment">//其中n为线程池中的固定线程数</span></span><br><span class="line"><span class="comment">//ExecutorService threadPool2 = Executor.newSingleThreadExecutor();//构建只包含一个线程的线程池</span></span><br><span class="line"><span class="comment">//ExecutorService threadPool3 = Executors.newCachedThreadPool();//构建一个线程数可扩展的线程池</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="comment">//execute方法定义在父接口Executor接口中（有且仅有一个方法）void execute(Runnable command)  </span></span><br><span class="line">threadpool1.execute(()-&gt;&#123;System.out.println(<span class="string">"Thread.currentThread().getName()"</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line"><span class="comment">//shutdown方法定义在ExecutorService中</span></span><br><span class="line">threadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="newFixedThreadPool-int-nThreads"><a href="#newFixedThreadPool-int-nThreads" class="headerlink" title="newFixedThreadPool(int nThreads)"></a>newFixedThreadPool(int nThreads)</h2><p>特点：执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程。<br>源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newFixedThreadPool()创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的是LinkedBlockingQueue。</p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor()"></a>newSingleThreadExecutor()</h2><p>特点：一个任务一个任务的执行，一池一线程。<br>源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newSingleThreadExecutor() 创建的线程池corePoolSize和maximumPoolSize值都是1，它使用的是LinkedBlockingQueue。</p><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool()"></a>newCachedThreadPool()</h2><p>特点：执行很多短期异步任务，线程池根据需要创建新线程，但在先前构建的线程可用时将重用它们。可扩容，遇强则强。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newCachedThreadPoo()创建的线程池将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，它使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p><h2 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h2><p><img src="https://img-blog.csdnimg.cn/2019111421320624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图所示，java中各种线程池，不管是单一线程还是可扩展线程数的线程池底层都是使用ThreadPoolExecutor类进行创建。<br>ThreadPoolExecutor类的构造方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor类的7大参数：<br><img src="https://img-blog.csdnimg.cn/20191114213400462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="线程池底层工作原理"><a href="#线程池底层工作原理" class="headerlink" title="线程池底层工作原理"></a>线程池底层工作原理</h1><p><img src="https://img-blog.csdnimg.cn/20191114213549689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20191114213527829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>流程如下：<br>1、在创建了线程池后，开始等待请求。<br>2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：<br>  2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；<br>  2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；<br>  2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；<br>  2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。<br>3、当一个线程完成任务时，它会从队列中取下一个任务来执行。<br>4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：<br>    如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。<br>    所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</p><h1 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h1><p>当等待队列已经排满了，再也塞不下新任务了同时，线程池中的max线程也达到了，无法继续为新任务服务。<br>这个是时候我们就需要拒绝策略机制合理的处理这个问题，JDK中为我们提供了4中拒绝策略，如下所示：<br>1、AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行。<br>2、CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。（谁调用的这个线程，回退给那个线程执行，如main线程调用线程池执行，则回调给main线程执行此任务）<br>3、DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。<br>4、DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略。</p><p>以上内置拒绝策略均实现了RejectedExecutionHandle接口。</p><p>常见：问题在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？<br>    <strong>答案</strong>：一个都不用，我们工作中只能使用自定义的。<br>    <img src="https://img-blog.csdnimg.cn/20191114214715301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所以自定义的线程池代码实例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.guigu.juc;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/11/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService myThreadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>,<span class="comment">//常驻核心线程数</span></span><br><span class="line">                <span class="number">10</span>,<span class="comment">//可容纳最大线程数</span></span><br><span class="line">                <span class="number">3</span>,<span class="comment">//多余空闲线程的存活时间</span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">//存活时间单位</span></span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>),<span class="comment">//阻塞任务队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),<span class="comment">//线程池中用于生成线程的线程工厂（一般默认）</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());<span class="comment">//拒绝策略</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                myThreadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            myThreadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何设置线程池中线程的数量"><a href="#如何设置线程池中线程的数量" class="headerlink" title="如何设置线程池中线程的数量"></a>如何设置线程池中线程的数量</h1><h2 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h2><p><img src="https://img-blog.csdnimg.cn/20191205203027295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="IO密集型"><a href="#IO密集型" class="headerlink" title="IO密集型"></a>IO密集型</h2><p><img src="https://img-blog.csdnimg.cn/20191205203052632.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191205203059964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程池的优势&quot;&gt;&lt;a href=&quot;#线程池的优势&quot; class=&quot;headerlink&quot; title=&quot;线程池的优势&quot;&gt;&lt;/a&gt;线程池的优势&lt;/h1&gt;&lt;p&gt;线程池做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。&lt;/p&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://youngyang.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="并发编程" scheme="https://youngyang.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JUC之阻塞队列BlockingQueue</title>
    <link href="https://youngyang.top/2019/04/22/JUC%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue/"/>
    <id>https://youngyang.top/2019/04/22/JUC%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T12:49:06.470Z</updated>
    
    <content type="html"><![CDATA[<p>在java.util.concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的一些成员，包括他们各自的功能以及常见使用场景。</p><a id="more"></a><h1 id="BlockingQueue优势"><a href="#BlockingQueue优势" class="headerlink" title="BlockingQueue优势"></a>BlockingQueue优势</h1><p>多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。<br>然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。好在此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。（在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）</p><h1 id="BlockingQueue介绍"><a href="#BlockingQueue介绍" class="headerlink" title="BlockingQueue介绍"></a>BlockingQueue介绍</h1><h2 id="BlockingQueue架构介绍"><a href="#BlockingQueue架构介绍" class="headerlink" title="BlockingQueue架构介绍"></a>BlockingQueue架构介绍</h2><p>BlockingQueue接口是Queue的子接口，而Queue接口和List接口Set接口一样，都是Collection的子接口。具体实现关系如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191114221959715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="BlockingQueue结构"><a href="#BlockingQueue结构" class="headerlink" title="BlockingQueue结构"></a>BlockingQueue结构</h2><p>阻塞队列，顾名思义，首先它是一个队列，而一个队列在数据结构中所起的作用大致如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191114221322916.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图我们可以很清楚看到，通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；线程1往阻塞队列里添加元素，线程2从阻塞队列里移除元素。</p><p><strong>当队列是空的，从队列中获取元素的操作将会被阻塞；当队列是满的，从队列中添加元素的操作将会被阻塞。</strong></p><p>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素。<br>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增。</p><h2 id="BlockingQueue种类"><a href="#BlockingQueue种类" class="headerlink" title="BlockingQueue种类"></a>BlockingQueue种类</h2><p>BlockingQueue有如下7个实现类，常用的如下面红色所示：<br><img src="https://img-blog.csdnimg.cn/20191114222752980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="BlockingQueue的核心方法"><a href="#BlockingQueue的核心方法" class="headerlink" title="BlockingQueue的核心方法"></a>BlockingQueue的核心方法</h2><p>作为BlockingQueue的使用者，我们再也不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了。既然BlockingQueue如此神通广大，让我们一起来见识下它的常用方法：<br><img src="https://img-blog.csdnimg.cn/20191114222944455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191114223006143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在java.util.concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的一些成员，包括他们各自的功能以及常见使用场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JUC" scheme="https://youngyang.top/categories/JUC/"/>
    
    
      <category term="JUC" scheme="https://youngyang.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java 8之流式计算</title>
    <link href="https://youngyang.top/2019/04/22/Java%208%E4%B9%8B%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    <id>https://youngyang.top/2019/04/22/Java%208%E4%B9%8B%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T13:02:18.340Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。用周阳大神的话说就是：SQL就是JAVA，JAVA就是SQL。使用java.util.stream包中的Stream接口即可完成SQL中的计算、order by、where等操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。流式操作实现了集合的过滤、排序、映射等功能。</p><a id="more"></a><h1 id="四大内置核心函数式接口"><a href="#四大内置核心函数式接口" class="headerlink" title="四大内置核心函数式接口"></a>四大内置核心函数式接口</h1><p>大部分函数式接口都不用我们自己写，Java 8都给我们写好了，这些接口都在java.util.function包里，下面简单介绍其中的几个。而在讲到Java 8中利用Stream的流式计算的时候，就不得不提及到java.util.function包中的四大函数式接口，分别是<strong>Function</strong>函数接口、<strong>Predicate</strong>函数式接口、<strong>Consumer</strong>函数式接口和<strong>Supplier</strong>函数式接口。</p><h2 id="Function函数型函数式接口"><a href="#Function函数型函数式接口" class="headerlink" title="Function函数型函数式接口"></a>Function函数型函数式接口</h2><p> Function接口为函数型接口，该接口的抽象方法接收一个参数并且做一些处理然后返回返回一个参数。其中T为接收参数类型，R为返回参数类型。<br> 源码如下：其中的抽象方法为 <strong>R apply(T t)</strong><img src="https://img-blog.csdnimg.cn/20191115170254736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Predicate断言型函数式接口"><a href="#Predicate断言型函数式接口" class="headerlink" title="Predicate断言型函数式接口"></a>Predicate断言型函数式接口</h2><p>Predicate 用于做判断操作，所以抽象方法返回的是Boolean。<br>源码如下：抽象方法为： <strong>boolean test(T t)</strong><br><img src="https://img-blog.csdnimg.cn/20191115170814909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Consumer消费型函数式接口"><a href="#Consumer消费型函数式接口" class="headerlink" title="Consumer消费型函数式接口"></a>Consumer<strong>消费型函数式接口</strong></h2><p>Consumer表示执行在单个参数上面的操作，但没有返回值的（正如消费有去无回）。<br>该类的源码如下：抽象方法为：<strong>void accept(T t)</strong><br><img src="https://img-blog.csdnimg.cn/20191115171119346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Supplier供给型函数式接口"><a href="#Supplier供给型函数式接口" class="headerlink" title="Supplier供给型函数式接口"></a>Supplier<strong>供给型函数式接口</strong></h2><p>该接口不接受任何参数，返回一个任意泛型的值。<br>该类的源码如下：<strong>T get()</strong><br><img src="https://img-blog.csdnimg.cn/20191115171253184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/20191115171323494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1><p>流(Stream) 到底是什么呢？<br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！”</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、Stream 自己不会存储元素。<br>2、Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。<br>3、Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>1、创建一个Stream：一个数据源（数组、集合）。（如list.stream()将List转换为Stream）<br>2、中间操作：一个中间操作，处理数据源数据。<br>3、终止操作：一个终止操作，执行中间操作链，产生结果。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.juc.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String  userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：请按照给出数据，找出同时满足</span></span><br><span class="line"><span class="comment"> *      偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序</span></span><br><span class="line"><span class="comment"> *      最后只输出一个用户名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">11</span>,<span class="string">"a"</span>,<span class="number">23</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">12</span>,<span class="string">"b"</span>,<span class="number">24</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">13</span>,<span class="string">"c"</span>,<span class="number">22</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">14</span>,<span class="string">"d"</span>,<span class="number">28</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">16</span>,<span class="string">"e"</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; <span class="built_in">list</span> = Arrays.asList(u1,u2,u3,u4,u5);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span>.stream().filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getId() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;).filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getAge() &gt; <span class="number">24</span>;</span><br><span class="line">        &#125;).<span class="built_in">map</span>(f -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> f.getUserName().toUpperCase();</span><br><span class="line">        &#125;).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    R apply(T t);</span></span><br><span class="line">        Function&lt;String,Integer&gt; function = t -&gt; &#123;<span class="keyword">return</span> t.length();&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">"abc"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean test(T t);</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = t -&gt; &#123;<span class="keyword">return</span> t.startsWith(<span class="string">"a"</span>);&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void accept(T t);</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = t -&gt; &#123;System.out.println(t);&#125;;</span><br><span class="line">        consumer.accept(<span class="string">"java1018"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    T get();</span></span><br><span class="line">        Supplier&lt;String&gt; supplier =  () -&gt; &#123;<span class="keyword">return</span> UUID.randomUUID().toString();&#125;;</span><br><span class="line">        System.out.println(supplier.get());;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8 引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。用周阳大神的话说就是：SQL就是JAVA，JAVA就是SQL。使用java.util.stream包中的Stream接口即可完成SQL中的计算、order by、where等操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。流式操作实现了集合的过滤、排序、映射等功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java8新特性，流式计算" scheme="https://youngyang.top/categories/Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%8C%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="Java8新特性" scheme="https://youngyang.top/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="流式计算" scheme="https://youngyang.top/tags/%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>JVM的7种垃圾回收器</title>
    <link href="https://youngyang.top/2019/04/22/JVM%E7%9A%847%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://youngyang.top/2019/04/22/JVM%E7%9A%847%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T12:50:00.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收算法和垃圾回收器"><a href="#垃圾回收算法和垃圾回收器" class="headerlink" title="垃圾回收算法和垃圾回收器"></a>垃圾回收算法和垃圾回收器</h1><p>对于JVM的垃圾回收算法有复制算法、标记清除、标记整理。</p><p>用阳哥的话就是：这些算法只是天上飞的理念，是一种方法论，但是真正的垃圾回收还需要有落地实现，所以垃圾回收器应运而生。</p><p>JVM回收的区域包括方法区和堆，jvm对于不同区域不同的特点采用分代收集算法，比如因为所有的对象都是在Eden区进行分配，并且大部分对象的存活时间都不长，都是“朝生夕死”的，每次新生代存活的对象都不多，所以新采取复制算法；而jvm默认是新生代的对象熬过15次GC才能进入老年代，所以老年代的对象都是生命周期比较长的，采用标记清除或者标记整理算法。</p><p>那么对于这些算法的实现都有什么呢？</p><a id="more"></a><p><strong><em>新生代：serial、ParNew、Parallel<br>老年代：Serial Old、Parallel Old、CMS<br>全堆：G1</em></strong></p><p>并且他们的搭配组合如下：<br><img src="https://img-blog.csdnimg.cn/20200329183345463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p>jvm的垃圾回收器大体上的分类主要包括四种：串行、并行、并发（CMS）和G1。</p><p><strong>串行垃圾回收器（Serial）</strong>：它为单线程环境设计并且只使用一个线程进行垃圾回收，会暂停所有的用户线程。所以不适合服务器环境。<br><strong>并行垃圾回收器（Parallel）</strong>：多个垃圾回收线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理等弱交互场景。<br><strong>并发垃圾回收器（CMS）</strong>：用户线程和垃圾收集线程同时执行（不一定是并行，可能交替执行），不需要停顿用户线程。互联网公司多用它，适用于对响应时间有要求的场景。<br><strong>G1垃圾回收器</strong>：G1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收。<br><img src="https://img-blog.csdnimg.cn/20200329183758412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="默认的垃圾回收器"><a href="#默认的垃圾回收器" class="headerlink" title="默认的垃圾回收器"></a>默认的垃圾回收器</h2><p>平时我们没有配置什么jvm参数，程序也能正常执行，那么JVM默认的垃圾回收器是什么呢？</p><p>那么如何查看默认的回收器呢？有很多方式，这里简单列举几种：<br>1.命令行方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200329184831286.png" alt="在这里插入图片描述"><br>可以看到jdk8默认的是使用的Parallel并行回收器。<br>2、jvm参数设置<br>在JVM运行之前加入参数同样可以查看，其实这两种方式是差不多的<br><img src="https://img-blog.csdnimg.cn/20200329184736708.png" alt="在这里插入图片描述"><br>3.jps+jinfo<br>先使用jps查看java进程号，在使用jinfo查看该进程的配置<br><img src="https://img-blog.csdnimg.cn/20200329185103280.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200329185124436.png" alt="在这里插入图片描述"></p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial是一个单线程收集器，在进行垃圾收集的时候必须停下所有的工作（Stop The World） 。<br><img src="https://img-blog.csdnimg.cn/20200329185621793.png" alt="在这里插入图片描述"><br>串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在进行垃圾收集过程中可能会产生较长的停顿(<br>Stop-The-World状态)。</p><p>虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虛拟机运行在Client模式下默认的新生代垃圾收集器。</p><p><strong>对应JVM参数是: -XX:+UseSerialGC</strong></p><p>开启后会使用: <strong>Serial(Young区用) + Serial Old(Old区用)</strong>的收集器组合：表示新生代、老年代都会使用串行回收收集器，新生代使用复制算法，老年代使用标记-整理算法。</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew是Serial收集器的升级版，将单线程进行垃圾回收升级为多线程进行垃圾回收，但是依旧会Stop The World。<br><img src="https://img-blog.csdnimg.cn/20200329192043546.png" alt="在这里插入图片描述"><br>ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景是<strong>配合老年代的CMS GC工作</strong>，其余的行为和<br>Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多java虚拟机运行在Server<br>模式下新生代的默认垃圾收集器。</p><p><strong>常用对应JVM参数: -XX:+UseParNewGC</strong></p><p>启用ParNew收集器，只影响新生代的收集，不影响老年代<br>开启。上述参数后，会使用: <strong>ParNew(Young区用) + Serial Old</strong>的收集器组合，新生代使用复制算法，老年代采用标记-整理算法。</p><p>但是，ParNew+Tenured这样的搭配，java8已经不再被推荐。<br><img src="https://img-blog.csdnimg.cn/20200329192521994.png" alt="在这里插入图片描述"></p><h2 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h2><p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，<strong>俗称吞吐<br>量优先收集器</strong>。一句话:串行收集器在新生代和老年代的并行化</p><p>首先先科普下什么是吞吐量：<br><strong>吞吐量(Thoughput）</strong>=运行用户代码时间(运行用户代码时间+垃圾收集时间)，也即比如程序运行100分钟，垃圾收集时间1分钟，<br>吞吐量就是99%)。</p><p>Parallel收集器重点关注的是:<br><strong>可控制的高吞吐量意味着高效利用CPU的时间，它多用于在后台运算而不需要太多交互的任务。</strong></p><p><strong>自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的-一个重要区别。</strong>自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间(-XX:MaxGCPauseMillis)或最大的吞吐量。</p><p><strong>常用JVM参数: -XX:+UseParallelGC或-XX:+UseParallelOldGC(可互相激活)使用Parallel Scanvenge收集器</strong></p><p>开启该参数后:使用<strong>Parallel收集器+Parallel Old</strong>的组合。新生代使用复制算法，老年代使用标记-整理算法。</p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>SerialOlid是Serial垃圾收集器老年代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默<br>的java虚拟机默认的年老代垃圾收集器。</p><p>在Server模式下，主要有两个用途(了解，版本已经到8及以后): .<br>1.在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。 ( Parallel Scavenge + Serial Old )<br>2.<strong>作为老年代版中使用CMS收集器的后备垃圾收集方案</strong>。</p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old收集器是Parallel Scavenge的老年代版木，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。<br>在JDK1.6之前，新生代使用Parallel Scavenge收集器只能搭配年老代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保<br>证整体的吞吐量。在JDK1.6之前(Parallel Scavenge + Serial Old )<br>Parallel Old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8后可以优先考虑新生代<br>Parallel Scavenge和年老代Parallel Old收集器的搭配策略。在 JDK1.8及后(Parallel Scavenge + Parallel Old )<br>JVM常用参数：<br><strong>-XX:+UseParallelOldGC</strong>使用Parallel Old收集器，设置该参数后，<strong>新生代Parallel+老年代Parallel Old</strong>。</p><h2 id="CMS-Concurrent-Mark-Sweep"><a href="#CMS-Concurrent-Mark-Sweep" class="headerlink" title="CMS(Concurrent Mark Sweep)"></a>CMS(Concurrent Mark Sweep)</h2><p><strong>CMS收集器(Concurrent Mark Sweep: 并发标记清除)是一种以获取最短回收停顿时间为目标的收集器</strong>。</p><p>适合应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。</p><p>CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。<br><img src="https://img-blog.csdnimg.cn/20200329194129287.png" alt="在这里插入图片描述"><br>Concurrent Mark Sweep并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行。</p><p>启该收集器的JVM参数: <strong>-XX:+UseConcMarkSweepGC</strong> 开启该参数后会自动将-XX:+UseParNewGC打开<br>开启该参数后，使用<strong>ParNew(Young区用) + CMS(Old区用) + Serial Old</strong>的收集器组合，Serial Old将作为CMS出错的后备收集器</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记：</strong>标记GC Roots能直接关联的对象。速度很快但是存在Stop The World。<br><strong>并发标记：</strong>进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行。<br><strong>重新标记：</strong>为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题。<br><strong>并发清除：</strong>对标记的对象进行清除回收。</p><p><strong>CMS优点：</strong>并发收集低停顿<br><strong>缺点：</strong><br>1.浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然会有新垃圾产生，这部分垃圾得标记过程之后，所以CMS无法在当收集中处理掉他们，只好留待下一次GC清理掉，这一部分垃圾称为浮动垃圾。在jdk1.5默认设置下，CMS收集器当老年代使用了68%的空间就会被激活，可以通过-XX:CMSInitialOccupancyFraction的值来提高触发百分比，在jdk1.6中CMS启动阈值提升到了92%，要是CMS运行期间预留的内存无法满足程序的需要，就会出现”Concurrent Mode Failure“，然后降级临时启用Serial Old收集器进行老年代的垃圾收集，这样停顿时间就很长了。所以-XX:CMSInitialOccupancyFraction设置太高容易导致大量”Concurrent Mode Failure“。</p><p>2.有空间碎片：CMS是一款基于“标记-清除”算法实现的，所以会产生空间碎片。为了解决这个问题，CMS提供了-XX:UseCMSCompactAtFullCollection开发参数用于开启内存碎片的合并整理，由于内存整理是无法并行的，所以停顿时间会变长。还有-XX:CMSFullGCBeforeCompaction，这个参数用于设置多少次不压缩Full GC后，跟着来一次带压缩的(默认为0)。</p><p>3.对CPU资源敏感。在并发标记和并发清除阶段虽然不会停止用户线程，但是会因为占用一部分cpu资源进行垃圾回收导致用户程序变慢。<br>CMS默认启动的回收线程数是（cpu数量+3）/4。所以CPU数量少会导致用户程序执行速度降低较多。</p><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1适用于全堆，既可以在新生代使用和老年代使用。G1与之前的收集器有很大的不同，是从不同的角度去设计的。</p><p>回想下之前的垃圾收集器的特点：<br>1.年轻代和老年代都是各自独立的连续的内存块。<br>2.年轻代Eden+from+to使用复制算法<br>3.老年代的收集必须扫描全部老年代内存空间。<br>4.都是以尽可能少而快速地执行GC为设计原则</p><p>G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色：<br>1、G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。<br>2、G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</p><p>CMS垃圾收集器虽然减少了暂停应用程序的运行时间，但是它还是存在着内存碎片问题。于是，为了去除内存碎片问题，同时又保留<br>CMS垃圾收集器低暂停时间的优点，JAVA7发布了一个新的垃圾收集器——G1垃圾收集器。</p><p>G1是在2012年才在jdk1.7u4中可用。 oracle官方计划在jdk9中将G1变成默认的垃圾收集器以替代CMS。它是一 款面向服务端应用的收<br>器，主要应用在多CPU和大内存服务器环境下，极大的减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换java8以前的CM:<br>集器。</p><p>主要改变是<strong>Eden，Survivor和Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的region ,每个region从1M到32M不等。- - 个region有可能属于Eden, Survivor或 者Tenured内存区域。</strong></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><img src="https://img-blog.csdnimg.cn/20200329195752141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200329195809972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200329195820666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>G1的最大好处是化整为零，避免全内存扫描，只需要按照区域来进行扫描即可。<br><img src="https://img-blog.csdnimg.cn/20200329195920191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200329195928775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>G1收集器大致可分为如下步骤：</p><p><strong>初始标记：</strong>仅标记GC Roots能直接到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。（需要线程停顿，但耗时很短。）<br><strong>并发标记：</strong>从GC Roots开始对堆中对象进行可达性分析，找出存活对象。（耗时较长，但可与用户程序并发执行）<br><strong>最终标记：</strong>为了修正在并发标记期间因用户程序执行而导致标记产生变化的那一部分标记记录。且对象的变化记录在线程Remembered Set  Logs里面，把Remembered Set  Logs里面的数据合并到Remembered Set中。（需要线程停顿，但可并行执行。）<br><strong>筛选回收：</strong>对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（可并发执行）<br><img src="https://img-blog.csdnimg.cn/2020032920005033.png" alt="在这里插入图片描述"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://img-blog.csdnimg.cn/20200329195049567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垃圾回收算法和垃圾回收器&quot;&gt;&lt;a href=&quot;#垃圾回收算法和垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收算法和垃圾回收器&quot;&gt;&lt;/a&gt;垃圾回收算法和垃圾回收器&lt;/h1&gt;&lt;p&gt;对于JVM的垃圾回收算法有复制算法、标记清除、标记整理。&lt;/p&gt;
&lt;p&gt;用阳哥的话就是：这些算法只是天上飞的理念，是一种方法论，但是真正的垃圾回收还需要有落地实现，所以垃圾回收器应运而生。&lt;/p&gt;
&lt;p&gt;JVM回收的区域包括方法区和堆，jvm对于不同区域不同的特点采用分代收集算法，比如因为所有的对象都是在Eden区进行分配，并且大部分对象的存活时间都不长，都是“朝生夕死”的，每次新生代存活的对象都不多，所以新采取复制算法；而jvm默认是新生代的对象熬过15次GC才能进入老年代，所以老年代的对象都是生命周期比较长的，采用标记清除或者标记整理算法。&lt;/p&gt;
&lt;p&gt;那么对于这些算法的实现都有什么呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://youngyang.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://youngyang.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java的四种引用：强引用、软引用、弱引用、虚引用</title>
    <link href="https://youngyang.top/2019/04/22/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    <id>https://youngyang.top/2019/04/22/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T12:36:25.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体引用架构"><a href="#整体引用架构" class="headerlink" title="整体引用架构"></a>整体引用架构</h2><p>Java中包括四种引用，分别是强引用、软引用、弱引用、虚引用。这些引用关系也对对象的生命周期有着重要的联系。</p><a id="more"></a><p>四种引用的架构图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200328213542771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>四种引用的区别和各自特点：<br><img src="https://img-blog.csdnimg.cn/20200328222546828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>Reference就是强引用，SoftReference是弱引用，WeakReference是弱引用，PhantomReference是虚引用。</strong></p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>对于普通的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object object = new Object();</span><br></pre></td></tr></table></figure><p>对于这种直接new出来赋值的操作就是强引用。</p><p>当内存不足，JVM开始垃圾回收，对于强引用的对象，<strong>就算是出现了OOM也不会对该对象进行回收</strong>。只有显式地设置o为null，或超出对象的生命周期范围，gc才认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。</p><p>强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在Java<br>中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达<br>状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要<br>原因之一。</p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，一般认为就是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略)。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref. SoftReference类来实现，可以让对象豁免一些垃圾收集。</p><p>对于只有软引用的对象来说，当<strong>系统内存充足时它不会被回收，当系统内存不足时它会被回收</strong>。软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收。</p><p>验证代码如下，在内存充足也就是不发生OOM的时候：<br><img src="https://img-blog.csdnimg.cn/20200328215014336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200328215316515.png" alt="在这里插入图片描述"><br>在内存不足发生OOM的时候：（这里我设置的是-Xms10m -Xmx10m，在程序中new了一个大数组，所以必回OOM）<br><img src="https://img-blog.csdnimg.cn/20200328215403466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/2020032821551984.png" alt="在这里插入图片描述"></p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用需要使用java.lang.ref.WeakReference来实现，他比软引用的生命周期更短。<strong>只要发生GC，该引用的对象就会被回收。</strong><br><img src="https://img-blog.csdnimg.cn/20200328220130849.png" alt="在这里插入图片描述"><br>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200328220152924.png" alt="在这里插入图片描述"></p><h2 id="使用软引用和弱引用的场景"><a href="#使用软引用和弱引用的场景" class="headerlink" title="使用软引用和弱引用的场景"></a>使用软引用和弱引用的场景</h2><p>假如有一个应用需要读取大量的本地图片：</p><p>如果每次读取图片都从硬盘读取则会严重影响性能，如果一次性全部加载到内存中又可能造成内存溢出。此时使用软引用可以解决这个问题。</p><p>设计思路是:用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span></span><br><span class="line">HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="WeakHasnMap"><a href="#WeakHasnMap" class="headerlink" title="WeakHasnMap"></a>WeakHasnMap</h2><p>WeakHashMap在使用上和HashMap没有任何的区别，只不过WeakHashMap的key被设置为null并经过gc垃圾回收之后，这个数据将会从map中被回收掉。<br>代码示例如下：<br><img src="https://img-blog.csdnimg.cn/20200328220718573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输出结果为：<br><img src="https://img-blog.csdnimg.cn/20200328220957355.png" alt="在这里插入图片描述"></p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用需要java.lang.ref:PhantomReference类来实现。</p><p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p><p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在<strong>任何时候都可能被垃圾回收器回收</strong>，它不能单独使用也不能通过它访问对象，虚引用必须和<strong>引用队列(ReferenceQueue)</strong>联合使用。<br>虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。</p><p>PhantomReference的get方法总是返回null,因此无法访问对应的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被<br>gc回收，用来实现比finalization机制更灵活的回收操作。</p><p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到–个系统通知或者后续添加进一步的处理。Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p><p>想要深入理解虚引用，我觉得很有必要理解一下引用队列。<br><img src="https://img-blog.csdnimg.cn/2020032822131292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>其实不管是对SoftReference对象还是WeakReference亦或者是PhantomReference来说他们不只是单单有一个传入引用对象的构造方法，他们还可以传入一个引用队列，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200328221544279.png" alt="在这里插入图片描述"><br>那么传入的这个引用对列有什么用呢？</p><p>这个引用队列的作用就是对象在被回收之前会被保存到引用队列中。<br>示例代码如下：<br><img src="https://img-blog.csdnimg.cn/20200328222212940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200328222154722.png" alt="在这里插入图片描述"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/20200328222247518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整体引用架构&quot;&gt;&lt;a href=&quot;#整体引用架构&quot; class=&quot;headerlink&quot; title=&quot;整体引用架构&quot;&gt;&lt;/a&gt;整体引用架构&lt;/h2&gt;&lt;p&gt;Java中包括四种引用，分别是强引用、软引用、弱引用、虚引用。这些引用关系也对对象的生命周期有着重要的联系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://youngyang.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://youngyang.top/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程的6种状态</title>
    <link href="https://youngyang.top/2019/04/22/Java%20%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81/"/>
    <id>https://youngyang.top/2019/04/22/Java%20%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T12:35:18.736Z</updated>
    
    <content type="html"><![CDATA[<p>关于Java线程的状态网上的说法不一，有的说是6种状态，有的说是5中状态，索性就查看了一下Java源码。Thread类里面有一个枚举类，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这个枚举类里面有6种类型，所以Java中的线程有6种状态。</p><p>关于各种状态的简单说明：<br><strong>NEW(初始)</strong>：线程被创建后尚未启动。<br><strong>RUNNABLE(运行)</strong>：包括了操作系统线程状态中的Running和<strong>Ready</strong>，也就是处于此状态的线程可能正在运行，也可能正在等待系统资源，如等待CPU为它分配时间片。<br><strong>BLOCKED(阻塞)</strong>：线程阻塞于锁。<br><strong>WAITING(等待)</strong>：线程需要等待其他线程做出一些特定动作（通知或中断）。<br><strong>TIME_WAITING(超时等待)</strong>：该状态不同于WAITING，它可以在指定的时间内自行返回。<br>TERMINATED(终止)：该线程已经执行完毕。</p><p>状态图 ：<br><img src="https://img-blog.csdnimg.cn/20200501000733227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>初始状态<br>通过继承Thread类或实现Runnable接口得到一个线程类，new一个实例出来，这个生成的线程就进入了初始状态。</li></ol><p>该线程没有被start()启动，但也不代表调用了start()状态就立即改变状态，中间还有一些步骤，如果在这个启动的过程中有另一个线程来获取它的状态，其实是不确定的，要看那些中间步骤是否已经完成了。</p><ol start="2"><li>运行状态<br>就绪状态</li></ol><p>包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程可能正在运行，也可能正在等待系统资源，如等待CPU为它分配时间片。就绪状态有资格运行，但是要等到调度程序选到，不选到永远都是就绪状态。</p><p>进入就绪状态的几种方式：</p><p>新建的线程调用start()方法进入就绪状态。<br>运行中线程时间片用完了，调用该线程的yield()方法进入就绪状态。<br>等待锁资源的线程拿到对象锁后进入就绪状态。<br>当前线程sleep()结束、其他线程join()结束、等待用户输入完毕、某个线程拿到对象锁，这些线程也将进入就绪状态。<br>运行中状态</p><p>线程调度程序从可运行线程池中选择一个线程作为当前线程时，该线程所处的状态。</p><ol start="3"><li><p>阻塞状态<br>线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p></li><li><p>等待状态<br>线程需要等待其他线程做通知或中断，如果没有就要一直等待下去。</p></li></ol><p>比如：<br>Thread1获取lock对象锁，之后调用wait()方法进入等待队列，而同时会释放掉对象锁，状态为Waiting。<br>Thread2获取lock对象锁后调用notify()方法通知一个等待线程，将其移到同步队列，然后继续执行自己Synchronized中的代码，当释放掉lock对象锁后，Thread1线程才有可能重新获取lock并执行先前未完成的代码（是否通知了Thread1要看线程调度器有没有选择Thread1）。</p><p>阻塞与等待的区别：</p><p>阻塞状态是等待着获取到一个排他锁，进入阻塞状态都是被动的，离开阻塞状态是因为其它线程释放了锁，不阻塞了。<br>等待状态是在等待一段时间或者某个唤醒动作的发生，进入等待状态是主动的。<br>5. 超时等待<br>与等待类似，但可以在指定的时间内自行返回。</p><ol start="6"><li>终止状态<br>当线程的run()方法完成时或主线程的main()方法完成时，我们就认为该线程终止了。这个线程对象也许是活的，但它不是一个线程。<br>线程一旦终止就不能复生。在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Java线程的状态网上的说法不一，有的说是6种状态，有的说是5中状态，索性就查看了一下Java源码。Thread类里面有一个枚举类，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; State &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NEW,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RUNNABLE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BLOCKED,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WAITING,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TIMED_WAITING,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TERMINATED;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="并发编程" scheme="https://youngyang.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://youngyang.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux中编辑工具vi</title>
    <link href="https://youngyang.top/2019/04/22/Linux%E4%B8%AD%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7vim/"/>
    <id>https://youngyang.top/2019/04/22/Linux%E4%B8%AD%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7vim/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T12:40:37.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vi与vim"><a href="#vi与vim" class="headerlink" title="vi与vim"></a>vi与vim</h1><p>vi编辑器是所有Unix及Linux系统下标准的编辑器，他就相当于windows系统中的记事本一样，它的强大不逊色于任何最新的文本编辑器。他是我们使用Linux系统不能缺少的工具。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，学会它后，您将在Linux的世界里畅行无阻。</p><a id="more"></a><h2 id="vim的特点"><a href="#vim的特点" class="headerlink" title="vim的特点"></a>vim的特点</h2><p>vim 具有程序编辑的能力，可以以字体颜色辨别语法的正确性，方便程序设计；<br>因为程序简单，编辑速度相当快速。<br>vim可以当作vi的升级版本，他可以用多种颜色的方式来显示一些特殊的信息。<br>vim会依据文件扩展名或者是文件内的开头信息， 判断该文件的内容而自动的执行该程序的语法判断式，再以颜色来显示程序代码与一般信息。<br>vim里面加入了很多额外的功能，例如支持正则表达式的搜索、多文件编辑、块复制等等。 这对于我们在Linux上进行一些配置文件的修改工作时是很棒的功能。</p><h2 id="为何要学-vi"><a href="#为何要学-vi" class="headerlink" title="为何要学 vi"></a>为何要学 vi</h2><p>所有的Unix Like系统都会内建vi文本编辑器，其他的文本编辑器则不一定会存在；<br>一些软件的编辑接口会主动调用vi (例如 crontab, visudo, edquota 等命令)；</p><h1 id="vi的使用"><a href="#vi的使用" class="headerlink" title="vi的使用"></a>vi的使用</h1><p>基本上vi可以分为三种状态，分别是一般模式、编辑模式和命令行模式，各模式的功能区分如下：</p><h2 id="一般模式："><a href="#一般模式：" class="headerlink" title="一般模式："></a>一般模式：</h2><p>以vi打开一个文件就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用上下左右按键来移动光标，你可以使用删除字符或删除整行来处理文件内容， 也可以使用复制、粘贴来处理你的文件数据。</p><h2 id="编辑模式："><a href="#编辑模式：" class="headerlink" title="编辑模式："></a>编辑模式：</h2><p>在一般模式中可以进行删除、复制、粘贴等的操作，但是却无法编辑文件的内容，只有当到你按下【i, I, o, O, a, A, r, R】等任何一个字母之后才会进入编辑模式。这时候屏幕的左下方会出现【INSERT或 REPLACE】的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下【Esc】即可退出编辑模式。</p><h2 id="命令行模式："><a href="#命令行模式：" class="headerlink" title="命令行模式："></a>命令行模式：</h2><p>输入【 : / ? 】三个中的任何一个，就可以将光标移动到最底下那一行。在这个模式中， 可以提供查找、读取、存盘、替换字符、离开vi、显示行号等的动作则是在此模式中完成的！</p><h2 id="一般模式可用的按钮说明"><a href="#一般模式可用的按钮说明" class="headerlink" title="一般模式可用的按钮说明"></a>一般模式可用的按钮说明</h2><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><p>【h、j、k、l】，分别控制光标左、下、上、右移一格<br>按【ctrl+b】屏幕往”后”移动一页<br>按【ctrl+f】屏幕往”前”移动一页</p><p>【n<space>】光标向右移动n个字符<br>【Home】移动到这一行的最前面字符处:0数字，但不能用数字小键盘上的数字<br>【End】 移动到这一行的最后面字符处:$，我测试好像不行<br>【w】光标跳到下个字的开头<br>【e】光标跳到下个字的字尾</p><p>【H】 光标移动到这个屏幕的最上方那一行的第一个字符<br>【M】 光标移动到这个屏幕的中间那一行的第一个字符<br>【L】光标移动到这个屏幕的最下方那一行的第一个字符</p><p>【G】 移动到这个文件的最后一行<br>【nG】移动到这个文件的第n行(可配合:set nu)<br>【gg】 移动到这个文件的第一行，相当于1G<br>【n<Enter>】光标向下移动n行</p><h3 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h3><p>【/word】 向光标向下寻找一个名称为word的字符串<br>【?word】 向光标向上寻找一个名称为word的字符串<br>【n】 代表重复前一个查找的动作<br>【N】 与n刚好相反，为【反向】进行行前一个查找动作</p><p>【:n1,n2s/word1/word2/g】  n1与n2为数字，在第n1与n2行之间查找word1 这个字符串，并将该字符串替换为word2</p><p>【:1,$s/word1/word2/g】 从第一行到最后一行查找word1字符串，并将该字符串替换为word2<br>【:1,$s/word1/word2/gc】 从第一行到最后一行查找word1字符串，并将该字符串替换为word2 ，且在替换前提示用户确认是否进行替换</p><h3 id="删除、复制与粘贴"><a href="#删除、复制与粘贴" class="headerlink" title="删除、复制与粘贴"></a>删除、复制与粘贴</h3><p>【x】 为向后删除一个字符 (相当于【del】键)<br>【X】 为向前删除一个字符(相当于【backspace】键)<br>【nx】 连续向后删除n个字符</p><p>【dd】 删除光标所在行<br>【ndd】 删除光标所在的向下n行<br>【d1G】 删除光标所在行到第一行的所有数据<br>【dG】 删除光标所在到最后一行的所有数据</p><p>【d$】 删除光标所在处，到该行的最后一个字符<br>【d0】 删除光标所在处，到该行的最前一个字符</p><p>【yy】 复制光标所在的那一行<br>【nyy】 复制光标所在的向下n列</p><p>【y1G】 复制光标所在行到第一行的所有数据<br>【yG】 复制光标所在行到最后一行的所有数据</p><p>【y0】 复制光标所在的那个字符到该行行首的所有数据<br>【y$】 复制光标所在的那个字符到该行行尾的所有数据</p><p>【p】将已复制的数据在光标下一行粘贴上<br>【P】 则为贴在光标的上一行</p><p>【u】 恢复前一个操作<br>【Ctrl+r】重做上一个操作</p><p>【.】 是重复前一个操作</p><h2 id="一般模式切换到编辑模式的可用的按钮说明"><a href="#一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="一般模式切换到编辑模式的可用的按钮说明"></a>一般模式切换到编辑模式的可用的按钮说明</h2><p>【i, I】 进入编辑模式：<br>i 为【从目前光标所在处插入】<br>I 为【在目前所在行的第一个非空格符处开始插入】</p><p>【a, A】 进入编辑模式(Insert mode)：<br>a 为【从目前光标所在的下一个字符处开始插入】<br>A 为【从光标所在行的最后一个字符处开始插入】</p><p>【o, O】 进入编辑模式：<br>o 为【在目前光标所在的下一行处插入新的一行】<br>O 为在目前光标所在处的上一行插入新的一行</p><p>【r, R】 进入取代模式：<br>r 只会取代光标所在的那一个字符一次<br>R会一直取代光标所在的文字，直到按下 ESC 为止；</p><p>【Esc】 退出编辑模式，回到一般模式</p><h2 id="一般模式切换到命令行模式可用的按钮说明"><a href="#一般模式切换到命令行模式可用的按钮说明" class="headerlink" title="一般模式切换到命令行模式可用的按钮说明"></a>一般模式切换到命令行模式可用的按钮说明</h2><p>【:w】 保存编辑的内容<br>【:w!】强制写入该文件，但跟你对该文件的权限有关<br>【:q】 离开vi<br>【:q!】 不想保存修改强制离开<br>【:wq】 保存后离开<br>【:x】 保存后离开<br>【ZZ】 若文件没有更动，则不保存离开，若文件已经被更改过，则保存后离开</p><p>【:w filename】 将编辑的数据保存成另一个文件（类似另存）<br>【:r filename】 在编辑的数据中，读入另一个文件的数据。即将【filename】 这个文件的内容加到光标所在行后面。</p><p>【:n1,n2 w filename】 将n1到n2的内容保存成filename这个文件。<br>【:! command】暂时离开vi 到命令行模式下执行command的显示结果！例如 【:! ls /home】即可在 vi 当中察看/home底下以ls输出的文件信息！</p><p>【:set nu】 显示行号<br>【:set nonu】 与 set nu 相反，为取消行</p><h2 id="vim的缓存文件、恢复与开启时的警告信息"><a href="#vim的缓存文件、恢复与开启时的警告信息" class="headerlink" title="vim的缓存文件、恢复与开启时的警告信息"></a>vim的缓存文件、恢复与开启时的警告信息</h2><p>我们知道一些常用的编辑软件，都有个恢复的功能，就是说当你的系统因为某些原因而导致类似当机的情况时，还可以利用这个恢复功能将之前未保存的数据找回来。我们的VIM也有这个功能。</p><p>当我们在使用vim编辑时，vim会在与被编辑的文件的目录下，再建立一个名为 .filename.swp的文件。如果你的系统因为某些原因断线了， 导致你编辑的文件还没有保存，这个时候 .filenam.swp 就能够发会救援的功能了。</p><p>我们来演示一下<br>vim man.config<br>ctrl+z放到后台执行<br>我们停止VI的进程<br>一种方法<br>ps aux |grep vi<br>kill -9 n</p><p>另外一种方法<br>jobs<br>kill -9 %1</p><p>我们用ls -l 命令来查看一下目录里面，会发现有个.man.config.swp的文件，这个文件就是个缓存的文件</p><p>我们再来编辑<br>vim man.config<br>这时候会出现一些信息<br>问题一：可能有其他人或程序同时在编辑这个文件：<br>问题二：在前一个vim的环境中，可能因为某些不知名原因导致vim中断 (crashed)：</p><p>右下角会出现六个命令项，其作用说明如下：<br>(O)pen Read-Only：打开此文件成为只读档， 可以用在你只是想要查阅该文件内容并不想要进行编辑行为时。一般来说，在上课时，如果你是登入到同学的计算机去看他的配置文件， 结果发现其实同学他自己也在编辑时，可以使用这个模式；<br>(E)dit anyway：还是用正常的方式打开你要编辑的那个文件， 并不会载入暂存盘的内容。如果说两个人都在编辑这个文件的话，很容易出现互相改变对方的文件等问题。<br>(R)ecover：就是加载暂存盘的内容，用在你要救回之前未保存的工作。 不过当你救回来并且储存离开vim后，还是要手动自行删除那个暂存档。<br>(D)elete it：你确定那个暂存档是无用的！那么开启文件前会先将这个暂存盘删除<br>(Q)uit：按下 q 就离开vim，不会进行任何动作回到命令提示字符。<br>(A)bort：忽略这个编辑行为，感觉上与 quit 非常类似！</p><h1 id="vim的功能"><a href="#vim的功能" class="headerlink" title="vim的功能"></a>vim的功能</h1><p>其实，目前大部分的Linux发行版本都以vim取代了vi。为什么要用vim呢？因为vim具有颜色显示的功能，并且还支持许多的程序语法(syntax)和相应的提示信息。查看自己的VI是不是被VIM代替，可以用<br>alias这个命令来查看是不是有alias vi=’vim’这一行。</p><p>块选择<br>【v】字符选择，会将光标经过的地方反白选择<br>【V】 行选择，会将光标经过的行反白选择<br>【Ctrl+v】 块选择，可以用长方形的方式选择资料 （提制竖列）<br>【y】 将反白的地方复制<br>【d】 将反白的地方删除</p><p>多文件编辑<br>大家在使用vim的时候，可能会碰到你需要复制一个文件中的某段到另外一个文件中，而vim不能够在关闭的时候，把这段保留住。或者是用其它的方法复制。<br>【vim file1 file2】</p><p>【:n】编辑下一个文件<br>【:N】编辑上一个文件<br>【:files】列出目前这个vim编辑的所有文件</p><p>多窗口功能<br>有两个需要对照着看的文件<br>【:sp filename】开启一个新窗口，如果有加 filename， 表示在新窗口开启一个新文件，否则表示两个窗口为同一个文件内容(同步显示)。</p><p>【ctrl+w+j】<br>【ctrl+w+↓】按键的按法是：先按下 【ctrl】 不放， 再按下 w 后放开所有的按键，然后再按下 j (或向下箭头键)，则光标可移动到下方的窗口。</p><p>【ctrl+w+k】<br>【ctrl+w+↑】同上，不过光标移动到上面的窗口。</p><p>vim 环境设定与记录(<del>/.vimrc, ~/.viminfo)<br>如果我们以vim软件来查找一个文件内部的某个字符串时，这个字符串会被反白， 而下次我们再次以vim编辑这个文件时，该查找的字符串反白情况还是存在。另外，当我们重复编辑同一个文件时，当第二次进入该文件时， 光标竟然就在上次离开的那一行的开头。这个功能可能是方便，但也有不方便的时候。怎么会这样呢？这是因为我们的vim会主动的将你曾经做过的行为登录下来，那个记录动作的文件就是： ~/.viminfo，不想用这个功能，就直接删除</del>/.viminfo。只要你曾经使用过vim，那么你的家目录就会有这个文件。这个文件是自动产生的，你在vim里头所做过的动作，就可以在这个文件内部找到。有兴趣的朋友可以自己查看文件里面的内容。</p><p>不过，对于每个不同的发行版本对vim的预设环境都不太相同。举例来说，某些版本在查找到关键词时并不会高亮度反白， 有些版本则会主动的帮你进行缩排（所谓的缩排，就是当你按下 Enter 编辑新的一行时，光标不会在行首，而是在与上一行的第一个非空格符处对齐）的行为。其实这些都可以自行设定的，下面我们就来看看vim的环境设定。<br>vim的环境设定参数有很多，如果你想要知道目前的设定值，可以在一般模式时输入【 :set all】来查阅，由于设定项目实在太多了，我们在这里就仅列出一些平时比较常用的一些简单的设定值，给大家提供参考。</p><p>:set all “显示目前所有的环境参数设定值<br>:set hlsearch “高亮度反白(高亮度搜寻)<br>:set nohlsearch “取消高亮度反白(高亮度搜寻)<br>:set backspace=2 “在编辑的时候可随时用退格键删除 （０、１的时候，只针对刚输入的字符有效）<br>:set autoindent “自动缩排<br>:set noautoindent “取消自动缩排<br>:set ruler “可显示最后一行的状态<br>:set showmode “左下角那一行的状态<br>:set nu “显示行号<br>:set nonu “取消行号<br>:set bg=dark “显示不同的底色色调<br>:syntax on “进行语法检验，颜色显示<br>:syntax off “关闭语法检验</p><p>了解完上面的内容后，下面我们就能写一下自己的vim操作环境。<br>整体vim的设定值一般是置在/etc/vimrc这个文件里面，不建议大家来修改他。我们在自己的家目录里面建立个.vimrc文件，在这里面写入自己的内容就能实现了。<br>[root@yufei ~]# vim ~/.vimrc<br>内容如下<br>set hlsearch “高亮度反白<br>set backspace=2 “可随时用退格键删除<br>set autoindent “自动缩排<br>set ruler “可显示最后一行的状态<br>set showmode “左下角那一行的状态<br>set nu “可以在每一行的最前面显示行号<br>set bg=dark “显示不同的底色色调<br>syntax on “进行语法检验，颜色显示<br>“这个文件的双引号 (“)表示的是注释</p><p>保存退出vim后，在下次使用vim的时候，就会有自己的vim操作环境了。<br>提醒一点，这个文件中每一行前面加不加【:】效果都是一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vi与vim&quot;&gt;&lt;a href=&quot;#vi与vim&quot; class=&quot;headerlink&quot; title=&quot;vi与vim&quot;&gt;&lt;/a&gt;vi与vim&lt;/h1&gt;&lt;p&gt;vi编辑器是所有Unix及Linux系统下标准的编辑器，他就相当于windows系统中的记事本一样，它的强大不逊色于任何最新的文本编辑器。他是我们使用Linux系统不能缺少的工具。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，学会它后，您将在Linux的世界里畅行无阻。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://youngyang.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://youngyang.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机类的加载过程</title>
    <link href="https://youngyang.top/2019/04/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://youngyang.top/2019/04/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T12:37:39.638Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客主要讲解Java虚拟机加载类的过程。</p><p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过<strong>加载，连接，初始化</strong>三步来实现这个类进行初始化。其中连接又包括三步：验证、准备和解析。</p><a id="more"></a><p>类的生命周期如图所示：<br><img src="https://img-blog.csdnimg.cn/20200514221537884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><p>“加载”是“类加载”（Class Loading）过程的一个阶段，希望读者没有混淆这两个看起来 很相似的名词。</p><p>在加载阶段，虚拟机需要完成以下3件事情：<br><strong>1）通过一个类的全限定名来获取定义此类的二进制字节流。<br> 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>  3）在内存中生成一个代表这个类的java.lang.Class对象。</strong></p><p>对 于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这 个对象将作为程序访问方法区中的这些类型数据的外部接口。</p><p>这里有两个重点：</p><p>字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译。</p><p>（1）Java虚拟机将.class文件读入内存，并为之创建一个Class对象。<br>（2）任何类被使用时系统都会为其创建<strong>一个且仅有一个</strong>Class对象。<br>（3）这个Class对象描述了这个类创建出来的对象的所有信息，比如有哪些构造方法，都有哪些成员方法，都有哪些成员变量等。</p><p>Student类加载过程图示：<br><img src="https://img-blog.csdnimg.cn/20200409225557693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机加载类使用的是类加载器，加载器分为四种：<br>分别是：<strong>Bootstrat Class Loader、Extension Class Loader、System Class Loader和用户自定义的类加载器</strong>。<br><img src="https://img-blog.csdnimg.cn/20200409225809652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="1、boot"><br>VM预定义有三种类加载器，当一个 JVM启动的时候，Java开始使用如下三种类加载器：</p><p> 1)<strong>根类加载器（bootstrap class loader）</strong>:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。<br> 2)<strong>扩展类加载器（extensions class loader）</strong>：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。<br>  3)<strong>系统类加载器（system class loader）</strong>：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p><strong>类加载器加载Class使用双亲委派机制：</strong><br>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 </p><p>采用双亲委派的一个好处是：<br>比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。 </p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>链接又包括三个阶段，分别是：验证、准备以及解析。</p><p>（1）<strong>验证阶段。验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</strong></p><p>包括对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？<br>对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？<br>对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。<br>对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p><p>（2）<strong>准备阶段</strong>：准备阶段是正式<strong>为类变量分配内存并设置类变量初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。</p><p>这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这 时候进行内存分配的<strong>仅包括类变量</strong>（被static修饰的变量），而<strong>不包括实例变量</strong>，实例变量将会在对象实例化时随着对象一起分配在Java堆中。通常情况下的初始值如下表：<br><img src="https://img-blog.csdnimg.cn/20200514222711997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其次，这里所说的初始值“通常情况”下是 数据类型的零值，假设一个类变量的定义为：public static final a = 1;<br>那么这个a就会直接被赋值为指定的值1。</p><p>（3）<strong>解析阶段</strong>。将类的二进制数据中的符号引用替换为直接引用。<br>说明：<br><strong>符号引用</strong>：即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。<br><strong>直接引用</strong>：可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。</p><p>举个例子来说，现在调用方法hello()，这个方法的地址是0xaabbccdd，那么hello就是符号引用，0xaabbccdd就是直接引用。</p><p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>这是类加载机制的最后一步，在这个阶段，java程序代码才开始真正执行。我们知道，<strong>在准备阶段已经为类变量赋过一次值。在初始化阶段，程序员可以根据自己的需求来赋值了。</strong></p><p>在初始化阶段，主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><p>①声明类变量是指定初始值<br>②使用静态代码块为类变量指定初始值</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>类加载过程只是一个类生命周期的一部分，在其前，有编译的过程，只有对源代码编译之后，才能获得能够被虚拟机加载的字节码文件；在其后还有具体的类使用过程，当使用完成之后，还会在方法区垃圾回收的过程中进行卸载（垃圾回收）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博客主要讲解Java虚拟机加载类的过程。&lt;/p&gt;
&lt;p&gt;当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过&lt;strong&gt;加载，连接，初始化&lt;/strong&gt;三步来实现这个类进行初始化。其中连接又包括三步：验证、准备和解析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="https://youngyang.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://youngyang.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>SpringDataJpa学习</title>
    <link href="https://youngyang.top/2019/04/22/SpringDataJpa%E5%AD%A6%E4%B9%A0%E4%B8%80/"/>
    <id>https://youngyang.top/2019/04/22/SpringDataJpa%E5%AD%A6%E4%B9%A0%E4%B8%80/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T12:53:49.495Z</updated>
    
    <content type="html"><![CDATA[<p>学springdatajpa之前，我觉得非常有必要复习一下Jpa规范和orm思想。</p><h1 id="JPA入门"><a href="#JPA入门" class="headerlink" title="JPA入门"></a>JPA入门</h1><h2 id="orm概述"><a href="#orm概述" class="headerlink" title="orm概述"></a>orm概述</h2><p>ORM（Object-Relational Mapping） 表示对象关系映射。在面向对象的软件开发中，通过ORM，就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了ORM对象关系映射。</p><p>简单的说：<strong>ORM就是建立实体类和数据库表之间的关系，从而达到操作实体类就相当于操作数据库表的目的。</strong></p><p>常见的orm框架：Mybatis（ibatis）、Hibernate、Jpa。</p><a id="more"></a><h2 id="JPA规范"><a href="#JPA规范" class="headerlink" title="JPA规范"></a>JPA规范</h2><p>JPA的全称是Java Persistence API， 即Java 持久化API，是SUN公司推出的一套基于ORM的规范，内部是由一系列的接口和抽象类构成。</p><p>JPA通过JDK 5.0注解描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p><p>JPA规范本质上就是一种ORM规范，注意不是ORM框架——因为JPA并未提供ORM实现，它只是制订了一些规范，提供了一些编程的API接口，但具体实现则由服务厂商来提供实现。<br><img src="https://img-blog.csdnimg.cn/20200303101517225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>JPA和Hibernate的关系就像JDBC和JDBC驱动的关系，JPA是规范，Hibernate除了作为ORM框架之外，它也是一种JPA实现。<strong><em>java代码调用JPA规范中的接口和实现类，但是接口并不能实现功能，实际实现功能的还是hibernate框架，而hibernate还是对jdbc的封装，从而操作数据库。</em></strong></p><h2 id="JPA入门-1"><a href="#JPA入门-1" class="headerlink" title="JPA入门"></a>JPA入门</h2><p>目的：通过JPA规范实现对数据库中客户表的操作。<br>步骤一：创建maven工程，导入依赖；<br>步骤二：建立数据库表和实体类对象<br>步骤三：编写JPA的配置文件；<br>步骤四：进行单元测试。</p><p>步骤一：创建maven工程，导入依赖；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">       &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;project.hibernate.version&gt;5.0.7.Final&lt;/project.hibernate.version&gt;</span><br><span class="line">   &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependencies&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">           &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!--lombok进行代码简化--&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.16.10&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- hibernate对jpa的支持包 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- c3p0数据库连接池 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;$&#123;project.hibernate.version&#125;&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- <span class="built_in">log</span>日志 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">       &lt;!-- Mysql驱动包 --&gt;</span><br><span class="line">       &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;5.1.6&lt;/version&gt;</span><br><span class="line">       &lt;/dependency&gt;</span><br><span class="line">   &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>步骤二：建立数据库表和实体类对象</p><p>创建数据库表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE jpa;</span><br><span class="line">USE jpa;</span><br><span class="line"></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">t_customer</span><span class="params">(</span></span></span><br><span class="line">cst_id INT(10) PRIMARY KEY AUTO_INCREMENT COMMENT'顾客id(主键)',</span><br><span class="line">cst_name VARCHAR(32) COMMENT'顾客姓名',</span><br><span class="line">cst_age INT(2) COMMENT '顾客年龄'</span><br><span class="line">)ENGINE=INNODB AUTO_INCREMENT=<span class="number">1</span> DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>创建实体类对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package top.youngyang.pojo;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line">@Data<span class="comment">//lombok为类添加了setter，getter，toString，hashcode和equal方法</span></span><br><span class="line">@Entity<span class="comment">//说明当前是一个实体类</span></span><br><span class="line">@Table(name = <span class="string">"t_customer"</span>)<span class="comment">//@Table指定该实体类对应的数据库表</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    @Id<span class="comment">//指明该字段为id主键</span></span><br><span class="line">    @GeneratedValue(strategy=GenerationType.IDENTITY)<span class="comment">//设置主键生成策略为自增</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    @Column(name = <span class="string">"cst_name"</span>)<span class="comment">//@Column指明该属性对应的字段</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    @Column(name = <span class="string">"cst_age"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤三：编写JPA的配置文件；</p><p>配置文件必须在META-INF文件夹下，并且名称为persistence.xml。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;persistence xmlns=<span class="string">"http://java.sun.com/xml/ns/persistence"</span> version=<span class="string">"2.0"</span>&gt;</span><br><span class="line">    &lt;!--在此约束下，需要配置persistence-unit，否则会报错</span><br><span class="line">        持久化单元：</span><br><span class="line">            name：持久化单元的名称</span><br><span class="line">            transaction-type:事务管理的方式</span><br><span class="line">                JTA：分布式事务管理</span><br><span class="line">                RESOURCE_LOCAL:本地事务管理</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;persistence-unit name=<span class="string">"myJpa"</span> transaction-type=<span class="string">"RESOURCE_LOCAL"</span>&gt;</span><br><span class="line">        &lt;!--jpa的实现方式--&gt;</span><br><span class="line">        &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;!--配置数据库的信息</span><br><span class="line">                用户名：javax.persistence.jdbc.user</span><br><span class="line">                密码：javax.persistence.jdbc.password</span><br><span class="line">                驱动：javax.persistence.jdbc.driver</span><br><span class="line">                url：javax.persistence.jdbc.url--&gt;</span><br><span class="line"></span><br><span class="line">            &lt;property name=<span class="string">"javax.persistence.jdbc.user"</span> value=<span class="string">"root"</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=<span class="string">"javax.persistence.jdbc.password"</span> value=<span class="string">"root"</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=<span class="string">"javax.persistence.jdbc.driver"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=<span class="string">"javax.persistence.jdbc.url"</span> value=<span class="string">"jdbc:mysql:///jpa"</span>&gt;&lt;/property&gt;</span><br><span class="line">            &lt;!--配置实现方的信息（此处为hibernate）</span><br><span class="line">                <span class="number">1.</span>是否显示sql</span><br><span class="line">                <span class="number">2.</span>自动创建数据库表</span><br><span class="line">                    create:无表时创建，有表删除在创建</span><br><span class="line">                    update：没有表才创建</span><br><span class="line">                    none：无论有没有表都不会创建</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;property name=<span class="string">"hibernate.show_sql"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">            &lt;property name=<span class="string">"hibernate.format_sql"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">            &lt;property name=<span class="string">"hibernate.hbm2ddl.auto"</span> value=<span class="string">"update"</span> /&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/persistence-unit&gt;</span><br><span class="line">&lt;/persistence&gt;</span><br></pre></td></tr></table></figure><p>步骤四：进行单元测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package top.youngyang;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> top.youngyang.pojo.Customer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityTransaction;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Persistence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJpa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建实体类管理器工厂，参数必须传入一个persistence-unit名称</span></span><br><span class="line">        EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory(<span class="string">"myJpa"</span>);</span><br><span class="line">        <span class="comment">//利用实体类管理器工厂创建实体类管理器</span></span><br><span class="line">        EntityManager entityManager = entityManagerFactory.createEntityManager();</span><br><span class="line">        <span class="comment">//获取事务，并且开启</span></span><br><span class="line">        EntityTransaction transaction = entityManager.getTransaction();</span><br><span class="line">        transaction.begin();</span><br><span class="line">        <span class="comment">//保存操作</span></span><br><span class="line">        Customer c = <span class="keyword">new</span> Customer(<span class="string">"hahha"</span>, <span class="number">11</span>);</span><br><span class="line">        entityManager.persist(c);</span><br><span class="line">        <span class="comment">//事务提交</span></span><br><span class="line">        transaction.commit();</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        entityManager.close();</span><br><span class="line">        entityManagerFactory.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>EntityManagerFactory</em></strong>：由javax.persistence.Persistence通过静态方法获得，主要是用来创建EntityManager。</p><p>由于EntityManagerFactory 是一个线程安全的对象（即多个线程访问同一个EntityManagerFactory 对象不会有线程安全问题），并且EntityManagerFactory 的创建极其浪费资源，所以在使用JPA编程时，我们可以对EntityManagerFactory 的创建进行优化，只需要做到一个工程只存在一个EntityManagerFactory 即可。</p><p><strong><em>EntityManager</em></strong>：在 JPA 规范中, EntityManager是完成持久化操作的核心对象。</p><p>实体类作为普通 java对象，只有在调用 EntityManager将其持久化后才会变成持久化对象。EntityManager对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过JPQL语句查询实体。</p><p>我们可以通过调用EntityManager的方法完成获取事务，以及持久化数据库的操作。<br>方法说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getTransaction : 获取事务对象</span><br><span class="line">persist ： 保存操作</span><br><span class="line">merge ： 更新操作</span><br><span class="line">remove ： 删除操作</span><br><span class="line">find/getReference ： 根据id查询。</span><br><span class="line">注意：find为立即加载，getReference为延迟加载，即什么时候使用什么时候加载。</span><br></pre></td></tr></table></figure><h2 id="JPA的复杂查询"><a href="#JPA的复杂查询" class="headerlink" title="JPA的复杂查询"></a>JPA的复杂查询</h2><p>在JPA规范中也可使用JPQL完成复杂查询，JPQL全称Java Persistence Query Language。<strong>和sql相似，但是sql语句的查询来源和条件等等都是数据库表中的，而jpql语句则是从实体类中。</strong></p><p>使用jpql完成查询所有操作，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJSPL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">"myJpa"</span>);</span><br><span class="line">        EntityManager entityManager = factory.createEntityManager();</span><br><span class="line">        EntityTransaction tx = entityManager.getTransaction();</span><br><span class="line">        tx.begin();</span><br><span class="line">        <span class="comment">//编写jpql语句</span></span><br><span class="line">        String jpql = <span class="string">"from Customer"</span>;</span><br><span class="line">        Query query = entityManager.createQuery(jpql);</span><br><span class="line">        List resultList = query.getResultList();</span><br><span class="line">        <span class="keyword">for</span>(Object e:resultList)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如sql语句相似，也可使用带有占位符的jpql语句，如使用jpql完成条件查询：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJSPL2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">"myJpa"</span>);</span><br><span class="line">        EntityManager entityManager = factory.createEntityManager();</span><br><span class="line">        EntityTransaction tx = entityManager.getTransaction();</span><br><span class="line">        tx.begin();</span><br><span class="line">        String jpql = <span class="string">"from Customer where name like ?"</span>;</span><br><span class="line">        Query query = entityManager.createQuery(jpql);</span><br><span class="line">        <span class="comment">//占位符赋值从q开始</span></span><br><span class="line">        query.setParameter(<span class="number">1</span>,<span class="string">"ha%"</span>);</span><br><span class="line">        List resultList = query.getResultList();</span><br><span class="line">        <span class="keyword">for</span>(Object e:resultList)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="SpringDataJpa"><a href="#SpringDataJpa" class="headerlink" title="SpringDataJpa"></a>SpringDataJpa</h1><p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套JPA应用框架，可使开发者用极简的代码即可实现对数据库的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率！</p><p>Spring Data JPA 让我们解脱了DAO层的操作，基本上所有CRUD都可以依赖于它来实现，在实际的工作工程中，推荐使用Spring Data JPA + ORM（如：hibernate）完成操作，这样在切换不同的ORM框架时提供了极大的方便，同时也使数据库层操作更加简单，方便解耦。</p><h2 id="SpringDataJpa、Hibernate和Jpa之间的关系"><a href="#SpringDataJpa、Hibernate和Jpa之间的关系" class="headerlink" title="SpringDataJpa、Hibernate和Jpa之间的关系"></a>SpringDataJpa、Hibernate和Jpa之间的关系</h2><p>JPA是一套规范，内部是有接口和抽象类组成的。hibernate是一套成熟的ORM框架，而且Hibernate实现了JPA规范，所以也可以称hibernate为JPA的一种实现方式，我们使用JPA的API编程，意味着站在更高的角度上看待问题（面向接口编程）。</p><p>Spring Data JPA是Spring提供的一套对JPA操作更加高级的封装，是在JPA规范下的专门用来进行数据持久化的解决方案。</p><p>三者之间的关系图：<br><img src="https://img-blog.csdnimg.cn/20200303113514754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>springdatajpa是对jpa规范的更加高级的封装，我们不在需要重复调用JPA规范完成功能，springdatajpa已经替我们完成。springdatajpa调用JPA规范完成功能，而JPA之是一套规范，只是一套接口和抽象类，底层还是使用hibernate完成实现，而hibernate对jdbc进行了封装，从而访问数据库。</p><h2 id="SpringDataJpa快速入门"><a href="#SpringDataJpa快速入门" class="headerlink" title="SpringDataJpa快速入门"></a>SpringDataJpa快速入门</h2><h3 id="步骤一：创建工程，导入坐标"><a href="#步骤一：创建工程，导入坐标" class="headerlink" title="步骤一：创建工程，导入坐标"></a>步骤一：创建工程，导入坐标</h3><p>使用Spring Data JPA，需要整合Spring与Spring Data JPA，并且需要提供JPA的服务提供者hibernate，所以需要导入spring相关坐标，hibernate坐标，数据库驱动坐标和SpringDataJpa坐标。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">      &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;</span><br><span class="line">      &lt;hibernate.version&gt;5.0.7.Final&lt;/hibernate.version&gt;</span><br><span class="line">      &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt;</span><br><span class="line">      &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt;</span><br><span class="line">      &lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt;</span><br><span class="line">      &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;4.9&lt;/version&gt;</span><br><span class="line">          &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;!-- spring aop相关jar包 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.6.8&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      </span><br><span class="line">&lt;!--spring ioc相关jar包--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">     &lt;!--spring对orm框架的支持--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- spring end --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- hibernate beg --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;5.2.1.Final&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- hibernate end --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- c3p0 连接池 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;c3p0&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;c3p0.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- c3p0 end --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- <span class="built_in">log</span>日志 --&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      &lt;!-- <span class="built_in">log</span> end --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;1.9.0.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">&lt;!--spring的单元测试--&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;!-- el beg 使用spring data jpa 必须引入 --&gt;</span><br><span class="line">      &lt;dependency&gt;  </span><br><span class="line">          &lt;groupId&gt;javax.el&lt;/groupId&gt;  </span><br><span class="line">          &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt;  </span><br><span class="line">          &lt;version&gt;2.2.4&lt;/version&gt;  </span><br><span class="line">      &lt;/dependency&gt;  </span><br><span class="line">      &lt;dependency&gt;  </span><br><span class="line">          &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;  </span><br><span class="line">          &lt;artifactId&gt;javax.el&lt;/artifactId&gt;  </span><br><span class="line">          &lt;version&gt;2.2.4&lt;/version&gt;  </span><br><span class="line">      &lt;/dependency&gt; </span><br><span class="line">      &lt;!-- el end --&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="整合SpringDataJpa和spring"><a href="#整合SpringDataJpa和spring" class="headerlink" title="整合SpringDataJpa和spring"></a>整合SpringDataJpa和spring</h3><p>applicationContext.xml文件内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">       xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       xmlns:jdbc=<span class="string">"http://www.springframework.org/schema/jdbc"</span> xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">       xmlns:jpa=<span class="string">"http://www.springframework.org/schema/data/jpa"</span> xmlns:task=<span class="string">"http://www.springframework.org/schema/task"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/data/jpa</span></span><br><span class="line"><span class="string">http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--spring 和 spring data jpa的配置--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">1.</span>创建entityManagerFactory对象交给spring容器管理--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"entityManagerFactoty"</span> class=<span class="string">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span> /&gt;</span><br><span class="line">        &lt;!--配置的扫描的包（实体类所在的包） --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"packagesToScan"</span> value=<span class="string">"top.youngyang.pojo"</span> /&gt;</span><br><span class="line">        &lt;!-- jpa的实现厂家 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"persistenceProvider"</span>&gt;</span><br><span class="line">            &lt;bean class=<span class="string">"org.hibernate.jpa.HibernatePersistenceProvider"</span>/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--jpa的供应商适配器 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"jpaVendorAdapter"</span>&gt;</span><br><span class="line">            &lt;bean class=<span class="string">"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"</span>&gt;</span><br><span class="line">                &lt;!--配置是否自动创建数据库表 --&gt;</span><br><span class="line">                &lt;property name=<span class="string">"generateDdl"</span> value=<span class="string">"false"</span> /&gt;</span><br><span class="line">                &lt;!--指定数据库类型 --&gt;</span><br><span class="line">                &lt;property name=<span class="string">"database"</span> value=<span class="string">"MYSQL"</span> /&gt;</span><br><span class="line">                &lt;!--数据库方言：支持的特有语法 --&gt;</span><br><span class="line">                &lt;property name=<span class="string">"databasePlatform"</span> value=<span class="string">"org.hibernate.dialect.MySQLDialect"</span> /&gt;</span><br><span class="line">                &lt;!--是否显示sql --&gt;</span><br><span class="line">                &lt;property name=<span class="string">"showSql"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--jpa的方言 ：高级的特性 --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"jpaDialect"</span> &gt;</span><br><span class="line">            &lt;bean class=<span class="string">"org.springframework.orm.jpa.vendor.HibernateJpaDialect"</span> /&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-<span class="number">-2.</span>创建数据库连接池 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"dataSource"</span> class=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"user"</span> value=<span class="string">"root"</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"password"</span> value=<span class="string">"root"</span>&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"jdbcUrl"</span> value=<span class="string">"jdbc:mysql:///jpa"</span> &gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"driverClass"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-<span class="number">-3.</span>整合spring dataJpa--&gt;</span><br><span class="line">    &lt;jpa:repositories base-package=<span class="string">"top.youngyang.dao"</span> transaction-manager-ref=<span class="string">"transactionManager"</span></span><br><span class="line">                      entity-manager-factory-ref=<span class="string">"entityManagerFactoty"</span> &gt;&lt;/jpa:repositories&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-<span class="number">-4.</span>配置事务管理器 --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"transactionManager"</span> class=<span class="string">"org.springframework.orm.jpa.JpaTransactionManager"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"entityManagerFactory"</span> ref=<span class="string">"entityManagerFactoty"</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">4.</span>txAdvice--&gt;</span><br><span class="line">    &lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"transactionManager"</span>&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"save*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"insert*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"update*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"delete*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"get*"</span> read-only=<span class="string">"true"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"find*"</span> read-only=<span class="string">"true"</span>/&gt;</span><br><span class="line">            &lt;tx:method name=<span class="string">"*"</span> propagation=<span class="string">"REQUIRED"</span>/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">5.</span>aop--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">"pointcut"</span> expression=<span class="string">"execution(* top.youngyang.service.*.*(..))"</span> /&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">"txAdvice"</span> pointcut-ref=<span class="string">"pointcut"</span> /&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-<span class="number">-5.</span>声明式事务 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">6.</span> 配置IOC包扫描--&gt;</span><br><span class="line">    &lt;context:component-scan base-package=<span class="string">"top.youngyang"</span> &gt;&lt;/context:component-scan&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="步骤三-编写数据库表和实体类以及配置他们的关系"><a href="#步骤三-编写数据库表和实体类以及配置他们的关系" class="headerlink" title="步骤三 编写数据库表和实体类以及配置他们的关系"></a>步骤三 编写数据库表和实体类以及配置他们的关系</h3><p>此部分内容与JPA入门相应的内容相同。</p><h3 id="步骤四-编写符合Spring-Data-JPA规范的Dao层接口"><a href="#步骤四-编写符合Spring-Data-JPA规范的Dao层接口" class="headerlink" title="步骤四 编写符合Spring Data JPA规范的Dao层接口"></a>步骤四 编写符合Spring Data JPA规范的Dao层接口</h3><p>在Spring Data JPA中，对于定义符合规范的Dao层接口，我们只需要遵循以下几点就可以了：<br>1.创建一个Dao层接口，并实现JpaRepository和JpaSpecificationExecutor<br>2.提供相应的泛型。</p><p>dao接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package top.youngyang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaSpecificationExecutor;</span><br><span class="line"><span class="keyword">import</span> top.youngyang.pojo.Customer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JpaRepository&lt;实体类类型，主键类型&gt;：用来完成基本CRUD操作</span></span><br><span class="line"><span class="comment"> * JpaSpecificationExecutor&lt;实体类类型&gt;：用于复杂查询（分页等查询操作）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> interface CustomerDao extends JpaRepository&lt;Customer,Integer&gt;, JpaSpecificationExecutor&lt;Customer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤五-单元测试"><a href="#步骤五-单元测试" class="headerlink" title="步骤五 单元测试"></a>步骤五 单元测试</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package top.youngyang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> top.youngyang.dao.CustomerDao;</span><br><span class="line"><span class="keyword">import</span> top.youngyang.pojo.Customer;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)<span class="comment">//声明spring提供的测试环境</span></span><br><span class="line">@ContextConfiguration(<span class="string">"classpath:applicationContext.xml"</span>)<span class="comment">//指定spring配置文件的地方</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringdataJpaTest</span> &#123;</span></span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Customer customer = customerDao.save(<span class="keyword">new</span> Customer(<span class="string">"1234"</span>, <span class="number">12</span>));</span><br><span class="line">        Assert.assertNotNull(customer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Customer customer = customerDao.findOne(<span class="number">3</span>);</span><br><span class="line">        Assert.assertNotNull(customer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SpringDataJpa的查询方式"><a href="#SpringDataJpa的查询方式" class="headerlink" title="SpringDataJpa的查询方式"></a>SpringDataJpa的查询方式</h1><p>在继承JpaRepository，和JpaRepository接口后,我们就可以使用接口中定义的方法进行查询</p><h2 id="1-继承JpaRepository后的方法列表"><a href="#1-继承JpaRepository后的方法列表" class="headerlink" title="1.继承JpaRepository后的方法列表"></a>1.继承JpaRepository后的方法列表</h2><p><img src="https://img-blog.csdnimg.cn/20200303215300743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-继承JpaSpecificationExecutor的方法列表"><a href="#2-继承JpaSpecificationExecutor的方法列表" class="headerlink" title="2.继承JpaSpecificationExecutor的方法列表"></a>2.继承JpaSpecificationExecutor的方法列表</h2><p><img src="https://img-blog.csdnimg.cn/20200303215323706.png" alt="在这里插入图片描述"></p><h2 id="3-使用JPQL语句查询"><a href="#3-使用JPQL语句查询" class="headerlink" title="3.使用JPQL语句查询"></a>3.使用JPQL语句查询</h2><p>使用Spring Data JPA继承自接口的查询方法已经可以解决大部分的应用场景，但是对于某些业务来说，我们还需要灵活的构造查询条件，这时就可以使用@Query注解，结合JPQL的语句方式完成查询</p><p>@Query 注解的使用非常简单，只需在方法上面标注该注解，同时提供一个JPQL查询语句即可，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface CustomerDao extends JpaRepository&lt;Customer,Integer&gt;, JpaSpecificationExecutor&lt;Customer&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用jpql定义自己的方法</span></span><br><span class="line">    @Query(<span class="string">"from Customer where id &gt; 2"</span>)</span><br><span class="line">    List&lt;Customer&gt; myFind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询。</p><p>若在jpql语句中使用到占位符，则方法中必须出现此参数，并且顺序不能改变，如要改变参数顺序，那么应该在占位符？后面加上索引(索引默认从1开始)，如?1。<br><strong>注意：在进行更新/删除操作时，要使用事物的支持（@Transactional），否则汇报异常。</strong></p><h2 id="4-使用SQL语句查询"><a href="#4-使用SQL语句查询" class="headerlink" title="4.使用SQL语句查询"></a>4.使用SQL语句查询</h2><p>在SpringDataJpa中不仅可以使用jpql语句查询，也可以使用sql语句查询，与jpql查询略有不同。需要在@Query注解中加入nativeQuery属性并设置为true，表明为本地查询（SQL查询），如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * nativeQuery : 使用本地sql的方式查询</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  @Query(value=<span class="string">"select * from cst_customer"</span>,nativeQuery=<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findSql</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="5-方法命名规则查询"><a href="#5-方法命名规则查询" class="headerlink" title="5.方法命名规则查询"></a>5.方法命名规则查询</h2><p>顾名思义，方法命名规则查询就是根据方法的名字，就能创建查询。只需要按照Spring Data JPA提供的方法命名规则定义方法的名称，就可以完成查询工作。Spring Data JPA在程序执行的时候会根据方法名称进行解析，并自动生成查询语句进行查询。</p><p>按照Spring Data JPA 定义的规则，查询方法以findBy开头，涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性首字母需大写。框架在进行方法名解析时，会先把方法名多余的前缀截取掉，然后对剩下部分进行解析。<br>如下所示：<br><img src="https://img-blog.csdnimg.cn/20200303223125680.png" alt="在这里插入图片描述"><br>此处表示模糊查询。</p><h1 id="SpringDataJpa动态查询"><a href="#SpringDataJpa动态查询" class="headerlink" title="SpringDataJpa动态查询"></a>SpringDataJpa动态查询</h1><p>有时我们在查询某个实体的时候，给定的条件是不固定的，这时就需要动态构建相应的查询语句，在Spring Data JPA中可以通过JpaSpecificationExecutor接口查询。相比JPQL,其优势是类型安全，更加的面向对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Sort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.domain.Specification;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *JpaSpecificationExecutor中定义的方法</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="keyword">public</span> interface JpaSpecificationExecutor&lt;T&gt; &#123;</span><br><span class="line">   <span class="comment">//根据条件查询一个对象</span></span><br><span class="line"> <span class="function">T <span class="title">findOne</span><span class="params">(Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">   <span class="comment">//根据条件查询集合</span></span><br><span class="line"> List&lt;T&gt; findAll(Specification&lt;T&gt; spec);</span><br><span class="line">   <span class="comment">//根据条件分页查询</span></span><br><span class="line"> Page&lt;T&gt; findAll(Specification&lt;T&gt; spec, Pageable pageable);</span><br><span class="line">   <span class="comment">//排序查询查询</span></span><br><span class="line"> List&lt;T&gt; findAll(Specification&lt;T&gt; spec, Sort sort);</span><br><span class="line">   <span class="comment">//统计查询</span></span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于JpaSpecificationExecutor，这个接口基本是围绕着Specification接口来定义的。我们可以简单的理解为，Specification构造的就是查询条件。</p><p><strong><em>Specification接口中只定义了如下一个方法：</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造查询条件</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*root：Root接口，代表查询的根对象，可以通过root获取实体中的属性</span></span><br><span class="line"><span class="comment">*query：代表一个顶层查询对象，用来自定义查询</span></span><br><span class="line"><span class="comment">*cb：用来构建查询，此对象里有很多条件方法</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="使用Specifications完成条件查询"><a href="#使用Specifications完成条件查询" class="headerlink" title="使用Specifications完成条件查询"></a>使用Specifications完成条件查询</h2><p><strong>注意：在使用精准查询（如name=zhangsan），可以直接进行查询，而其他的必须调用as()方法指定比较的对象，如as(String.class)。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依赖注入customerDao</span></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpecifications</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//使用匿名内部类的方式，创建一个Specification的实现类，并实现toPredicate方法</span></span><br><span class="line">Specification &lt;Customer&gt; spec = <span class="keyword">new</span> Specification&lt;Customer&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123;</span><br><span class="line"><span class="comment">//cb:构建查询，添加查询方式   like：模糊匹配</span></span><br><span class="line"><span class="comment">//root：从实体Customer对象中按照custName属性进行查询</span></span><br><span class="line"><span class="keyword">return</span> cb.like(root.get(<span class="string">"custName"</span>).as(String.class), <span class="string">"传智播客%"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Customer customer = customerDao.findOne(spec);</span><br><span class="line">System.out.println(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若查询天条件存在多个，则需要调用CriteriaBuilder 中的and或者or方法进行合成。<br>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpec2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Specification&lt;Customer&gt; specification = <span class="keyword">new</span> Specification&lt;Customer&gt;() &#123;</span><br><span class="line">           <span class="keyword">public</span> Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123;</span><br><span class="line">               Path&lt;Object&gt; name = root.get(<span class="string">"name"</span>);</span><br><span class="line">               Path&lt;Object&gt; age = root.get(<span class="string">"age"</span>);</span><br><span class="line">               <span class="comment">//第一个条件</span></span><br><span class="line">               Predicate predicate1 = cb.equal(name, <span class="string">"haha"</span>);</span><br><span class="line">               <span class="comment">//第二个条件</span></span><br><span class="line">               Predicate predicate2 = cb.equal(age, <span class="number">11</span>);</span><br><span class="line">               <span class="comment">//两个条件进行合成</span></span><br><span class="line">               Predicate <span class="keyword">and</span> = cb.<span class="keyword">and</span>(predicate1, predicate2);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">and</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       Customer customer = customerDao.findOne(specification);</span><br><span class="line">       System.out.println(customer);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="基于Specifications的分页查询"><a href="#基于Specifications的分页查询" class="headerlink" title="基于Specifications的分页查询"></a>基于Specifications的分页查询</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">   @Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//构造查询条件</span></span><br><span class="line">Specification&lt;Customer&gt; spec = <span class="keyword">new</span> Specification&lt;Customer&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> Predicate toPredicate(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123;</span><br><span class="line"><span class="keyword">return</span> cb.like(root.get(<span class="string">"custName"</span>).as(String.class), <span class="string">"传智%"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造分页参数</span></span><br><span class="line"><span class="comment"> * Pageable : 接口</span></span><br><span class="line"><span class="comment"> * PageRequest实现了Pageable接口，调用构造方法的形式构造</span></span><br><span class="line"><span class="comment"> * 第一个参数：页码（从0开始）</span></span><br><span class="line"><span class="comment"> * 第二个参数：每页查询条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询，封装为Spring Data Jpa 内部的page bean</span></span><br><span class="line"><span class="comment"> * 此重载的findAll方法为分页方法需要两个参数</span></span><br><span class="line"><span class="comment"> * 第一个参数：查询条件Specification</span></span><br><span class="line"><span class="comment"> * 第二个参数：分页参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Page&lt;Customer&gt; page = customerDao.findAll(spec,pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Spring Data JPA中的分页查询，是其内部自动实现的封装过程，返回的是一个Spring Data JPA提供的pageBean对象。其中的方法说明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//获取总页数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTotalPages</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="comment">//获取总记录数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getTotalElements</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取列表数据</span></span><br><span class="line">List&lt;T&gt; getContent();</span><br></pre></td></tr></table></figure><h2 id="CriteriaBuilder-中的比较方法对应关系"><a href="#CriteriaBuilder-中的比较方法对应关系" class="headerlink" title="CriteriaBuilder 中的比较方法对应关系"></a>CriteriaBuilder 中的比较方法对应关系</h2><p>CriteriaBuilder 中的主要常用比较方法对应的关系如下所示：<br><img src="https://img-blog.csdnimg.cn/20200309165708392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="SpringDataJpa中的多表操作"><a href="#SpringDataJpa中的多表操作" class="headerlink" title="SpringDataJpa中的多表操作"></a>SpringDataJpa中的多表操作</h1><h2 id="JPA中的一对多"><a href="#JPA中的一对多" class="headerlink" title="JPA中的一对多"></a>JPA中的一对多</h2><p>我们采用的示例为客户和联系人。</p><p> 客户：指的是一家公司，我们记为A。<br> 联系人：指的是A公司中的员工。</p><p> 在不考虑兼职的情况下，公司和员工的关系即为一对多。</p><h3 id="表关系建立"><a href="#表关系建立" class="headerlink" title="表关系建立"></a>表关系建立</h3><p>在一对多关系中，我们习惯把一的一方称之为主表，把多的一方称之为从表。在数据库中建立一对多的关系，需要使用数据库的外键约束。</p><p>什么是外键？<br>指的是从表中有一列，取值参照主表的主键，这一列就是外键。</p><p>一对多数据库关系的建立，如下图所示 ：<br><img src="https://img-blog.csdnimg.cn/20200309185649593.png" alt="在这里插入图片描述"></p><h3 id="实体类关系建立以及映射配置"><a href="#实体类关系建立以及映射配置" class="headerlink" title="实体类关系建立以及映射配置"></a>实体类关系建立以及映射配置</h3><p>两张表的sql语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建客户表*/</span></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">cst_customer</span> <span class="params">(</span></span></span><br><span class="line">  cust_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT '客户编号(主键)',</span><br><span class="line">  cust_name varchar(32) NOT NULL COMMENT '客户名称(公司名称)',</span><br><span class="line">  cust_source varchar(32) DEFAULT NULL COMMENT '客户信息来源',</span><br><span class="line">  cust_industry varchar(32) DEFAULT NULL COMMENT '客户所属行业',</span><br><span class="line">  cust_level varchar(32) DEFAULT NULL COMMENT '客户级别',</span><br><span class="line">  cust_address varchar(128) DEFAULT NULL COMMENT '客户联系地址',</span><br><span class="line">  cust_phone varchar(64) DEFAULT NULL COMMENT '客户联系电话',</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`cust_id`)</span></span></span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建联系人表*/</span></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">cst_linkman</span> <span class="params">(</span></span></span><br><span class="line">  lkm_id bigint(32) NOT NULL AUTO_INCREMENT COMMENT '联系人编号(主键)',</span><br><span class="line">  lkm_name varchar(16) DEFAULT NULL COMMENT '联系人姓名',</span><br><span class="line">  lkm_gender char(1) DEFAULT NULL COMMENT '联系人性别',</span><br><span class="line">  lkm_phone varchar(16) DEFAULT NULL COMMENT '联系人办公电话',</span><br><span class="line">  lkm_mobile varchar(16) DEFAULT NULL COMMENT '联系人手机',</span><br><span class="line">  lkm_email varchar(64) DEFAULT NULL COMMENT '联系人邮箱',</span><br><span class="line">  lkm_position varchar(16) DEFAULT NULL COMMENT '联系人职位',</span><br><span class="line">  lkm_memo varchar(512) DEFAULT NULL COMMENT '联系人备注',</span><br><span class="line">  lkm_cust_id bigint(32) NOT NULL COMMENT '客户id(外键)',</span><br><span class="line">  PRIMARY KEY (`lkm_id`),</span><br><span class="line">  KEY `FK_cst_linkman_lkm_cust_id` (`lkm_cust_id`),</span><br><span class="line">  CONSTRAINT `FK_cst_linkman_lkm_cust_id` FOREIGN KEY (`lkm_cust_id`) REFERENCES `cst_customer` (`cust_id`) ON DELETE NO ACTION ON UPDATE NO ACTION</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=<span class="number">3</span> DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><p>在实体类中，由于客户是少的一方，它应该包含多个联系人，所以实体类要体现出客户中有多个联系人的信息，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户的实体类</span></span><br><span class="line"><span class="comment"> * 明确使用的注解都是JPA规范的</span></span><br><span class="line"><span class="comment"> * 所以导包都要导入javax.persistence包下的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Entity<span class="comment">//表示当前类是一个实体类</span></span><br><span class="line">@Table(name=<span class="string">"cst_customer"</span>)<span class="comment">//建立当前实体类和表之间的对应关系</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line"></span><br><span class="line">@Id<span class="comment">//表明当前私有属性是主键</span></span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY)<span class="comment">//指定主键的生成策略</span></span><br><span class="line">@Column(name=<span class="string">"cust_id"</span>)<span class="comment">//指定和数据库表中的cust_id列对应</span></span><br><span class="line"><span class="keyword">private</span> Long custId;</span><br><span class="line">@Column(name=<span class="string">"cust_name"</span>)<span class="comment">//指定和数据库表中的cust_name列对应</span></span><br><span class="line"><span class="keyword">private</span> String custName;</span><br><span class="line">@Column(name=<span class="string">"cust_source"</span>)<span class="comment">//指定和数据库表中的cust_source列对应</span></span><br><span class="line"><span class="keyword">private</span> String custSource;</span><br><span class="line">@Column(name=<span class="string">"cust_industry"</span>)<span class="comment">//指定和数据库表中的cust_industry列对应</span></span><br><span class="line"><span class="keyword">private</span> String custIndustry;</span><br><span class="line">@Column(name=<span class="string">"cust_level"</span>)<span class="comment">//指定和数据库表中的cust_level列对应</span></span><br><span class="line"><span class="keyword">private</span> String custLevel;</span><br><span class="line">@Column(name=<span class="string">"cust_address"</span>)<span class="comment">//指定和数据库表中的cust_address列对应</span></span><br><span class="line"><span class="keyword">private</span> String custAddress;</span><br><span class="line">@Column(name=<span class="string">"cust_phone"</span>)<span class="comment">//指定和数据库表中的cust_phone列对应</span></span><br><span class="line"><span class="keyword">private</span> String custPhone;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置客户和联系人的一对多关系</span></span><br><span class="line">  @OneToMany(targetEntity=LinkMan.class)</span><br><span class="line">@JoinColumn(name=<span class="string">"lkm_cust_id"</span>,referencedColumnName=<span class="string">"cust_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;LinkMan&gt; linkmans = <span class="keyword">new</span> HashSet&lt;LinkMan&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getCustId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustId</span><span class="params">(Long custId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custId = custId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustName</span><span class="params">(String custName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custName = custName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustSource</span><span class="params">(String custSource)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custSource = custSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustIndustry</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custIndustry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustIndustry</span><span class="params">(String custIndustry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custIndustry = custIndustry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custLevel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustLevel</span><span class="params">(String custLevel)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custLevel = custLevel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustAddress</span><span class="params">(String custAddress)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custAddress = custAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCustPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> custPhone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustPhone</span><span class="params">(String custPhone)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.custPhone = custPhone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Set&lt;LinkMan&gt; getLinkmans() &#123;</span><br><span class="line"><span class="keyword">return</span> linkmans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLinkmans</span><span class="params">(Set&lt;LinkMan&gt; linkmans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.linkmans = linkmans;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Customer [custId="</span> + custId + <span class="string">", custName="</span> + custName + <span class="string">", custSource="</span> + custSource</span><br><span class="line">+ <span class="string">", custIndustry="</span> + custIndustry + <span class="string">", custLevel="</span> + custLevel + <span class="string">", custAddress="</span> + custAddress</span><br><span class="line">+ <span class="string">", custPhone="</span> + custPhone + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于联系人是多的一方，在实体类中要体现出，每个联系人只能对应一个客户，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 联系人的实体类（数据模型）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Entity</span><br><span class="line">@Table(name=<span class="string">"cst_linkman"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkMan</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY)</span><br><span class="line">@Column(name=<span class="string">"lkm_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Long lkmId;</span><br><span class="line">@Column(name=<span class="string">"lkm_name"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmName;</span><br><span class="line">@Column(name=<span class="string">"lkm_gender"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmGender;</span><br><span class="line">@Column(name=<span class="string">"lkm_phone"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmPhone;</span><br><span class="line">@Column(name=<span class="string">"lkm_mobile"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmMobile;</span><br><span class="line">@Column(name=<span class="string">"lkm_email"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmEmail;</span><br><span class="line">@Column(name=<span class="string">"lkm_position"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmPosition;</span><br><span class="line">@Column(name=<span class="string">"lkm_memo"</span>)</span><br><span class="line"><span class="keyword">private</span> String lkmMemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多对一关系映射：多个联系人对应客户</span></span><br><span class="line">@ManyToOne(targetEntity=Customer.class)</span><br><span class="line">@JoinColumn(name=<span class="string">"lkm_cust_id"</span>,referencedColumnName=<span class="string">"cust_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Customer customer;<span class="comment">//用它的主键，对应联系人表中的外键</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getLkmId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmId</span><span class="params">(Long lkmId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmId = lkmId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmName</span><span class="params">(String lkmName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmName = lkmName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmGender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmGender</span><span class="params">(String lkmGender)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmGender = lkmGender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmPhone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmPhone</span><span class="params">(String lkmPhone)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmPhone = lkmPhone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmMobile;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmMobile</span><span class="params">(String lkmMobile)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmMobile = lkmMobile;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmEmail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmEmail</span><span class="params">(String lkmEmail)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmEmail = lkmEmail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmPosition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmPosition</span><span class="params">(String lkmPosition)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmPosition = lkmPosition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLkmMemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> lkmMemo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLkmMemo</span><span class="params">(String lkmMemo)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.lkmMemo = lkmMemo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> customer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCustomer</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.customer = customer;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"LinkMan [lkmId="</span> + lkmId + <span class="string">", lkmName="</span> + lkmName + <span class="string">", lkmGender="</span> + lkmGender + <span class="string">", lkmPhone="</span></span><br><span class="line">+ lkmPhone + <span class="string">", lkmMobile="</span> + lkmMobile + <span class="string">", lkmEmail="</span> + lkmEmail + <span class="string">", lkmPosition="</span> + lkmPosition</span><br><span class="line">+ <span class="string">", lkmMemo="</span> + lkmMemo + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射的注解说明"><a href="#映射的注解说明" class="headerlink" title="映射的注解说明"></a>映射的注解说明</h3><p>@OneToMany:<br>       作用：建立一对多的关系映射<br>    属性：<br>        targetEntityClass：指定多的多方的类的字节码<br>        mappedBy：指定从表实体类中引用主表对象的名称。<br>        cascade：指定要使用的级联操作<br>        fetch：指定是否采用延迟加载<br>        orphanRemoval：是否使用孤儿删除</p><p>@ManyToOne<br>    作用：建立多对一的关系<br>    属性：<br>        targetEntityClass：指定一的一方实体类字节码<br>        cascade：指定要使用的级联操作<br>        fetch：指定是否采用延迟加载<br>        optional：关联是否可选。如果设置为false，则必须始终存在非空关系。</p><p>@JoinColumn<br> 作用：用于定义主键字段和外键字段的对应关系。<br>     属性：<br>        name：指定外键字段的名称<br>        referencedColumnName：指定引用主表的主键字段名称<br>        unique：是否唯一。默认值不唯一<br>        nullable：是否允许为空。默认值允许。<br>        insertable：是否允许插入。默认值允许。<br>        updatable：是否允许更新。默认值允许。<br>        columnDefinition：列的定义信息。</p><h3 id="一对多的操作"><a href="#一对多的操作" class="headerlink" title="一对多的操作"></a>一对多的操作</h3><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations=<span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneToManyTest</span> &#123;</span></span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> LinkManDao linkManDao;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存操作</span></span><br><span class="line"><span class="comment"> * 需求:</span></span><br><span class="line"><span class="comment"> * 保存一个客户和一个联系人</span></span><br><span class="line"><span class="comment"> * 要求：</span></span><br><span class="line"><span class="comment"> * 创建一个客户对象和一个联系人对象</span></span><br><span class="line"><span class="comment"> *  建立客户和联系人之间关联关系（双向一对多的关联关系）</span></span><br><span class="line"><span class="comment"> *  先保存客户，再保存联系人</span></span><br><span class="line"><span class="comment"> * 问题：</span></span><br><span class="line"><span class="comment"> *当我们建立了双向的关联关系之后，先保存主表，再保存从表时：</span></span><br><span class="line"><span class="comment"> *会产生2条insert和1条update.</span></span><br><span class="line"><span class="comment"> * 而实际开发中我们只需要2条insert。  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Test</span><br><span class="line">@Transactional  <span class="comment">//开启事务</span></span><br><span class="line">@Rollback(<span class="literal">false</span>)<span class="comment">//设置为不回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Customer c = <span class="keyword">new</span> Customer();</span><br><span class="line">c.setCustName(<span class="string">"TBD云集中心"</span>);</span><br><span class="line">c.setCustLevel(<span class="string">"VIP客户"</span>);</span><br><span class="line">c.setCustSource(<span class="string">"网络"</span>);</span><br><span class="line">c.setCustIndustry(<span class="string">"商业办公"</span>);</span><br><span class="line">c.setCustAddress(<span class="string">"昌平区北七家镇"</span>);</span><br><span class="line">c.setCustPhone(<span class="string">"010-84389340"</span>);</span><br><span class="line"></span><br><span class="line">LinkMan l = <span class="keyword">new</span> LinkMan();</span><br><span class="line">l.setLkmName(<span class="string">"TBD联系人"</span>);</span><br><span class="line">l.setLkmGender(<span class="string">"male"</span>);</span><br><span class="line">l.setLkmMobile(<span class="string">"13811111111"</span>);</span><br><span class="line">l.setLkmPhone(<span class="string">"010-34785348"</span>);</span><br><span class="line">l.setLkmEmail(<span class="string">"98354834@qq.com"</span>);</span><br><span class="line">l.setLkmPosition(<span class="string">"老师"</span>);</span><br><span class="line">l.setLkmMemo(<span class="string">"还行吧"</span>);</span><br><span class="line"></span><br><span class="line">c.getLinkMans().add(l);</span><br><span class="line">l.setCustomer(c);</span><br><span class="line">customerDao.save(c);</span><br><span class="line">linkManDao.save(l);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过保存的案例，我们可以发现在设置了双向关系之后，会发送两条insert语句，一条多余的update语句，那我们的解决是思路很简单，就是一的一方放弃维护权。<br>所以，我们只需要在从表配置他们的映射关系即可，否则会出现多余的update语句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *放弃外键维护权的配置将如下配置改为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">//@OneToMany(targetEntity=LinkMan.class)</span></span><br><span class="line"><span class="comment">//@JoinColumn(name="lkm_cust_id",referencedColumnName="cust_id")</span></span><br><span class="line"><span class="comment">//设置为</span></span><br><span class="line">@OneToMany(mappedBy=<span class="string">"customer"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;LinkMan&gt; linkmans = <span class="keyword">new</span> HashSet&lt;LinkMan&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">@Transactional</span><br><span class="line">@Rollback(<span class="literal">false</span>)<span class="comment">//设置为不回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">customerDao.<span class="keyword">delete</span>(<span class="number">1l</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除操作的说明如下：</p><p>删除从表数据：可以随时任意删除。</p><p>删除主表数据：</p><p>若有从表数据<br>  1、在默认情况下，它会把外键字段置为null，然后删除主表数据。如果在数据库的表结构上，外键字段有非空约束，默认情况就会报错了。<br>  2、如果配置了放弃维护关联关系的权利，则不能删除（与外键字段是否允许为null，没有关系）因为在删除时，它根本不会去更新从表的外键字段了。<br>  3、如果还想删除，使用级联删除引用</p><p>若没有从表数据引用：随便删</p><p>在实际开发中，级联删除请慎用！(在一对多的情况下)</p><h4 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h4><p>级联操作：指操作一个对象同时操作它的关联对象<br><strong><em>使用方法：只需要在操作主体的注解上配置cascade</em></strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cascade:配置级联操作</span></span><br><span class="line"><span class="comment"> * CascadeType.MERGE级联更新</span></span><br><span class="line"><span class="comment"> * CascadeType.PERSIST级联保存：</span></span><br><span class="line"><span class="comment"> * CascadeType.REFRESH 级联刷新：</span></span><br><span class="line"><span class="comment"> * CascadeType.REMOVE级联删除：</span></span><br><span class="line"><span class="comment"> * CascadeType.ALL包含所有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@OneToMany(mappedBy=<span class="string">"customer"</span>,cascade=CascadeType.ALL)</span><br></pre></td></tr></table></figure><h2 id="JPA中的多对多操作"><a href="#JPA中的多对多操作" class="headerlink" title="JPA中的多对多操作"></a>JPA中的多对多操作</h2><p>我们采用的示例为用户和角色。</p><p> 用户：指的是咱们班的每一个同学。<br> 角色：指的是咱们班同学的身份信息。</p><p> 比如A同学，它是我的学生，其中有个身份就是学生，还是家里的孩子，那么他还有个身份是子女。</p><p> 同时B同学，它也具有学生和子女的身份。</p><p> 那么任何一个同学都可能具有多个身份。同时学生这个身份可以被多个同学所具有。</p><p> 所以我们说，用户和角色之间的关系是多对多。</p><h3 id="表关系建立-1"><a href="#表关系建立-1" class="headerlink" title="表关系建立"></a>表关系建立</h3><p>多对多的表关系建立靠的是中间表，其中用户表和中间表的关系是一对多，角色表和中间表的关系也是一对多，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200311110814429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="实体类关系建立以及映射配置-1"><a href="#实体类关系建立以及映射配置-1" class="headerlink" title="实体类关系建立以及映射配置"></a>实体类关系建立以及映射配置</h3><p>一个用户可以具有多个角色，所以在用户实体类中应该包含多个角色的信息，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@Entity(targetEntity=Role.class)</span><br><span class="line">@Table(name=<span class="string">"sys_user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line"></span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY)</span><br><span class="line">@Column(name=<span class="string">"user_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Long userId;</span><br><span class="line">@Column(name=<span class="string">"user_code"</span>)</span><br><span class="line"><span class="keyword">private</span> String userCode;</span><br><span class="line">@Column(name=<span class="string">"user_name"</span>)</span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line">@Column(name=<span class="string">"user_password"</span>)</span><br><span class="line"><span class="keyword">private</span> String userPassword;</span><br><span class="line">@Column(name=<span class="string">"user_state"</span>)</span><br><span class="line"><span class="keyword">private</span> String userState;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多对多关系映射</span></span><br><span class="line">@ManyToMany(mappedBy=<span class="string">"users"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;SysRole&gt; roles = <span class="keyword">new</span> HashSet&lt;SysRole&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userId = userId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userCode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserCode</span><span class="params">(String userCode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userCode = userCode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userName = userName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userPassword;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserPassword</span><span class="params">(String userPassword)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userPassword = userPassword;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserState</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> userState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserState</span><span class="params">(String userState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.userState = userState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Set&lt;SysRole&gt; getRoles() &#123;</span><br><span class="line"><span class="keyword">return</span> roles;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(Set&lt;SysRole&gt; roles)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.roles = roles;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"SysUser [userId="</span> + userId + <span class="string">", userCode="</span> + userCode + <span class="string">", userName="</span> + userName + <span class="string">", userPassword="</span></span><br><span class="line">+ userPassword + <span class="string">", userState="</span> + userState + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个角色可以赋予多个用户，所以在角色实体类中应该包含多个用户的信息，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 角色的数据模型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Entity</span><br><span class="line">@Table(name=<span class="string">"sys_role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysRole</span> <span class="title">implements</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line"></span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy=GenerationType.IDENTITY)</span><br><span class="line">@Column(name=<span class="string">"role_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Long roleId;</span><br><span class="line">@Column(name=<span class="string">"role_name"</span>)</span><br><span class="line"><span class="keyword">private</span> String roleName;</span><br><span class="line">@Column(name=<span class="string">"role_memo"</span>)</span><br><span class="line"><span class="keyword">private</span> String roleMemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多对多关系映射</span></span><br><span class="line">@ManyToMany(targetEntity = User.class)</span><br><span class="line">@JoinTable(name=<span class="string">"user_role_rel"</span>,<span class="comment">//中间表的名称</span></span><br><span class="line">  <span class="comment">//中间表user_role_rel字段关联sys_role表的主键字段role_id</span></span><br><span class="line">  joinColumns=&#123;@JoinColumn(name=<span class="string">"role_id"</span>,referencedColumnName=<span class="string">"role_id"</span>)&#125;,</span><br><span class="line">  <span class="comment">//中间表user_role_rel的字段关联sys_user表的主键user_id</span></span><br><span class="line">  inverseJoinColumns=&#123;@JoinColumn(name=<span class="string">"user_id"</span>,referencedColumnName=<span class="string">"user_id"</span>)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">private</span> Set&lt;SysUser&gt; users = <span class="keyword">new</span> HashSet&lt;SysUser&gt;(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">getRoleId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> roleId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleId</span><span class="params">(Long roleId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.roleId = roleId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRoleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> roleName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleName</span><span class="params">(String roleName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.roleName = roleName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getRoleMemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> roleMemo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleMemo</span><span class="params">(String roleMemo)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.roleMemo = roleMemo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Set&lt;SysUser&gt; getUsers() &#123;</span><br><span class="line"><span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsers</span><span class="params">(Set&lt;SysUser&gt; users)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.users = users;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"SysRole [roleId="</span> + roleId + <span class="string">", roleName="</span> + roleName + <span class="string">", roleMemo="</span> + roleMemo + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="映射注解说明"><a href="#映射注解说明" class="headerlink" title="映射注解说明"></a>映射注解说明</h3><p>@ManyToMany<br>    作用：用于映射多对多关系<br>    属性：<br>        cascade：配置级联操作。<br>        fetch：配置是否采用延迟加载。<br>        targetEntity：配置目标的实体类。映射多对多的时候不用写。</p><p>@JoinTable<br>    作用：针对中间表的配置<br>    属性：<br>        nam：配置中间表的名称<br>        joinColumns：中间表的外键字段关联当前实体类所对应表的主键字段<br>        inverseJoinColumn：中间表的外键字段关联对方表的主键字段</p><p>@JoinColumn<br>    作用：用于定义主键字段和外键字段的对应关系。<br>    属性：<br>        name：指定外键字段的名称<br>        referencedColumnName：指定引用主表的主键字段名称<br>        unique：是否唯一。默认值不唯一<br>        nullable：是否允许为空。默认值允许。<br>        insertable：是否允许插入。默认值允许。<br>        updatable：是否允许更新。默认值允许。<br>        columnDefinition：列的定义信息。</p><h3 id="多对多的操作"><a href="#多对多的操作" class="headerlink" title="多对多的操作"></a>多对多的操作</h3><h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   @Autowired</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> RoleDao roleDao;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求：</span></span><br><span class="line"><span class="comment"> * 保存用户和角色</span></span><br><span class="line"><span class="comment"> * 要求：</span></span><br><span class="line"><span class="comment"> * 创建2个用户和3个角色</span></span><br><span class="line"><span class="comment"> * 让1号用户具有1号和2号角色(双向的)</span></span><br><span class="line"><span class="comment"> * 让2号用户具有2号和3号角色(双向的)</span></span><br><span class="line"><span class="comment"> *  保存用户和角色</span></span><br><span class="line"><span class="comment"> * 问题：</span></span><br><span class="line"><span class="comment"> *  在保存时，会出现主键重复的错误，因为都是要往中间表中保存数据造成的。</span></span><br><span class="line"><span class="comment"> * 解决办法：</span></span><br><span class="line"><span class="comment"> * 让任意一方放弃维护关联关系的权利</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Test</span><br><span class="line">@Transactional  <span class="comment">//开启事务</span></span><br><span class="line">@Rollback(<span class="literal">false</span>)<span class="comment">//设置为不回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">SysUser u1 = <span class="keyword">new</span> SysUser();</span><br><span class="line">u1.setUserName(<span class="string">"用户1"</span>);</span><br><span class="line">SysRole r1 = <span class="keyword">new</span> SysRole();</span><br><span class="line">r1.setRoleName(<span class="string">"角色1"</span>);</span><br><span class="line"><span class="comment">//建立关联关系</span></span><br><span class="line">u1.getRoles().add(r1);</span><br><span class="line">r1.getUsers().add(u1);</span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line">roleDao.save(r1);</span><br><span class="line">userDao.save(u1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多对多（保存）中，如果双向都设置关系，意味着双方都维护中间表，都会往中间表插入数据，中间表的2个字段又作为联合主键，所以报错，主键重复，解决保存失败的问题：只需要在任意一方放弃对中间表的维护权即可，推荐在被动的一方放弃，配置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放弃对中间表的维护权，解决保存中主键冲突的问题</span></span><br><span class="line">@ManyToMany(mappedBy=<span class="string">"roles"</span>)</span><br><span class="line"><span class="keyword">private</span> Set&lt;SysUser&gt; users = <span class="keyword">new</span> HashSet&lt;SysUser&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除操作</span></span><br><span class="line"><span class="comment"> * 在多对多的删除时，双向级联删除根本不能配置</span></span><br><span class="line"><span class="comment"> * 禁用</span></span><br><span class="line"><span class="comment"> *如果配了的话，如果数据之间有相互引用关系，可能会清空所有数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Test</span><br><span class="line">@Transactional</span><br><span class="line">@Rollback(<span class="literal">false</span>)<span class="comment">//设置为不回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao.<span class="keyword">delete</span>(<span class="number">1l</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象导航查询"><a href="#对象导航查询" class="headerlink" title="对象导航查询"></a>对象导航查询</h3><p>对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。例如：我们通过ID查询方式查出一个客户，可以调用Customer类中的getLinkMans()方法来获取该客户的所有联系人。对象导航查询的使用要求是：两个对象之间必须存在关联关系。</p><p>查询一个客户，获取该客户下的所有联系人</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line"><span class="comment">//由于是在java代码中测试，为了解决no session问题，将操作配置到同一个事务中</span></span><br><span class="line">@Transactional </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Customer customer = customerDao.findOne(<span class="number">5l</span>);</span><br><span class="line">Set&lt;LinkMan&gt; linkMans = customer.getLinkMans();<span class="comment">//对象导航查询</span></span><br><span class="line"><span class="keyword">for</span>(LinkMan linkMan : linkMans) &#123;</span><br><span class="line"> System.out.println(linkMan);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询一个联系人，获取该联系人的所有客户</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line"><span class="keyword">private</span> LinkManDao linkManDao;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkMan linkMan = linkManDao.findOne(<span class="number">4l</span>);</span><br><span class="line">Customer customer = linkMan.getCustomer(); <span class="comment">//对象导航查询</span></span><br><span class="line">System.out.println(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象导航查询的问题分析"><a href="#对象导航查询的问题分析" class="headerlink" title="对象导航查询的问题分析"></a>对象导航查询的问题分析</h4><p><strong><em>问题1：我们查询客户时，要不要把联系人查询出来？</em></strong></p><p>分析：如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的，不使用时又会白白的浪费了服务器内存。</p><p>解决：采用延迟加载的思想。通过配置的方式来设定当我们在需要使用时，发起真正的查询。（并且在多的一方进行查询，默认会立即加载直接查出一的一方的数据，而在一的一方查询，则会采用延迟加载的方式对多的一方进行查询，即用的时候才会发送sql语句进行查询。）<br>配置方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在客户对象的@OneToMany注解中添加fetch属性</span></span><br><span class="line"><span class="comment"> * FetchType.EAGER：立即加载</span></span><br><span class="line"><span class="comment"> * FetchType.LAZY：延迟加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@OneToMany(mappedBy=<span class="string">"customer"</span>,fetch=FetchType.EAGER)</span><br><span class="line"><span class="keyword">private</span> Set&lt;LinkMan&gt; linkMans = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong><em>问题2：我们查询联系人时，要不要把客户查询出来？</em></strong></p><p>分析：例如：查询联系人详情时，肯定会看看该联系人的所属客户。如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的话，一个对象不会消耗太多的内存。而且多数情况下我们都是要使用的。</p><p>解决： 采用立即加载的思想。通过配置的方式来设定，只要查询从表实体，就把主表实体对象同时查出来</p><p>配置方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在联系人对象的@ManyToOne注解中添加fetch属性</span></span><br><span class="line"><span class="comment"> * FetchType.EAGER：立即加载</span></span><br><span class="line"><span class="comment"> * FetchType.LAZY：延迟加载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@ManyToOne(targetEntity=Customer.class,fetch=FetchType.EAGER)</span><br><span class="line">@JoinColumn(name=<span class="string">"cst_lkm_id"</span>,referencedColumnName=<span class="string">"cust_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Customer customer;</span><br></pre></td></tr></table></figure><h3 id="specifiction的多表查询"><a href="#specifiction的多表查询" class="headerlink" title="specifiction的多表查询"></a>specifiction的多表查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specification的多表查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Specification&lt;LinkMan&gt; spec = <span class="keyword">new</span> Specification&lt;LinkMan&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> Predicate toPredicate(Root&lt;LinkMan&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123;</span><br><span class="line"><span class="comment">//Join代表链接查询，通过root对象获取</span></span><br><span class="line"><span class="comment">//创建的过程中，第一个参数为关联对象的属性名称，第二个参数为连接查询的方式（left，inner，right）</span></span><br><span class="line"><span class="comment">//JoinType.LEFT : 左外连接,JoinType.INNER：内连接,JoinType.RIGHT：右外连接</span></span><br><span class="line">Join&lt;LinkMan, Customer&gt; join = root.join(<span class="string">"customer"</span>,JoinType.INNER);</span><br><span class="line"><span class="keyword">return</span> cb.like(join.get(<span class="string">"custName"</span>).as(String.class),<span class="string">"传智播客1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">List&lt;LinkMan&gt; <span class="built_in">list</span> = linkManDao.findAll(spec);</span><br><span class="line"><span class="keyword">for</span> (LinkMan linkMan : <span class="built_in">list</span>) &#123;</span><br><span class="line">System.out.println(linkMan);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学springdatajpa之前，我觉得非常有必要复习一下Jpa规范和orm思想。&lt;/p&gt;
&lt;h1 id=&quot;JPA入门&quot;&gt;&lt;a href=&quot;#JPA入门&quot; class=&quot;headerlink&quot; title=&quot;JPA入门&quot;&gt;&lt;/a&gt;JPA入门&lt;/h1&gt;&lt;h2 id=&quot;orm概述&quot;&gt;&lt;a href=&quot;#orm概述&quot; class=&quot;headerlink&quot; title=&quot;orm概述&quot;&gt;&lt;/a&gt;orm概述&lt;/h2&gt;&lt;p&gt;ORM（Object-Relational Mapping） 表示对象关系映射。在面向对象的软件开发中，通过ORM，就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了ORM对象关系映射。&lt;/p&gt;
&lt;p&gt;简单的说：&lt;strong&gt;ORM就是建立实体类和数据库表之间的关系，从而达到操作实体类就相当于操作数据库表的目的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的orm框架：Mybatis（ibatis）、Hibernate、Jpa。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringDataJpa" scheme="https://youngyang.top/categories/SpringDataJpa/"/>
    
    
      <category term="SpringDataJpa" scheme="https://youngyang.top/tags/SpringDataJpa/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中对MVC进行扩展</title>
    <link href="https://youngyang.top/2019/04/22/Springboot%E4%B8%AD%E5%AF%B9mvc%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/"/>
    <id>https://youngyang.top/2019/04/22/Springboot%E4%B8%AD%E5%AF%B9mvc%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T12:59:16.910Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br>声明：本篇文章所有的内容都是基于<strong><em>springboot2.2.5</em></strong>的。</p><p>关于springboot对mvc的自动配置见我的另一篇博客：<a href="https://blog.csdn.net/qq_42013590/article/details/104879704" target="_blank" rel="noopener">https://blog.csdn.net/qq_42013590/article/details/104879704</a></p><p>对于已经有的自动配置显然很多时候并不能满足我们的需求，那么我们如何实现对mvc的扩展呢？</p><p><strong>观看其他博客结合看源码发现：<br>1）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置<br> 2）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（如：ViewResolver），sprngboot就会将用户配置的和自己默认的组合起来；<br> 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</strong></p><a id="more"></a><h1 id="实现WebMvcConfigurer接口"><a href="#实现WebMvcConfigurer接口" class="headerlink" title="实现WebMvcConfigurer接口"></a>实现WebMvcConfigurer接口</h1><p>springboot官方对于mvc的扩展时，建议我们实现WebMvcConfigurer接口，并且要将该实现类加入到容器中。</p><p>在以前比如 springboot1.x.x 的时候，我们可以继承WebMvcConfigurerAdapter这个抽象类来完成对mvc的扩展，但是这个类值·全部是对WebMvcConfigurer的空实现，远吗如下：<br><img src="https://img-blog.csdnimg.cn/20200319153243942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>对于在springboot 2.2.5版本已经废弃了这个类，idea中提示：<br><img src="https://img-blog.csdnimg.cn/20200319153343212.png" alt="在这里插入图片描述"><br>所以我们可以直接实现WebMvcConfigurer接口，反正WebMvcConfigurerAdapter也只是全部空实现。</p><p>并且WebMvcConfigurer接口中的方法全是default方法（java8之后支持在接口中定义default和static方法），所以我们可以只重写我们需要重写的方法：<br><img src="https://img-blog.csdnimg.cn/20200319154607545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>我们可以复写这个接口中的default方法实现扩展，比如：<br><img src="https://img-blog.csdnimg.cn/20200319155144587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中编写的我自己的登录拦截器如下所示：<br><img src="https://img-blog.csdnimg.cn/2020031916020254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="将组件加入到容器中替代默认配置"><a href="#将组件加入到容器中替代默认配置" class="headerlink" title="将组件加入到容器中替代默认配置"></a>将组件加入到容器中替代默认配置</h2><p>比如国际化需要的组件LocaleResolver：<br><img src="https://img-blog.csdnimg.cn/20200319155750729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以观察他的注解，只有<strong>容器中没有LocaleResolver这个组建的时候才帮我们自动配置</strong>，如果我们不想使用springboot的自动配置，我们可以写一个LocaleResolver并加入到容器中，这样默认的就会失效。</p><p><strong>步骤一：编写一个自己的LocaleResolver</strong><br>这个解析器的功能就是从get方式的请求中获取参数，在进行国际化，如下：<br><img src="https://img-blog.csdnimg.cn/20200319160245164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>步骤二：将国际化解析器加入到容器中</strong><br><img src="https://img-blog.csdnimg.cn/20200319163117609.png" alt="在这里插入图片描述"><br>这样就会自动替代springboot帮我们默认实现的。</p><h2 id="加入容器中一起生效"><a href="#加入容器中一起生效" class="headerlink" title="加入容器中一起生效"></a>加入容器中一起生效</h2><p>对于可以有多个生效的组件，我们只要将我们DIY的加入到容器中即可，例如ViewResolver，查看WebMvcAutoConfiguger：<br><img src="https://img-blog.csdnimg.cn/20200319162216134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>源码也是非常的体贴，还帮我们写了注释，ContentNegotiatingViewResolver会使用所有其他的视图解析器去定位一个视图，所以他应该有一个高的优先级，也就是会先加载他，他去帮我们调用其他的视图解析器。，之后debug的时候也可以看到。</p><p><strong>第一步：编写我自己ViewResolver：</strong><br><img src="https://img-blog.csdnimg.cn/20200319160952405.png" alt="在这里插入图片描述"><br> <strong>第二步：将自己编写的组件加入到容器中使之生效</strong><br><img src="https://img-blog.csdnimg.cn/20200319163742139.png" alt="在这里插入图片描述"><br><strong>第三步：debug查看我们的视图解析器是否生效</strong><br>DispaterServlet是web的入口，所有的请求都要经过它，其中的核心方法就是doService方法，doService()方法调用的是doDispater()方法，在这里设置一个断点，查看是否生效：<br><img src="https://img-blog.csdnimg.cn/20200319164053875.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200319164140114.png" alt="在这里插入图片描述"><br>可以观察到我们自己编写的ViewResolver已经加载进来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;声明：本篇文章所有的内容都是基于&lt;strong&gt;&lt;em&gt;springboot2.2.5&lt;/em&gt;&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;关于springboot对mvc的自动配置见我的另一篇博客：&lt;a href=&quot;https://blog.csdn.net/qq_42013590/article/details/104879704&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_42013590/article/details/104879704&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于已经有的自动配置显然很多时候并不能满足我们的需求，那么我们如何实现对mvc的扩展呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;观看其他博客结合看源码发现：&lt;br&gt;1）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置&lt;br&gt; 2）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（如：ViewResolver），sprngboot就会将用户配置的和自己默认的组合起来；&lt;br&gt; 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://youngyang.top/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://youngyang.top/tags/SpringBoot/"/>
    
      <category term="微服务" scheme="https://youngyang.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Docker学习之二</title>
    <link href="https://youngyang.top/2019/04/22/docke%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E4%B9%8B%E4%BA%8C/"/>
    <id>https://youngyang.top/2019/04/22/docke%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E4%B9%8B%E4%BA%8C/</id>
    <published>2019-04-22T06:47:40.000Z</published>
    <updated>2020-07-04T14:29:31.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h1><p>镜像是一种轻量级、可执行的独立软件包，<strong>用来打包软件运行环境和基于运行环境开发的软件</strong>，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><a id="more"></a><h2 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h2><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><h2 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统是UnionFS。</p><p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel， Linux刚启动时会加载bootfs文件系统，<strong>在Docker镜像的最底层是bootfs</strong>。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。<br><img src="https://img-blog.csdnimg.cn/202001062159462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</strong><br><img src="https://img-blog.csdnimg.cn/20200106220000303.png" alt="在这里插入图片描述"><br>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p><h2 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h2><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载。<br><img src="https://img-blog.csdnimg.cn/2020010622011221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>为什么docker镜像要采用这种分层的结构呢？</strong><br>最大的一个好处就是 - <strong>共享资源</strong>。<br>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，<br>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h2 id="镜像的特点"><a href="#镜像的特点" class="headerlink" title="镜像的特点"></a>镜像的特点</h2><p>docker镜像都是只读的。<br>当容器启动时，一个新的可写层被加载到镜像的顶部。<br>这一层通常称做“容器层”，“容器层”之下的都叫“镜像层”。</p><h2 id="docker镜像commit操作补充"><a href="#docker镜像commit操作补充" class="headerlink" title="docker镜像commit操作补充"></a>docker镜像commit操作补充</h2><p>docker commit是提交容器副本使之成为一个新的镜像。<br><strong>命令：docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:标签名</strong></p><p><strong>案例演示：</strong><br>1、从Hub上下载tomcat镜像到本地并运行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br><span class="line">docker run -it -p <span class="number">8888</span>:<span class="number">8080</span> --name mytomcat tomcat</span><br></pre></td></tr></table></figure><p>其中：-p：主机端口：docker端口；-i：交互；-t：终端。<br><img src="https://img-blog.csdnimg.cn/2020010622095457.png" alt="在这里插入图片描述"><br>启动成功后再本地访问8888端口就可以访问到那只cat了。<br><img src="https://img-blog.csdnimg.cn/20200106221311754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、故意删除上一步镜像产生tomcat容器的文档使此容器成为我自己的tomcat容器<br><img src="https://img-blog.csdnimg.cn/20200106221603606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3、将删除doc文档的容器作为一个模板提交到仓库<img src="https://img-blog.csdnimg.cn/20200106221628128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样我们就剩成了一个属于自己的镜像文件并提交到了仓库中。</p><h1 id="docker容器数据卷"><a href="#docker容器数据卷" class="headerlink" title="docker容器数据卷"></a>docker容器数据卷</h1><p>先来看看Docker的理念：</p><ul><li>将应用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</li><li>容器之间希望有可能共享数据</li></ul><p>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，<br>那么当容器删除后，数据自然也就没有了。</p><p>为了能保存docker中的数据我们使用卷，有点类似redis中的RDB(Redis database)和AOF(append only file)持久化。</p><p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p><p>特点：<br>1：数据卷可在容器之间共享或重用数据<br>2：卷中的更改可以直接生效<br>3：数据卷中的更改不会包含在镜像的更新中<br>4：数据卷的生命周期一直持续到没有容器使用它为止</p><h2 id="容器内添加数据卷的两种方式"><a href="#容器内添加数据卷的两种方式" class="headerlink" title="容器内添加数据卷的两种方式"></a>容器内添加数据卷的两种方式</h2><h3 id="使用命令添加"><a href="#使用命令添加" class="headerlink" title="使用命令添加"></a>使用命令添加</h3><p><strong>docker run -it -v /宿主机绝对路径目录:/容器内目录 centos /bin/bash</strong><br><img src="https://img-blog.csdnimg.cn/20200106222147346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后在其中一方的目录中进行修改，另一方都可以看到，即实现了数据共享和持久化。<br><img src="https://img-blog.csdnimg.cn/20200106222401460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注：在容器停止退出之后，主机修改数据是否同步？<br>答：在容器重新启动之后依旧会同步。<br><img src="https://img-blog.csdnimg.cn/20200106222508707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>命令中可带权限，如<strong>docker run -it -v /宿主机绝对路径:/容器内目录:ro 镜像名</strong><br>其中：ro代表read only(只读)<br><img src="https://img-blog.csdnimg.cn/20200106222637273.png" alt="在这里插入图片描述"></p><h3 id="使用Docker-File添加"><a href="#使用Docker-File添加" class="headerlink" title="使用Docker File添加"></a>使用Docker File添加</h3><p><strong>步骤：</strong><br><strong>1、根目录下创建/mydocker并进入；</strong><br><strong>2、编写Dockerfile文件；</strong><br>创建Dockerfile文件，并在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷。<br><img src="https://img-blog.csdnimg.cn/20200106223323252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>说明：</strong><br>出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。<br><strong>3、build生成镜像；</strong><br><img src="https://img-blog.csdnimg.cn/20200106223348838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中-f代表file，指定Dockerfile的位置，若不使用-f选项，那么默认的文件是本目录的“Dockerfile”文件。<br>这样就生成了一个新的镜像zzyy/centos。<br><strong>4、run容器</strong><br><img src="https://img-blog.csdnimg.cn/20200106223427321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过上述方法，容器中的卷目录地址已经知道，那么主机中对应的主机目录地址在哪里？<br><img src="https://img-blog.csdnimg.cn/20200106223516621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106223825568.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106223838557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注：</strong><br>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied<br>解决办法：在挂载目录后多加一个–privileged=true参数即可</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为<strong>数据卷容器</strong>。</p><p>以上一步新建的zzyy/centos为模板，创建并运行容器dc01、dc02、dc03，那么他们已经有容器卷/dataVolumeContainer1和/dataVolumeContainer2了。</p><p><strong>容器中的传递共享：</strong></p><p><strong>1、先启动一个父容器dc01，并且在/dataVolumeContainer2内新增内容</strong><br><img src="https://img-blog.csdnimg.cn/2020010622420771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2、dc02和dc03继承自dc01，并且dc02和dc03也在/dataVolumeContainer2新增内容。</strong><br><img src="https://img-blog.csdnimg.cn/20200106224333497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3、回到dc01可以看到02和03各自添加的内容了，证明数据可以共享。</strong></p><p><strong>问题1：删除dc01，并修改dc02之后dc03可否看到？</strong><br>答：可以！<br><img src="https://img-blog.csdnimg.cn/20200106224617612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>问题2：删除dc02后dc03可否访问？</strong><br><img src="https://img-blog.csdnimg.cn/20200106224919738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106224942109.png" alt="在这里插入图片描述"><br><strong>结论：<br>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。</strong></p><h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>Dockerfile是用来构建docker镜像的构建文件，是有一系列命令和参数构成的脚本。</p><p>构建的步骤：<br>1、编写Dockerfile文件；<br>2、docker build；<br>3、docker run。</p><h2 id="Dockerfile构建过程解析"><a href="#Dockerfile构建过程解析" class="headerlink" title="Dockerfile构建过程解析"></a>Dockerfile构建过程解析</h2><h3 id="Dockerfile内容基础知识："><a href="#Dockerfile内容基础知识：" class="headerlink" title="Dockerfile内容基础知识："></a>Dockerfile内容基础知识：</h3><p><img src="https://img-blog.csdnimg.cn/20200107110856372.png" alt="1、"></p><h3 id="docker执行Dockerfile的大致流程"><a href="#docker执行Dockerfile的大致流程" class="headerlink" title="docker执行Dockerfile的大致流程"></a>docker执行Dockerfile的大致流程</h3><p><img src="https://img-blog.csdnimg.cn/20200107111108848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p><ul><li>Dockerfile是软件的原材料</li><li>Docker镜像是软件的交付品</li><li>Docker容器则可以认为是软件的运行态。<br>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。<br><img src="https://img-blog.csdnimg.cn/20200107111238124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</li></ul><p>2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</p><p>3 Docker容器，容器是直接提供服务的。</p><h2 id="Dockerfile的体系结构（保留字指令）"><a href="#Dockerfile的体系结构（保留字指令）" class="headerlink" title="Dockerfile的体系结构（保留字指令）"></a>Dockerfile的体系结构（保留字指令）<img src="https://img-blog.csdnimg.cn/20200107111508611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><p><strong>CMD和ENTRYPOINT镜像案例</strong>：<br>两者都是指定容器启东市要运行的命令。<br>1、Dockerfile中可以有多个CMD命令，但是只有最后一个生效，CMD会被docker run之后的参数替换掉，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p <span class="number">8888</span>:<span class="number">8080</span> tomcat /bash/shell</span><br></pre></td></tr></table></figure><p>2、而ENTRYPOINT会将docker run之后的参数追加到ENTRYPOINT后面。比如若在Dockerfile中是：<code>ENTRYPOINT [ &quot;ls&quot;, &quot;-l&quot; ]</code>，运行指令是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p <span class="number">8888</span>:<span class="number">8080</span> tomcat -a</span><br></pre></td></tr></table></figure><p>那么最后的ENTRYPOINT运行结果为ENTRYPOINT [ “ls”, “-l”,”-a” ]即进行追加。</p><p><strong>ONBUILD指令案例</strong>：<br><img src="https://img-blog.csdnimg.cn/20200107111700649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="案例：自定义tomcat镜像"><a href="#案例：自定义tomcat镜像" class="headerlink" title="案例：自定义tomcat镜像"></a>案例：自定义tomcat镜像</h2><p>Docker Hub中99%的镜像都是通过base镜像（scratch）中安装和配置需要的软件构建出来的。如：<br><img src="https://img-blog.csdnimg.cn/20200107111849313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>1、创建目录</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydocker/dockerfile/tomcat9</span><br></pre></td></tr></table></figure><p><strong>2、在上述目录下 touch c.txt<br>3、将jdk和tomcat安装的压缩包靠近上一步的目录中</strong><br><img src="https://img-blog.csdnimg.cn/20200107113222243.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020010711323214.png" alt="在这里插入图片描述"><br><strong>4、在上一步目录中新建Dockerfile文件</strong>，内容为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM         centos</span><br><span class="line">MAINTAINER    xyy&lt;<span class="number">1274268227</span>@qq.com&gt;</span><br><span class="line">#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下</span><br><span class="line">COPY c.txt /usr/local/cincontainer.txt</span><br><span class="line">#把java与tomcat添加到容器中</span><br><span class="line">ADD jdk<span class="number">-8u</span>171-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat<span class="number">-9.0</span><span class="number">.8</span>.tar.gz /usr/local/</span><br><span class="line">#安装vim编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#设置工作访问时候的WORKDIR路径，登录落脚点</span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">#配置java与tomcat环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1<span class="number">.8</span><span class="number">.0</span>_171</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span></span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span></span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line">#容器运行时监听的端口</span><br><span class="line">EXPOSE  <span class="number">8080</span></span><br><span class="line">#启动时运行tomcat</span><br><span class="line"># ENTRYPOINT [<span class="string">"/usr/local/apache-tomcat-9.0.8/bin/startup.sh"</span> ]</span><br><span class="line"># CMD [<span class="string">"/usr/local/apache-tomcat-9.0.8/bin/catalina.sh"</span>,<span class="string">"run"</span>]</span><br><span class="line">CMD /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span>/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span>/bin/logs/catalina.out</span><br></pre></td></tr></table></figure><p>5、docker build构建镜像文件<br>6、docker run创建并运行容器<br>7、访问本地端口，查看能否访问到那只猫</p><h2 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h2><p><img src="https://img-blog.csdnimg.cn/20200107113609376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;docker镜像&quot;&gt;&lt;a href=&quot;#docker镜像&quot; class=&quot;headerlink&quot; title=&quot;docker镜像&quot;&gt;&lt;/a&gt;docker镜像&lt;/h1&gt;&lt;p&gt;镜像是一种轻量级、可执行的独立软件包，&lt;strong&gt;用来打包软件运行环境和基于运行环境开发的软件&lt;/strong&gt;，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="https://youngyang.top/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://youngyang.top/tags/Docker/"/>
    
  </entry>
  
</feed>
