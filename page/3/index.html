<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Yang's Blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="Record what you want!">
<meta property="og:type" content="website">
<meta property="og:title" content="Yang&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;youngyang.top&#x2F;page&#x2F;3&#x2F;index.html">
<meta property="og:site_name" content="Yang&#39;s Blog">
<meta property="og:description" content="Record what you want!">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://youngyang.top/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Yang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">40</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youngyang.top/2020/07/04/springboot%E7%9A%84MVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="youngyang">
      <meta itemprop="description" content="Record what you want!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/springboot%E7%9A%84MVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">springboot的MVC自动配置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-04 20:11:14 / 修改时间：20:08:10" itemprop="dateCreated datePublished" datetime="2020-07-04T20:11:14+08:00">2020-07-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>@[TOC]<br>springboot为我们提供了springmvc的自动配置，所以我们可以直接编写逻辑就能实现功能。（如下内容都是基于springboot2.2.5）</p>
<p>比如万能的helloworld：<br><img src="https://img-blog.csdnimg.cn/20200315153747721.png" alt="在这里插入图片描述"><br>我们只要写一个controller就能自动映射到。</p>
<p>访问localhost:8080/hello，如下<br><img src="https://img-blog.csdnimg.cn/20200315153841850.png" alt="在这里插入图片描述"><br>那么springboot是如何帮助我们自动配置的呢？</p>
<h1 id="springboot对mvc的自动配置"><a href="#springboot对mvc的自动配置" class="headerlink" title="springboot对mvc的自动配置"></a>springboot对mvc的自动配置</h1><p>对于springmvc的自动配置全部在WebMvcAutoConfiguration.class类中。</p>
<p>ctrl+n搜索类，进入：<br><img src="https://img-blog.csdnimg.cn/20200315154044100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="对静态资源的自动配置"><a href="#对静态资源的自动配置" class="headerlink" title="对静态资源的自动配置"></a>对静态资源的自动配置</h2><p>看到如下关键方法：<br><img src="https://img-blog.csdnimg.cn/20200315154425747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="webjars"><a href="#webjars" class="headerlink" title="webjars"></a>webjars</h3><p>首先webjars是什么呢？<br>看官网的描述：<br><img src="https://img-blog.csdnimg.cn/20200315155118221.png" alt="在这里插入图片描述"><br>其实说白了，就是讲静态资源通过jar包的方式导入进来。</p>
<p>那么我们看看springboot是如何配置webjars的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">	customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">				.addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">				.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
<p>关于webjars，会自动帮我们添加一个映射。对于/webjars/**这样的资源回去类路径下的？META-INF/resources/webjars/路径下面去找。<br><img src="https://img-blog.csdnimg.cn/20200315154828716.png" alt="在这里插入图片描述">并且可以设置缓存时间，而缓存时间是从ResourceProperties下面去找的。<br><img src="https://img-blog.csdnimg.cn/20200315154919727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>关于ResourcesProperties我们可以从配置文件的spring.resources前缀的属性注入进来。</p>
<p>这样在浏览器访问localhost:8080/webjars/<strong>这个路径就会通过根路径的respurces/webjars/</strong>这个路径来寻找。<br>比如：我们导入jquery的一个jar包：<br><img src="https://img-blog.csdnimg.cn/20200315155351961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>只要导入进来，我们就可以通过访问localhost:8080/webjars/jquery/3.3.1/jquery.js来访问了，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200315155507640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="静态资源的位置配置"><a href="#静态资源的位置配置" class="headerlink" title="静态资源的位置配置"></a>静态资源的位置配置</h3><p>那么我们编写的静态资源应该放到哪里才可以被访问到呢，比如下面的ilogin.html<br><img src="https://img-blog.csdnimg.cn/2020031515565130.png" alt="在这里插入图片描述"></p>
<p>再来看springboot的自动配置：<br><img src="https://img-blog.csdnimg.cn/20200315155749234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那我们点进去看一下这是给我们配置到哪里去了呢？<br><img src="https://img-blog.csdnimg.cn/2020031515582611.png" alt="在这里插入图片描述"><br>经过一路跟踪，终于找到，springboot为我们自动配置的静态资源位置是如下几个：classpath:/MATA-INF/resources/、classpath:/resources/、classpath:/public/、classpath:/static/这几个位置，无论我们把静态资源放到这几个的哪一个都可以访问到：<br><img src="https://img-blog.csdnimg.cn/20200315160111167.png" alt="在这里插入图片描述"><br>通过测试abcd四个html都能被访问到。</p>
<h2 id="欢迎页的配置"><a href="#欢迎页的配置" class="headerlink" title="欢迎页的配置"></a>欢迎页的配置</h2><p>对于欢迎页的配置，springboot又是如何自动配置的呢？<br>还是进入WebMvcAutoConfiguration.class这个类：<br><img src="https://img-blog.csdnimg.cn/2020031516032831.png" alt="在这里插入图片描述"><br>进入这个构造方法里边，<br><img src="https://img-blog.csdnimg.cn/20200315160407460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200315160433808.png" alt="在这里插入图片描述"><br>观察这个类的注释：支持静态资源和模板文件，但是更喜欢静态资源。</p>
<p>也就是我们无论是吧index.html页面放到静态资源文件夹下，还是放在templates文件夹下都可以被访问到，但是如果两个路径下都包括index.html，那么优先加载静态资源下的index。</p>
<h2 id="全面接管springmvc"><a href="#全面接管springmvc" class="headerlink" title="全面接管springmvc"></a>全面接管springmvc</h2><p>如何全面接管springmvc呢，我们只要在一个组件上面加上@EnableWebMvc注解就行。</p>
<p>这样springboot为我们做的mvc自动配置全部都会失效，只会保留最初始的功能。<br>如下所示：<br><img src="https://img-blog.csdnimg.cn/20200315162509225.png" alt="在这里插入图片描述"><br>这样如果我们在访问webjars，比如：<a href="http://localhost:8080/webjars/jquery/3.3.1/jquery.js" target="_blank" rel="noopener">http://localhost:8080/webjars/jquery/3.3.1/jquery.js</a><br><img src="https://img-blog.csdnimg.cn/20200315162554334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>就不能访问到了。</p>
<p>为什么只要添加一个注解就不能访问到了呢？<br>可以进这个注解看一下：<br><img src="https://img-blog.csdnimg.cn/20200315162639603.png" alt="在这里插入图片描述"><br>这个注解很简单，就是向容器中导入了一个组件，那我们点进去看一下：<br><img src="https://img-blog.csdnimg.cn/20200315162724412.png" alt="在这里插入图片描述"><br>我们可以看到这个类继承了WrbConfigurationSupport这个类，再看看mvc的自动配置类：<br><img src="https://img-blog.csdnimg.cn/20200315162840580.png" alt="在这里插入图片描述"><br>mvc的自动配置类会判断在没有这个组件的情况下，才会生效</p>
<p>也就是说我们使用了这个@EnableWebMvc注解，就会使springboot自动配置的mvc失效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youngyang.top/2020/07/04/docke%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E4%B9%8B%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="youngyang">
      <meta itemprop="description" content="Record what you want!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/docke%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E4%B9%8B%E4%BA%8C/" class="post-title-link" itemprop="url">docke学习内容之二</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-04 20:10:15 / 修改时间：20:08:10" itemprop="dateCreated datePublished" datetime="2020-07-04T20:10:15+08:00">2020-07-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.1k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="docker镜像"><a href="#docker镜像" class="headerlink" title="docker镜像"></a>docker镜像</h1><p>镜像是一种轻量级、可执行的独立软件包，<strong>用来打包软件运行环境和基于运行环境开发的软件</strong>，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h2 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h2><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<h2 id="docker镜像加载原理"><a href="#docker镜像加载原理" class="headerlink" title="docker镜像加载原理"></a>docker镜像加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统是UnionFS。</p>
<p>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel， Linux刚启动时会加载bootfs文件系统，<strong>在Docker镜像的最底层是bootfs</strong>。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。<br><img src="https://img-blog.csdnimg.cn/202001062159462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？</strong><br><img src="https://img-blog.csdnimg.cn/20200106220000303.png" alt="在这里插入图片描述"><br>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。</p>
<h2 id="分层的镜像"><a href="#分层的镜像" class="headerlink" title="分层的镜像"></a>分层的镜像</h2><p>以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载。<br><img src="https://img-blog.csdnimg.cn/2020010622011221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>为什么docker镜像要采用这种分层的结构呢？</strong><br>最大的一个好处就是 - <strong>共享资源</strong>。<br>比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，<br>同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h2 id="镜像的特点"><a href="#镜像的特点" class="headerlink" title="镜像的特点"></a>镜像的特点</h2><p>docker镜像都是只读的。<br>当容器启动时，一个新的可写层被加载到镜像的顶部。<br>这一层通常称做“容器层”，“容器层”之下的都叫“镜像层”。</p>
<h2 id="docker镜像commit操作补充"><a href="#docker镜像commit操作补充" class="headerlink" title="docker镜像commit操作补充"></a>docker镜像commit操作补充</h2><p>docker commit是提交容器副本使之成为一个新的镜像。<br><strong>命令：docker commit -m=“提交的描述信息” -a=“作者” 容器ID 要创建的目标镜像名:标签名</strong></p>
<p><strong>案例演示：</strong><br>1、从Hub上下载tomcat镜像到本地并运行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br><span class="line">docker run -it -p <span class="number">8888</span>:<span class="number">8080</span> --name mytomcat tomcat</span><br></pre></td></tr></table></figure>
<p>其中：-p：主机端口：docker端口；-i：交互；-t：终端。<br><img src="https://img-blog.csdnimg.cn/2020010622095457.png" alt="在这里插入图片描述"><br>启动成功后再本地访问8888端口就可以访问到那只cat了。<br><img src="https://img-blog.csdnimg.cn/20200106221311754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、故意删除上一步镜像产生tomcat容器的文档使此容器成为我自己的tomcat容器<br><img src="https://img-blog.csdnimg.cn/20200106221603606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3、将删除doc文档的容器作为一个模板提交到仓库<img src="https://img-blog.csdnimg.cn/20200106221628128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样我们就剩成了一个属于自己的镜像文件并提交到了仓库中。</p>
<h1 id="docker容器数据卷"><a href="#docker容器数据卷" class="headerlink" title="docker容器数据卷"></a>docker容器数据卷</h1><p>先来看看Docker的理念：</p>
<ul>
<li>将应用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</li>
<li>容器之间希望有可能共享数据</li>
</ul>
<p>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，<br>那么当容器删除后，数据自然也就没有了。</p>
<p>为了能保存docker中的数据我们使用卷，有点类似redis中的RDB(Redis database)和AOF(append only file)持久化。</p>
<p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p>
<p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p>
<p>特点：<br>1：数据卷可在容器之间共享或重用数据<br>2：卷中的更改可以直接生效<br>3：数据卷中的更改不会包含在镜像的更新中<br>4：数据卷的生命周期一直持续到没有容器使用它为止</p>
<h2 id="容器内添加数据卷的两种方式"><a href="#容器内添加数据卷的两种方式" class="headerlink" title="容器内添加数据卷的两种方式"></a>容器内添加数据卷的两种方式</h2><h3 id="使用命令添加"><a href="#使用命令添加" class="headerlink" title="使用命令添加"></a>使用命令添加</h3><p><strong>docker run -it -v /宿主机绝对路径目录:/容器内目录 centos /bin/bash</strong><br><img src="https://img-blog.csdnimg.cn/20200106222147346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后在其中一方的目录中进行修改，另一方都可以看到，即实现了数据共享和持久化。<br><img src="https://img-blog.csdnimg.cn/20200106222401460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注：在容器停止退出之后，主机修改数据是否同步？<br>答：在容器重新启动之后依旧会同步。<br><img src="https://img-blog.csdnimg.cn/20200106222508707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>命令中可带权限，如<strong>docker run -it -v /宿主机绝对路径:/容器内目录:ro 镜像名</strong><br>其中：ro代表read only(只读)<br><img src="https://img-blog.csdnimg.cn/20200106222637273.png" alt="在这里插入图片描述"></p>
<h3 id="使用Docker-File添加"><a href="#使用Docker-File添加" class="headerlink" title="使用Docker File添加"></a>使用Docker File添加</h3><p><strong>步骤：</strong><br><strong>1、根目录下创建/mydocker并进入；</strong><br><strong>2、编写Dockerfile文件；</strong><br>创建Dockerfile文件，并在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷。<br><img src="https://img-blog.csdnimg.cn/20200106223323252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>说明：</strong><br>出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。<br><strong>3、build生成镜像；</strong><br><img src="https://img-blog.csdnimg.cn/20200106223348838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中-f代表file，指定Dockerfile的位置，若不使用-f选项，那么默认的文件是本目录的“Dockerfile”文件。<br>这样就生成了一个新的镜像zzyy/centos。<br><strong>4、run容器</strong><br><img src="https://img-blog.csdnimg.cn/20200106223427321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过上述方法，容器中的卷目录地址已经知道，那么主机中对应的主机目录地址在哪里？<br><img src="https://img-blog.csdnimg.cn/20200106223516621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106223825568.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106223838557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>注：</strong><br>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied<br>解决办法：在挂载目录后多加一个–privileged=true参数即可</p>
<h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，挂载数据卷的容器，称之为<strong>数据卷容器</strong>。</p>
<p>以上一步新建的zzyy/centos为模板，创建并运行容器dc01、dc02、dc03，那么他们已经有容器卷/dataVolumeContainer1和/dataVolumeContainer2了。</p>
<p><strong>容器中的传递共享：</strong></p>
<p><strong>1、先启动一个父容器dc01，并且在/dataVolumeContainer2内新增内容</strong><br><img src="https://img-blog.csdnimg.cn/2020010622420771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2、dc02和dc03继承自dc01，并且dc02和dc03也在/dataVolumeContainer2新增内容。</strong><br><img src="https://img-blog.csdnimg.cn/20200106224333497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>3、回到dc01可以看到02和03各自添加的内容了，证明数据可以共享。</strong></p>
<p><strong>问题1：删除dc01，并修改dc02之后dc03可否看到？</strong><br>答：可以！<br><img src="https://img-blog.csdnimg.cn/20200106224617612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>问题2：删除dc02后dc03可否访问？</strong><br><img src="https://img-blog.csdnimg.cn/20200106224919738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106224942109.png" alt="在这里插入图片描述"><br><strong>结论：<br>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。</strong></p>
<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>Dockerfile是用来构建docker镜像的构建文件，是有一系列命令和参数构成的脚本。</p>
<p>构建的步骤：<br>1、编写Dockerfile文件；<br>2、docker build；<br>3、docker run。</p>
<h2 id="Dockerfile构建过程解析"><a href="#Dockerfile构建过程解析" class="headerlink" title="Dockerfile构建过程解析"></a>Dockerfile构建过程解析</h2><h3 id="Dockerfile内容基础知识："><a href="#Dockerfile内容基础知识：" class="headerlink" title="Dockerfile内容基础知识："></a>Dockerfile内容基础知识：</h3><p><img src="https://img-blog.csdnimg.cn/20200107110856372.png" alt="1、"></p>
<h3 id="docker执行Dockerfile的大致流程"><a href="#docker执行Dockerfile的大致流程" class="headerlink" title="docker执行Dockerfile的大致流程"></a>docker执行Dockerfile的大致流程</h3><p><img src="https://img-blog.csdnimg.cn/20200107111108848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段，</p>
<ul>
<li>Dockerfile是软件的原材料</li>
<li>Docker镜像是软件的交付品</li>
<li>Docker容器则可以认为是软件的运行态。<br>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。<br><img src="https://img-blog.csdnimg.cn/20200107111238124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1 Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等;</li>
</ul>
<p>2 Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务;</p>
<p>3 Docker容器，容器是直接提供服务的。</p>
<h2 id="Dockerfile的体系结构（保留字指令）"><a href="#Dockerfile的体系结构（保留字指令）" class="headerlink" title="Dockerfile的体系结构（保留字指令）"></a>Dockerfile的体系结构（保留字指令）<img src="https://img-blog.csdnimg.cn/20200107111508611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h2><p><strong>CMD和ENTRYPOINT镜像案例</strong>：<br>两者都是指定容器启东市要运行的命令。<br>1、Dockerfile中可以有多个CMD命令，但是只有最后一个生效，CMD会被docker run之后的参数替换掉，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p <span class="number">8888</span>:<span class="number">8080</span> tomcat /bash/shell</span><br></pre></td></tr></table></figure>
<p>2、而ENTRYPOINT会将docker run之后的参数追加到ENTRYPOINT后面。比如若在Dockerfile中是：<code>ENTRYPOINT [ &quot;ls&quot;, &quot;-l&quot; ]</code>，运行指令是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p <span class="number">8888</span>:<span class="number">8080</span> tomcat -a</span><br></pre></td></tr></table></figure>
<p>那么最后的ENTRYPOINT运行结果为ENTRYPOINT [ “ls”, “-l”,”-a” ]即进行追加。</p>
<p><strong>ONBUILD指令案例</strong>：<br><img src="https://img-blog.csdnimg.cn/20200107111700649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="案例：自定义tomcat镜像"><a href="#案例：自定义tomcat镜像" class="headerlink" title="案例：自定义tomcat镜像"></a>案例：自定义tomcat镜像</h2><p>Docker Hub中99%的镜像都是通过base镜像（scratch）中安装和配置需要的软件构建出来的。如：<br><img src="https://img-blog.csdnimg.cn/20200107111849313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>1、创建目录</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydocker/dockerfile/tomcat9</span><br></pre></td></tr></table></figure>
<p><strong>2、在上述目录下 touch c.txt<br>3、将jdk和tomcat安装的压缩包靠近上一步的目录中</strong><br><img src="https://img-blog.csdnimg.cn/20200107113222243.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020010711323214.png" alt="在这里插入图片描述"><br><strong>4、在上一步目录中新建Dockerfile文件</strong>，内容为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM         centos</span><br><span class="line">MAINTAINER    xyy&lt;<span class="number">1274268227</span>@qq.com&gt;</span><br><span class="line">#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下</span><br><span class="line">COPY c.txt /usr/local/cincontainer.txt</span><br><span class="line">#把java与tomcat添加到容器中</span><br><span class="line">ADD jdk<span class="number">-8u</span>171-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat<span class="number">-9.0</span><span class="number">.8</span>.tar.gz /usr/local/</span><br><span class="line">#安装vim编辑器</span><br><span class="line">RUN yum -y install vim</span><br><span class="line">#设置工作访问时候的WORKDIR路径，登录落脚点</span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line">#配置java与tomcat环境变量</span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1<span class="number">.8</span><span class="number">.0</span>_171</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span></span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span></span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin</span><br><span class="line">#容器运行时监听的端口</span><br><span class="line">EXPOSE  <span class="number">8080</span></span><br><span class="line">#启动时运行tomcat</span><br><span class="line"># ENTRYPOINT [<span class="string">"/usr/local/apache-tomcat-9.0.8/bin/startup.sh"</span> ]</span><br><span class="line"># CMD [<span class="string">"/usr/local/apache-tomcat-9.0.8/bin/catalina.sh"</span>,<span class="string">"run"</span>]</span><br><span class="line">CMD /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span>/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat<span class="number">-9.0</span><span class="number">.8</span>/bin/logs/catalina.out</span><br></pre></td></tr></table></figure>
<p>5、docker build构建镜像文件<br>6、docker run创建并运行容器<br>7、访问本地端口，查看能否访问到那只猫</p>
<h2 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h2><p><img src="https://img-blog.csdnimg.cn/20200107113609376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youngyang.top/2020/07/04/docker%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E4%B9%8B%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="youngyang">
      <meta itemprop="description" content="Record what you want!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/docker%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E4%B9%8B%E4%B8%80/" class="post-title-link" itemprop="url">docker学习内容之一</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-04 20:10:15 / 修改时间：20:08:10" itemprop="dateCreated datePublished" datetime="2020-07-04T20:10:15+08:00">2020-07-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="docker简介"><a href="#docker简介" class="headerlink" title="docker简介"></a>docker简介</h1><h2 id="为什么会有docker出现"><a href="#为什么会有docker出现" class="headerlink" title="为什么会有docker出现"></a>为什么会有docker出现</h2><p>一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验。</p>
<p>Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案。</p>
<p>环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，<strong>软件可以带环境安装？</strong>也就是说，<strong>安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题</strong>。<br><img src="https://img-blog.csdnimg.cn/2020010619251885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之前在服务器配置一个应用的运行环境，要安装各种软件，就拿我做过的的电商项目的环境来说吧，Java/Tomcat/MySQL/JDBC驱动包等。安装和配置这些东西有多麻烦就不说了，它还不能跨平台。假如我们是在 Windows 上安装的这些环境，到了 Linux 又得重新装。况且就算不跨操作系统，换另一台同样操作系统的服务器，要移植应用也是非常麻烦的。</p>
<p>传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，<strong>开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker镜像的设计，使得Docker得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。</strong></p>
<h2 id="关于docker"><a href="#关于docker" class="headerlink" title="关于docker"></a>关于docker</h2><p>Docker是基于Go语言实现的云开源项目。</p>
<p>Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到<strong>“一次封装，到处运行</strong>”。<br><img src="https://img-blog.csdnimg.cn/20200106192641662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Linux 容器技术的出现就解决了这样一个问题，而 Docker 就是在它的基础上发展过来的。将应用运行在 Docker 容器上面，而 Docker 容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。<strong>只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作。</strong></p>
<h2 id="容器虚拟化技术与虚拟机技术"><a href="#容器虚拟化技术与虚拟机技术" class="headerlink" title="容器虚拟化技术与虚拟机技术"></a>容器虚拟化技术与虚拟机技术</h2><h3 id="虚拟机技术"><a href="#虚拟机技术" class="headerlink" title="虚拟机技术"></a>虚拟机技术</h3><p>虚拟机（virtual machine）就是带环境安装的一种解决方案。<br>它可以在一种操作系统里面运行另一种操作系统，比如在Windows 系统里面运行Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。这类虚拟机完美的运行了另一套系统，能够使应用程序，操作系统和硬件三者之间的逻辑不变。<br><img src="https://img-blog.csdnimg.cn/20200106192853747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>虚拟机的缺点：</strong><br>        1    资源占用多               2    冗余步骤多                 3    启动慢</p>
<h3 id="容器虚拟化技术"><a href="#容器虚拟化技术" class="headerlink" title="容器虚拟化技术"></a>容器虚拟化技术</h3><p>由于前面虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p>
<p><strong>Linux 容器不是模拟一个完整的操作系统</strong>，而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。<br><img src="https://img-blog.csdnimg.cn/20200106193143427.png" alt="在这里插入图片描述"><br><strong>比较了 Docker 和传统虚拟化方式的不同之处：</strong><br>1、传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；<br>2、而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。<br>3、每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p>
<h3 id="为什么docker比虚拟机快"><a href="#为什么docker比虚拟机快" class="headerlink" title="为什么docker比虚拟机快"></a>为什么docker比虚拟机快</h3><p>(1)docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>(2)docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。<br><img src="https://img-blog.csdnimg.cn/202001062029425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106202953816.png" alt="在这里插入图片描述"></p>
<h2 id="docker的优势"><a href="#docker的优势" class="headerlink" title="docker的优势"></a>docker的优势</h2><p><strong>1、更快速的应用交付和部署</strong><br>传统的应用开发完成后，需要提供一堆安装程序和配置说明文档，安装部署后需根据配置文档进行繁杂的配置才能正常运行。Docker化之后只需要交付少量容器镜像文件，在正式生产环境加载镜像并运行即可，应用安装配置在镜像里已经内置好，大大节省部署配置和测试验证时间。<br><strong>2、更便捷的升级和扩缩容</strong><br>随着微服务架构和Docker的发展，大量的应用会通过微服务方式架构，应用的开发构建将变成搭乐高积木一样，每个Docker容器将变成一块“积木”，应用的升级将变得非常容易。当现有的容器不足以支撑业务处理时，可通过镜像运行新的容器进行快速扩容，使应用系统的扩容从原先的天级变成分钟级甚至秒级。<br><strong>3、更简单的系统运维</strong><br>应用容器化运行后，生产环境运行的应用可与开发、测试环境的应用高度一致，容器会将应用程序相关的环境和状态完全封装起来，不会因为底层基础架构和操作系统的不一致性给应用带来影响，产生新的BUG。当出现程序异常时，也可以通过测试环境的相同容器进行快速定位和修复。<br><strong>4、更高效的计算资源利用</strong><br>Docker是内核级虚拟化，其不像传统的虚拟化技术一样需要额外的Hypervisor支持，所以在一台物理机上可以运行很多个容器实例，可大大提升物理服务器的CPU和内存的利用率。</p>
<h2 id="docker的三大基本组成"><a href="#docker的三大基本组成" class="headerlink" title="docker的三大基本组成"></a>docker的三大基本组成</h2><p>docker的整体架构图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200106195139668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>1、镜像（image）</strong>：Docker 镜像（Image）就是一个<strong>只读</strong>的模板。镜像可以用来创建 Docker 容器，<strong>一个镜像可以创建很多容器</strong>。（镜像和容器我觉得和java中的类和对象相似，类就是创建对象的模板，并且一个类可以创建多个对象。）<br><strong>2、容器（container）</strong>：Docker 利用容器（Container）独立运行的一个或一组应用。<strong>容器是用镜像创建的运行实例。</strong></p>
<p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p>
<p><strong>可以把容器看做是一个简易版的 Linux 环境</strong>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。<br><strong>3、仓库（repository）</strong>：仓库（Repository）是集中存放镜像文件的场所。</p>
<p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云" target="_blank" rel="noopener">https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云</a> 、网易云 等。</p>
<p><strong>总结：</strong><br>我们需要正确的理解仓储/镜像/容器这几个概念。Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器。至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。</p>
<h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>Docker支持以下的CentOS版本：CentOS 7 (64-bit)，CentOS 6.5 (64-bit) 或更高的版本。</p>
<p>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</p>
<p><strong>如何查看自己的内核：</strong><br>uname命令用于打印当前系统相关信息（内核版本号、硬件架构、主机名称和操作系统类型等）。<br><img src="https://img-blog.csdnimg.cn/20200106194238941.png" alt="在这里插入图片描述"><br><strong>查看已安装的CentOS版本信息（CentOS6.8有，CentOS7无该命令）：</strong><br><img src="https://img-blog.csdnimg.cn/20200106194327871.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200106194330561.png" alt="在这里插入图片描述"></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>可以去docker的官网下载安装包：<a href="http://www.docker.com" target="_blank" rel="noopener">http://www.docker.com</a><br>docker的仓库：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>centos 6和centos 7的安装步骤略有不同，我是centos 7.3，所以是centos 7的安装教程。<br>1、安装gcc</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br></pre></td></tr></table></figure>
<p>2、如果原来安装过docker，需要卸载掉旧版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove docker docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure>
<p>3、安装需要的软件包</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
<p>4、设置stable镜像仓库</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http:<span class="comment">//mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br></pre></td></tr></table></figure>
<p>5、更新yum软件包索引</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>
<p>6、安装DOCKER CE</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install docker-ce</span><br></pre></td></tr></table></figure>
<p>7、启动docker</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<p>8、测试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<p>9、去阿里云配置镜像加速<br>阿里云官网的容器镜像服务栏中找到镜像加速器，根据提示设置即可：<br><img src="https://img-blog.csdnimg.cn/20200106202449834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>10、卸载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syatemctl stop docker</span><br><span class="line">yum -y remove docker-ce</span><br><span class="line">rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
<h1 id="docker的常用命令"><a href="#docker的常用命令" class="headerlink" title="docker的常用命令"></a>docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">docker info</span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>1、docker images</strong>：列出本地主机上的镜像。<br><img src="https://img-blog.csdnimg.cn/20200106210229594.png" alt="在这里插入图片描述"><br>上图中各个选项说明:<br>REPOSITORY：表示镜像的仓库源<br>TAG：镜像的标签<br>IMAGE ID：镜像ID<br>CREATED：镜像创建时间<br>SIZE：镜像大小<br> 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。<br> 选项说明：<br> -a：列出本地所有的镜像（含中间映像层）；<br> -q：只显示镜像ID；<br> –digests：显示镜像的摘要信息<br> –no-trunc：显示完整的镜像信息<br> <strong>2、docker search 镜像名字</strong>：从dockerHub上查找响应的镜像。<br>  <strong>3、docker pull 镜像名字:TAG</strong>：下载镜像，若不指定TAG标签，则默认下载latest镜像。<br>  <strong>4、docker rmi 镜像名字id</strong>：删除镜像<br>  删除单个：docker rmi -f 镜像ID；<br>  删除多个：docker rmi -f 镜像名1:TAG1 镜像名2:TAG2；<br>  删除全部：docker rmi -f $(docker images -qa)；</p>
<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>有镜像才能生成容器实例，首先先从镜像仓库pull镜像文件，如：docker pull centos。<br><strong>1、新建并启动容器:docker run [options] image [commends]</strong></p>
<p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号<br>–name=”容器新名字”: 为容器指定一个名称；<br>-d: 后台运行容器，并返回容器ID，也即启动守护式容器；<br><strong>-i：以交互模式运行容器，通常与 -t 同时使用；<br>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；</strong><br>-P: 随机端口映射；<br>-p: 指定端口映射，有以下四种格式<br>      ip:hostPort:containerPort<br>      ip::containerPort<br>      <strong>hostPort:containerPort</strong><br>      containerPort</p>
<p><strong>启动交互式容器：</strong><br>使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。<br>docker run -it centos /bin/bash <img src="https://img-blog.csdnimg.cn/20200106212545439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>2、列出当前所有正在运行的容器：docker ps [options]</strong></p>
<p>OPTIONS说明（常用）：<br>-a :列出当前所有正在运行的容器+历史上运行过的<br>-l :显示最近创建的容器。<br>-n：显示最近n个创建的容器。<br>-q :静默模式，只显示容器编号。<br>–no-trunc :不截断输出。<br><strong>3、退出容器</strong><br>退出容器有两种方式：<br>1、exit：容器停止并退出。<br>2、ctrl+Q+P：容器不停止退出<br><strong>4、启动容器：docker start 容器ID或者容器名<br>5、重启容器：docker restart 容器ID或者容器名<br>6、停止容器：docker stop 容器ID或者容器名<br>7、强制停止容器：docker kill 容器ID或者容器名<br>8、删除已停止的容器：docker rm 容器ID</strong><br>一次性删除多个容器：docker rm -f $(docker ps -qa)</p>
<p><strong>重要命令总结：</strong><br><strong>1、启动守护式容器：docker run -d 容器名</strong></p>
<p>使用镜像centos:latest以后台模式启动一个容器<br>docker run -d centos<br>问题：然后docker ps -a 进行查看, 会发现容器已经退出<br>很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.<br>容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。</p>
<p>这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如<br>service nginx start<br>但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,<br>这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.<br>所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行。<br><strong>2、查看容器日志：docker logs -f -t -tail容器ID</strong><br>其中：</p>
<ul>
<li>-t 是加入时间戳</li>
<li>-f 跟随最新的日志打印</li>
<li>–tail 数字 显示最后多少条</li>
<li>如：首先启动守护式容器：docker run -d centos /bin/sh -c “while true;do echo hello zzyy;sleep 2;done”<br><img src="https://img-blog.csdnimg.cn/20200106213545344.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200106213622451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><em>3、查看容器内运行的进程：docker top 容器ID<br>4、查看容器内部细节：docker inspect 容器ID<br>5、进入正在运行的容器并以命令行交互：*</em><br>1、docker exec -it 容器ID basnshell<br><img src="https://img-blog.csdnimg.cn/20200106213846640.png" alt="在这里插入图片描述"><br>2、重新进入：docker attach 容器ID<br>上述两种方式的区别：<br>attach直接进入容器启动命令的终端，不会启动新的进程；<br>exec是在容器中打开新的终端，并且可以启动新的进程。</li>
<li><em>6、从容器内拷贝文件到主机上：docker cp 容器ID:容器内路径 目的主机路径*</em></li>
</ul>
<p><strong>总结：</strong><br><img src="https://img-blog.csdnimg.cn/20200106214131826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>attach    Attach to a running container                 # 当前 shell 下 attach 连接指定运行镜像<br>build     Build an image from a Dockerfile              # 通过 Dockerfile 定制镜像<br>commit    Create a new image from a container changes   # 提交当前容器为新的镜像<br>cp        Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中<br>create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器<br>diff      Inspect changes on a container’s filesystem   # 查看 docker 容器变化<br>events    Get real time events from the server          # 从 docker 服务获取容器实时事件<br>exec      Run a command in an existing container        # 在已存在的容器上运行命令<br>export    Stream the contents of a container as a tar archive   # 导出容器的内容流作为一个 tar 归档文件[对应 import ]<br>history   Show the history of an image                  # 展示一个镜像形成历史<br>images    List images                                   # 列出系统当前镜像<br>import    Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]<br>info      Display system-wide information               # 显示系统相关信息<br>inspect   Return low-level information on a container   # 查看容器详细信息<br>kill      Kill a running container                      # kill 指定 docker 容器<br>load      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]<br>login     Register or Login to the docker registry server    # 注册或者登陆一个 docker 源服务器<br>logout    Log out from a Docker registry server          # 从当前 Docker registry 退出<br>logs      Fetch the logs of a container                 # 输出当前容器日志信息<br>port      Lookup the public-facing port which is NAT-ed to PRIVATE_PORT    # 查看映射端口对应的容器内部源端口<br>pause     Pause all processes within a container        # 暂停容器<br>ps        List containers                               # 列出容器列表<br>pull      Pull an image or a repository from the docker registry server   # 从docker镜像源服务器拉取指定镜像或者库镜像<br>push      Push an image or a repository to the docker registry server    # 推送指定镜像或者库镜像至docker源服务器<br>restart   Restart a running container                   # 重启运行的容器<br>rm        Remove one or more containers                 # 移除一个或者多个容器<br>rmi       Remove one or more images             # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]<br>run       Run a command in a new container              # 创建一个新的容器并运行一个命令<br>save      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]<br>search    Search for an image on the Docker Hub         # 在 docker hub 中搜索镜像<br>start     Start a stopped containers                    # 启动容器<br>stop      Stop a running containers                     # 停止容器<br>tag       Tag an image into a repository                # 给源中镜像打标签<br>top       Lookup the running processes of a container   # 查看容器中运行的进程信息<br>unpause   Unpause a paused container                    # 取消暂停容器<br>version   Show the docker version information           # 查看 docker 版本号<br>wait      Block until a container stops, then print its exit code   # 截取容器停止时的退出状态值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youngyang.top/2020/07/04/Java%E4%B9%8BJUC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="youngyang">
      <meta itemprop="description" content="Record what you want!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/Java%E4%B9%8BJUC/" class="post-title-link" itemprop="url">Java之JUC</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-04 20:10:15 / 修改时间：20:08:11" itemprop="dateCreated datePublished" datetime="2020-07-04T20:10:15+08:00">2020-07-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK 1.5开始出现的。下面一起来看看它怎么使用。</p>
<h1 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
<p>线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</p>
<p>例如：<br>使用QQ，查看进程一定有一个QQ.exe的进程，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。</p>
<p>大四的时候写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。</p>
<p>word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个线程：容灾备份，语法检查。</p>
<h2 id="线程的状态（Thread-State）"><a href="#线程的状态（Thread-State）" class="headerlink" title="线程的状态（Thread.State）"></a>线程的状态（Thread.State）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">//线程刚创建</span></span><br><span class="line">    NEW,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//在JVM中正在运行的线程</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//线程处于阻塞状态，等待监视锁，可以重新进行同步代码块中执行</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待状态</span></span><br><span class="line">    WAITING,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用sleep() join() wait()方法可能导致线程处于等待状态</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//线程执行完毕，已经退出</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="wait和sleep"><a href="#wait和sleep" class="headerlink" title="wait和sleep"></a>wait和sleep</h2><p>wait和sleep功能都是当前线程暂停，有什么区别？<br>wait放开手去睡，放开手里的锁；sleep握紧手去睡，醒了手里还有锁。</p>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>这是我自己的理解：<br>1）并行是指两个或者多个事件在<strong>同一时刻</strong>发生；而并发是指两个或多个事件在<strong>同一时间间隔</strong>发生。<br>2）并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。</p>
<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><p>1）继承Thread类<br>如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> <span class="title">extends</span> <span class="title">Thread</span></span></span><br></pre></td></tr></table></figure>
<p>但是，java是单继承，资源宝贵，要用接口方式。<br>2）实现Runnable接口<br>如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="title">implements</span> <span class="title">Runnable</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数体</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方法会创建新的类，所以使用第三种方法，即：直接new接口，使用匿名内部类的方式。<br>3）利用Thread的带参数构造方法<img src="https://img-blog.csdnimg.cn/20191112155846815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第一个参数：传递一个Runnable的实现类；第二个参数：线程名称。<br>如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line"> 		<span class="comment">//函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;, <span class="string">"your thread name"</span>).start();</span><br></pre></td></tr></table></figure>
<p><strong>补充</strong>：另外Runnable中只有一个抽象方法，是一个函数式接口（@FunctionalInterface），所以此处可以使用lambda表达式进行简化。简化结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(	()-&gt;&#123; &#123;<span class="comment">//函数体&#125;&#125;, "your thread name").start();</span></span><br></pre></td></tr></table></figure>
<p>接口里是否能有实现方法？<br>答：接口里在java 8后容许有接口的实现，default方法默认实现，并且可以有多个default方法。<br>如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x/y;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>另外接口中还可以呀静态方法的实现（静态方法必须用类去调用，不可以使用对象实例），并且可以有多个，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h1><p>在高内聚低耦合前提下，多线程的模板：<strong>线程 操作 资源类</strong>。<br>实现步骤：首先创建资源类，再在资源类中创建同步方法或者同步代码块。</p>
<p>使用synchronized创建同步方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">30</span>;</span><br><span class="line">	<span class="comment">//同步方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    		System.out.println(Thread.currentThread().getName()+<span class="string">"卖出"</span>+(number--)+<span class="string">"\t 还剩number);</span></span><br><span class="line"><span class="string">   		&#125;</span></span><br><span class="line"><span class="string">   		/*同步代码块</span></span><br><span class="line"><span class="string">  		synchronized(this) &#123;</span></span><br><span class="line"><span class="string">  		if(number &gt; 0) &#123;</span></span><br><span class="line"><span class="string">    		System.out.println(Thread.currentThread().getName()+"</span>卖出<span class="string">"+(number--)+"</span>\t 还剩number);</span><br><span class="line">  		&#125;</span><br><span class="line">	&#125;*/</span><br><span class="line">	&#125; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> &#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">    <span class="comment">//3个人同事卖30张票</span></span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; i++)ticket.sale();&#125;, <span class="string">"AA"</span>).start();</span><br><span class="line"> 	<span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; i++)ticket.sale();&#125;, <span class="string">"BB"</span>).start();</span><br><span class="line"> 	<span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span>; i++)ticket.sale();&#125;, <span class="string">"CC"</span>).start();</span><br><span class="line">	&#125;	   	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用lock类创建如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.guigu.juc;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/11/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> &#123;</span><span class="comment">//资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1000</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"卖出了第"</span> + (number--) + <span class="string">"张票，还剩下"</span> + number + <span class="string">"张！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaleTicket</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws Exception </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//Lambda Express</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) ticket.saleTicket();</span><br><span class="line">        &#125;, <span class="string">"a"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) ticket.saleTicket();</span><br><span class="line">        &#125;, <span class="string">"b"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) ticket.saleTicket();</span><br><span class="line">        &#125;, <span class="string">"c"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><p><strong>案例</strong>：<br>要求：现在两个线程 可以操作初始值为零的一个变量，实现一个线程对该变量加1，一个线程对该变量减1，交替执行10轮。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareDataOne</span>//资源类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;<span class="comment">//初始值为零的一个变量</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> throws InterruptedException </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="comment">//1判断</span></span><br><span class="line">     <span class="keyword">if</span>(number !=<span class="number">0</span> ) &#123;</span><br><span class="line">       <span class="keyword">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//2干活</span></span><br><span class="line">     ++number;</span><br><span class="line">     System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+number);</span><br><span class="line">     <span class="comment">//3通知</span></span><br><span class="line">     <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> throws InterruptedException </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="comment">// 1判断</span></span><br><span class="line">     <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">this</span>.wait();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2干活</span></span><br><span class="line">     --number;</span><br><span class="line">     System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + number);</span><br><span class="line">     <span class="comment">// 3通知</span></span><br><span class="line">     <span class="keyword">this</span>.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  * 笔记：Java里面如何进行工程级别的多线程编写</span></span><br><span class="line"><span class="comment"> * 1 多线程变成模板（套路）-----上</span></span><br><span class="line"><span class="comment"> *     1.1  线程    操作    资源类  </span></span><br><span class="line"><span class="comment"> *     1.2  高内聚  低耦合</span></span><br><span class="line"><span class="comment"> * 2 多线程变成模板（套路）-----下</span></span><br><span class="line"><span class="comment"> *     2.1  判断</span></span><br><span class="line"><span class="comment"> *     2.2  干活</span></span><br><span class="line"><span class="comment"> *     2.3  通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotifyWaitDemoOne</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     ShareDataOne sd = <span class="keyword">new</span> ShareDataOne();</span><br><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.increment();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">"A"</span>).start();</span><br><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            sd.decrement();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">"B"</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面案例是两个线程，如果换成4个线程会导致错误，虚假唤醒。<br>原因：在java多线程判断时，不能用if，程序出事出在了判断上面，突然有一添加的线程进到if了，突然中断了交出控制权，没有进行验证，而是直接走下去了，加了两次，甚至多次。</p>
<p>中断和虚假唤醒是可能产生的，所以要用loop循环，if只判断一次，while是只要唤醒就要拉回来再判断一次。if换成while。</p>
<h1 id="线程间定制化调用通信"><a href="#线程间定制化调用通信" class="headerlink" title="线程间定制化调用通信"></a>线程间定制化调用通信</h1><p>synchronized不能够实现线程间的定制化调用通信，若要实现线程间的定制化调用通信，则需要用到<strong>java.util.concurrent.locks.Lock</strong>类和<strong>java.util.concurrent.locks.Condition</strong>类。<br><strong>案例</strong>：<br>要求：多线程之间按顺序调用，实现A-&gt;B-&gt;C<br>三个线程启动，要求如下：AA打印5次，BB打印10次，CC打印15次；接着AA打印5次，BB打印10次，CC打印15次；如此反复来10轮。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareResource</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;<span class="comment">//1:A 2:B 3:C </span></span><br><span class="line">  <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print5</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> </span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//1 判断</span></span><br><span class="line">       <span class="keyword">while</span>(number != <span class="number">1</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">//A 就要停止</span></span><br><span class="line">          c1.await();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2 干活</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">5</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+i+<span class="string">"\t totalLoopNumber: "</span>+totalLoopNumber);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3 通知</span></span><br><span class="line">       number = <span class="number">2</span>;</span><br><span class="line">       c2.signal();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print10</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> </span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//1 判断</span></span><br><span class="line">       <span class="keyword">while</span>(number != <span class="number">2</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">//A 就要停止</span></span><br><span class="line">          c2.await();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2 干活</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+i+<span class="string">"\t totalLoopNumber: "</span>+totalLoopNumber);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3 通知</span></span><br><span class="line">       number = <span class="number">3</span>;</span><br><span class="line">       c3.signal();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print15</span><span class="params">(<span class="keyword">int</span> totalLoopNumber)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     lock.lock();</span><br><span class="line">     <span class="keyword">try</span> </span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">//1 判断</span></span><br><span class="line">       <span class="keyword">while</span>(number != <span class="number">3</span>)</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">//A 就要停止</span></span><br><span class="line">          c3.await();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2 干活</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">15</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">"\t"</span>+i+<span class="string">"\t totalLoopNumber: "</span>+totalLoopNumber);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//3 通知</span></span><br><span class="line">       number = <span class="number">1</span>;</span><br><span class="line">       c1.signal();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadOrderAccess</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     ShareResource sr = <span class="keyword">new</span> ShareResource();</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          sr.print5(i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">"AA"</span>).start();</span><br><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          sr.print10(i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">"BB"</span>).start();</span><br><span class="line">     <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">10</span>; i++) </span><br><span class="line">       &#123;</span><br><span class="line">          sr.print15(i);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;, <span class="string">"CC"</span>).start();     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多线程的8锁"><a href="#多线程的8锁" class="headerlink" title="多线程的8锁"></a>多线程的8锁</h1><p>多线程的8锁问题（两个方法不说明情况下都为普通同步方法（非静态））：<br>1 标准访问，先打印短信还是邮件<br>2 停4秒在短信方法内，先打印短信还是邮件<br>3 普通的hello方法，是先打短信还是hello<br>4 现在有两部手机，先打印短信还是邮件<br>5 两个静态同步方法，1部手机，先打印短信还是邮件<br>6 两个静态同步方法，2部手机，先打印短信还是邮件<br>7 1个静态同步方法，1个普通同步方法，1部手机，先打印短信还是邮件<br>8 1个静态同步方法，1个普通同步方法，2部手机，先打印短信还是邮件<br><strong>运行答案</strong>：<br>1、短信<br>2、短信<br>3、Hello<br>4、邮件<br>5、短信<br>6、短信<br>7、邮件<br>8、邮件</p>
<p>相应代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span>  synchronized <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> throws Exception</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   TimeUnit.SECONDS.sleep(<span class="number">4</span>);<span class="comment">//睡眠4秒钟</span></span><br><span class="line">   System.out.println(<span class="string">"------sendSMS"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> throws Exception</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"------sendEmail"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"------getHello"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock_8</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws Exception</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">   Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     phone.sendSMS();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;, <span class="string">"AA"</span>).start();</span><br><span class="line">   </span><br><span class="line">   Thread.sleep(<span class="number">100</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     phone.sendEmail();</span><br><span class="line">     <span class="comment">//phone.getHello();</span></span><br><span class="line">     <span class="comment">//phone2.sendEmail();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;, <span class="string">"BB"</span>).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>8锁总结</strong>：（重要）</p>
<p>分析8锁问题，我觉得唯一需要掌握的核心是各种锁所锁的是哪个对象。</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">A 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，</span></span><br><span class="line"><span class="xml">其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</span></span><br><span class="line"><span class="xml">锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">加个普通方法后发现和同步锁无关</span></span><br><span class="line"><span class="xml">换成两个对象后，不是同一把锁了，情况立刻变化。</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</span></span><br><span class="line"><span class="xml">具体表现为以下3种形式。</span></span><br><span class="line"><span class="xml">对于普通同步方法，锁是当前实例对象。</span></span><br><span class="line"><span class="xml">对于静态同步方法，锁是当前类的Class对象。</span></span><br><span class="line"><span class="xml">对于同步方法块，锁是Synchonized括号里配置的对象</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，</span></span><br><span class="line"><span class="xml">可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，</span></span><br><span class="line"><span class="xml">所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</span></span><br><span class="line"><span class="xml"> </span></span><br><span class="line"><span class="xml">所有的静态同步方法用的也是同一把锁——类对象本身，</span></span><br><span class="line"><span class="xml">这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。</span></span><br><span class="line"><span class="xml">但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，</span></span><br><span class="line"><span class="xml">而不管是同一个实例对象的静态同步方法之间，</span></span><br><span class="line"><span class="xml">还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</span></span><br></pre></td></tr></table></figure>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>在使用集合，如ArrayList、HashSet、HashMap的时候很容易出现线程安全问题，并发修改异常就会报并发修改异常（java.util.ConcurrentModificationException）。</p>
<p>知识回顾：<br>1、ArrayList的底层是一个object的数组；HashSet的底层是HashMap，但是HashSet的add方法是放一个数据进去，所以将此数据作为HashMap的key，其value是一个固定的Object类型值；HashMap底层是Node节点和链表。<br>2、HashMap的构造方法：<br>        1、new HashMap();构造一个默认的初始容量为16，和默认的负载因子为0.75的HashMap。<br>        2、new HashMap(<strong>int initialCapacity, float loadFactor</strong>);构造一个默认的初始容量为initialCapacity，和默认的负载因子为loadFactor的HashMap。</p>
<p>在ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常。<br>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">30</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                <span class="built_in">list</span>.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">                System.out.println(<span class="built_in">list</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList的底层其实是一个Object类型的数组（Object [ ]）,在上述过程中，很多线程既对list读又对list写，所以出现了ConcurrentModificationException异常。<br>查看ArrayList源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add方法并没有加synchronized，线程不安全。</p>
<p>提出三种解决方案如下：</p>
<p><strong>解决方案1</strong>、使用Vector代替ArrayList<br><img src="https://img-blog.csdnimg.cn/20191113212753653.png" alt="在这里插入图片描述"><br>Vector和ArrayList两个类都实现了List接口，但是观察Vector源码如下可发现加了synchronized，所以是线程安全的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> synchronized boolean <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>弊端</strong>：虽然Vector相对ArrayList来说加了synchronized，保证了线程安全，保持了数据的一致性，但是因为加了锁降低了高并发的效率。</p>
<p><strong>解决方案2</strong>、使用集合工具类Collections<br>如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="built_in">list</span> = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>Collections提供了方法synchronizedList保证list是同步线程安全的。<br>那HashMap，HashSet是线程安全的吗？也不是，所以有同样的线程安全方法。<br><img src="https://img-blog.csdnimg.cn/20191113213852140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解决方案3、使用java.util.concurrent包中的CopyOnWriteArrayList类。<br><img src="https://img-blog.csdnimg.cn/20191113214018864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>查看CopyOnWriteArrayList中add方法的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    final ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CopyOnWriteArrayList类虽然也用lock加了锁，但是他在add方法中复制出一份数组数据供本线程进行add写操作，原来的数据供其他线程读操作，在写完之后用类中的setArray()方法在将新生成的数组赋值给原数组。此类用到了<strong><em>读写分离</em></strong>的思想，读写互不干扰，但是应该注意，其底层是读写不同的数组，而不是同时读写相同的一个数组。</p>
<p>同样的：    </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//线程不安全</span></span><br><span class="line"> 	Set&lt;String&gt; <span class="built_in">set</span> = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();<span class="comment">//线程安全</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//线程不安全</span></span><br><span class="line">Map&lt;String,String&gt; <span class="built_in">map</span> = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="comment">//线程安全</span></span><br></pre></td></tr></table></figure>
<h1 id="获得多线程的第三种方法"><a href="#获得多线程的第三种方法" class="headerlink" title="获得多线程的第三种方法"></a>获得多线程的第三种方法</h1><p>前面介绍了两种获得多线程的方法：继承Thread类和实现Runnable接口。传统的是继承thread类和实现runnable接口，这两种方法，java 5以后又有实现JUC中的callable接口和java的线程池获得。</p>
<p>第三种方法：实现函数式接口Callable，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mythread</span> <span class="title">implements</span> <span class="title">Callable</span>&lt;Integer&gt;&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> throws Exception</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>callable接口与runnable接口的区别？</p>
<p> 答：（1）是否有返回值<br>       （2）是否抛异常<br>       （3）落地方法不一样，一个是run，一个是call<br> <strong>用法</strong>：<br>获得多线程的时候需要向Thread的构造方法中传一个Runnable接口的实现类，如new Thread(Runnable r,String name);但是实现Callable接口的类并不是Runnable的实现类，所以不能直接传给Thread构造方法。<br>但是Runnable在JUC包中有一个子接口RunnableFuture，而RunnableFuture在JUC中又有一个子接口FutureTask，FutureTask有一个构造方法FutureTask(Callable<V> callable) ，所以用上述的Callable实现类即可获得多线程。如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mythread</span> <span class="title">implements</span> <span class="title">Callable</span>&lt;Integer&gt;&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> throws Exception</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> &#123;</span></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Mythread());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现Callable相对于Runnable接口的优势在于会有一个返回值。那我们如何获取这个返回值呢？<br><img src="https://img-blog.csdnimg.cn/20191113222449767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>原理</strong>：<br>在主线程中需要执行比较耗时的操作，但又不想阻塞主线程时，可以把这些作业交给FutureTask对象在后台完成，当主线程将来需要时，就可以通过FutureTask对象获得后台作业的计算结果或者执行状态。</p>
<p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>
<p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。 所以建议<strong>get方法放到最后</strong>。</p>
<p>同一个Callable实现类中的call方法只计算一次，利用同一个Callable实现类获取多线程时，其中的代码只执行一次。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mythread</span> <span class="title">implements</span> <span class="title">Callable</span>&lt;Integer&gt;&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> throws Exception</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> &#123;</span></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> Mythread());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上诉代码的执行结果为：<br><img src="https://img-blog.csdnimg.cn/20191113223517266.png" alt="在这里插入图片描述"></p>
<h1 id="JUC中强大的辅助类"><a href="#JUC中强大的辅助类" class="headerlink" title="JUC中强大的辅助类"></a>JUC中强大的辅助类</h1><p>这里讲解三个JUC中的强大辅助类，分别是CountDownLatch、CyclicBarrier和Semaphore，这三个辅助类用于进一步控制线程的调度问题，其中CountDownLatch使用减法计数的方式控制某个线程在多个线程之后进行，而CyclicBarrier用加法计数的形式控制某个线程在多个线程之后进行，Semaphore能够控制线程的并发数量。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><strong>原理</strong>： CountDownLatch主要有await()和countDown()两个方法，当一个或多个线程调用await()方法时，这些线程会阻塞。其它线程调用countDown()方法会将计数器减1(调用countDown方法的线程不会阻塞)，当计数器的值变为0时，因await()方法阻塞的线程会被唤醒，继续执行。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。</span></span><br><span class="line"><span class="comment"> * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，</span></span><br><span class="line"><span class="comment"> * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 解释：6个同学陆续离开教室后值班同学才可以关门。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * main主线程必须要等前面6个线程完成全部工作后，自己才能开干 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws InterruptedException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   	   CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//6个上自习的同学，各自离开教室的时间不一致</span></span><br><span class="line">       &#123;</span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              System.out.println(Thread.currentThread().getName()+<span class="string">"\t 号同学离开教室"</span>);</span><br><span class="line">              countDownLatch.countDown();</span><br><span class="line">          &#125;, String.valueOf(i)).start();</span><br><span class="line">       &#125;</span><br><span class="line">       countDownLatch.await();</span><br><span class="line">       System.out.println(Thread.currentThread().getName()+<span class="string">"\t****** 班长关门走人，main线程是班长"</span>);         </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><strong>原理</strong>：CyclicBarrier 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是， 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CyclicBarrier</span></span><br><span class="line"><span class="comment"> * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，</span></span><br><span class="line"><span class="comment"> * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，</span></span><br><span class="line"><span class="comment"> * 直到最后一个线程到达屏障时，屏障才会开门，所有</span></span><br><span class="line"><span class="comment"> * 被屏障拦截的线程才会继续干活。</span></span><br><span class="line"><span class="comment"> * 线程进入屏障通过CyclicBarrier的await()方法。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 集齐7颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> NUMBER = <span class="number">7</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="comment">//CyclicBarrier(int parties, Runnable barrierAction) </span></span><br><span class="line">     </span><br><span class="line">     CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUMBER, ()-&gt;&#123;System.out.println(<span class="string">"*****集齐7颗龙珠就可以召唤神龙"</span>);&#125;) ;</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 星龙珠被收集 "</span>);</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125; </span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><strong>原理</strong>：在信号量上我们定义两种操作：</p>
<ul>
<li>acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。</li>
<li>release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。</li>
<li></li>
<li>信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.thread;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);<span class="comment">//模拟3个停车位</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">6</span>; i++) <span class="comment">//模拟6部汽车</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> </span><br><span class="line">          &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t 抢到了车位"</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"\t------- 离开"</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;finally &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;, String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ReadWriteLock读写锁"><a href="#ReadWriteLock读写锁" class="headerlink" title="ReadWriteLock读写锁"></a>ReadWriteLock读写锁</h1><p>正常情况下应该保证只有一个设备在进行写操作，也就是等一个线程写完之后其他的写线程才能执行，否则就会出错。未加锁控制的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t 正在写"</span>+key);</span><br><span class="line">        <span class="comment">//暂停一会儿线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace(); &#125;</span><br><span class="line">        <span class="built_in">map</span>.put(key,value);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t 写完了"</span>+key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        Object result = null;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t 正在读"</span>+key);</span><br><span class="line">        <span class="keyword">try</span> &#123;TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace(); &#125;</span><br><span class="line">        result = <span class="built_in">map</span>.get(key);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"\t 读完了"</span>+result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            final <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.put(num+<span class="string">""</span>,num+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            final <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                myCache.get(num+<span class="string">""</span>);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JUC中locks.Losk类虽然可以控制线程的安全保证相同的时间只有一个操作执行，但是这也规定了相同时间只能有一个操作不管是写还是读，降低了并发性能。在正常情况下，我们应该保证读写分离，即只有一个线程在写，读操作不做限制可以有多个线程在读，所以使用locks.ReadWriteLock。</p>
<p>改良后代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock rwLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在写"</span> + key);</span><br><span class="line">            <span class="comment">//暂停一会儿线程</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 写完了"</span> + key);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        Object result = null;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 正在读"</span> + key);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">map</span>.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"\t 读完了"</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache myCache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            final <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.put(num + <span class="string">""</span>, num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            final <span class="keyword">int</span> num = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                myCache.get(num + <span class="string">""</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youngyang.top/2020/07/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="youngyang">
      <meta itemprop="description" content="Record what you want!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">Java虚拟机中类加载的过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-04 20:10:15 / 修改时间：20:08:09" itemprop="dateCreated datePublished" datetime="2020-07-04T20:10:15+08:00">2020-07-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本篇博客主要讲解Java虚拟机加载类的过程。</p>
<p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过<strong>加载，连接，初始化</strong>三步来实现这个类进行初始化。其中连接又包括三步：验证、准备和解析。</p>
<p>类的生命周期如图所示：<br><img src="https://img-blog.csdnimg.cn/20200514221537884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><p>“加载”是“类加载”（Class Loading）过程的一个阶段，希望读者没有混淆这两个看起来 很相似的名词。</p>
<p>在加载阶段，虚拟机需要完成以下3件事情：<br><strong>1）通过一个类的全限定名来获取定义此类的二进制字节流。<br> 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>  3）在内存中生成一个代表这个类的java.lang.Class对象。</strong></p>
<p>对 于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这 个对象将作为程序访问方法区中的这些类型数据的外部接口。</p>
<p>这里有两个重点：</p>
<p>字节码来源。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译。</p>
<p>（1）Java虚拟机将.class文件读入内存，并为之创建一个Class对象。<br>（2）任何类被使用时系统都会为其创建<strong>一个且仅有一个</strong>Class对象。<br>（3）这个Class对象描述了这个类创建出来的对象的所有信息，比如有哪些构造方法，都有哪些成员方法，都有哪些成员变量等。</p>
<p>Student类加载过程图示：<br><img src="https://img-blog.csdnimg.cn/20200409225557693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机加载类使用的是类加载器，加载器分为四种：<br>分别是：<strong>Bootstrat Class Loader、Extension Class Loader、System Class Loader和用户自定义的类加载器</strong>。<br><img src="https://img-blog.csdnimg.cn/20200409225809652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="1、boot"><br>VM预定义有三种类加载器，当一个 JVM启动的时候，Java开始使用如下三种类加载器：</p>
<p> 1)<strong>根类加载器（bootstrap class loader）</strong>:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。<br> 2)<strong>扩展类加载器（extensions class loader）</strong>：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。<br>  3)<strong>系统类加载器（system class loader）</strong>：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。</p>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p><strong>类加载器加载Class使用双亲委派机制：</strong><br>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 </p>
<p>采用双亲委派的一个好处是：<br>比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。 </p>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>链接又包括三个阶段，分别是：验证、准备以及解析。</p>
<p>（1）<strong>验证阶段。验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</strong></p>
<p>包括对于文件格式的验证，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？<br>对于元数据的验证，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？<br>对于字节码的验证，保证程序语义的合理性，比如要保证类型转换的合理性。<br>对于符号引用的验证，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p>
<p>（2）<strong>准备阶段</strong>：准备阶段是正式<strong>为类变量分配内存并设置类变量初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<p>这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这 时候进行内存分配的<strong>仅包括类变量</strong>（被static修饰的变量），而<strong>不包括实例变量</strong>，实例变量将会在对象实例化时随着对象一起分配在Java堆中。通常情况下的初始值如下表：<br><img src="https://img-blog.csdnimg.cn/20200514222711997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其次，这里所说的初始值“通常情况”下是 数据类型的零值，假设一个类变量的定义为：public static final a = 1;<br>那么这个a就会直接被赋值为指定的值1。</p>
<p>（3）<strong>解析阶段</strong>。将类的二进制数据中的符号引用替换为直接引用。<br>说明：<br><strong>符号引用</strong>：即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。<br><strong>直接引用</strong>：可以理解为一个内存地址，或者一个偏移量。比如类方法，类变量的直接引用是指向方法区的指针；而实例方法，实例变量的直接引用则是从实例的头指针开始算起到这个实例变量位置的偏移量。</p>
<p>举个例子来说，现在调用方法hello()，这个方法的地址是0xaabbccdd，那么hello就是符号引用，0xaabbccdd就是直接引用。</p>
<p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>这是类加载机制的最后一步，在这个阶段，java程序代码才开始真正执行。我们知道，<strong>在准备阶段已经为类变量赋过一次值。在初始化阶段，程序员可以根据自己的需求来赋值了。</strong></p>
<p>在初始化阶段，主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<p>①声明类变量是指定初始值<br>②使用静态代码块为类变量指定初始值</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>类加载过程只是一个类生命周期的一部分，在其前，有编译的过程，只有对源代码编译之后，才能获得能够被虚拟机加载的字节码文件；在其后还有具体的类使用过程，当使用完成之后，还会在方法区垃圾回收的过程中进行卸载（垃圾回收）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youngyang.top/2020/07/04/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="youngyang">
      <meta itemprop="description" content="Record what you want!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%EF%BC%9A%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">Java的四种引用：强引用、软引用、弱引用、虚引用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-04 20:10:15 / 修改时间：20:08:09" itemprop="dateCreated datePublished" datetime="2020-07-04T20:10:15+08:00">2020-07-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="整体引用架构"><a href="#整体引用架构" class="headerlink" title="整体引用架构"></a>整体引用架构</h2><p>Java中包括四种引用，分别是强引用、软引用、弱引用、虚引用。这些引用关系也对对象的生命周期有着重要的联系。</p>
<p>四种引用的架构图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200328213542771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>四种引用的区别和各自特点：<br><img src="https://img-blog.csdnimg.cn/20200328222546828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>Reference就是强引用，SoftReference是弱引用，WeakReference是弱引用，PhantomReference是虚引用。</strong></p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>对于普通的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object object = new Object();</span><br></pre></td></tr></table></figure>
<p>对于这种直接new出来赋值的操作就是强引用。</p>
<p>当内存不足，JVM开始垃圾回收，对于强引用的对象，<strong>就算是出现了OOM也不会对该对象进行回收</strong>。只有显式地设置o为null，或超出对象的生命周期范围，gc才认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。</p>
<p>强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在Java<br>中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达<br>状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要<br>原因之一。</p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应(强)引用赋值为null，一般认为就是可以被垃圾收集的了(当然具体回收时机还是要看垃圾收集策略)。</p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref. SoftReference类来实现，可以让对象豁免一些垃圾收集。</p>
<p>对于只有软引用的对象来说，当<strong>系统内存充足时它不会被回收，当系统内存不足时它会被回收</strong>。软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用的时候就保留，不够用就回收。</p>
<p>验证代码如下，在内存充足也就是不发生OOM的时候：<br><img src="https://img-blog.csdnimg.cn/20200328215014336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200328215316515.png" alt="在这里插入图片描述"><br>在内存不足发生OOM的时候：（这里我设置的是-Xms10m -Xmx10m，在程序中new了一个大数组，所以必回OOM）<br><img src="https://img-blog.csdnimg.cn/20200328215403466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/2020032821551984.png" alt="在这里插入图片描述"></p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用需要使用java.lang.ref.WeakReference来实现，他比软引用的生命周期更短。<strong>只要发生GC，该引用的对象就会被回收。</strong><br><img src="https://img-blog.csdnimg.cn/20200328220130849.png" alt="在这里插入图片描述"><br>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200328220152924.png" alt="在这里插入图片描述"></p>
<h2 id="使用软引用和弱引用的场景"><a href="#使用软引用和弱引用的场景" class="headerlink" title="使用软引用和弱引用的场景"></a>使用软引用和弱引用的场景</h2><p>假如有一个应用需要读取大量的本地图片：</p>
<p>如果每次读取图片都从硬盘读取则会严重影响性能，如果一次性全部加载到内存中又可能造成内存溢出。此时使用软引用可以解决这个问题。</p>
<p>设计思路是:用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span></span><br><span class="line">HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="WeakHasnMap"><a href="#WeakHasnMap" class="headerlink" title="WeakHasnMap"></a>WeakHasnMap</h2><p>WeakHashMap在使用上和HashMap没有任何的区别，只不过WeakHashMap的key被设置为null并经过gc垃圾回收之后，这个数据将会从map中被回收掉。<br>代码示例如下：<br><img src="https://img-blog.csdnimg.cn/20200328220718573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>输出结果为：<br><img src="https://img-blog.csdnimg.cn/20200328220957355.png" alt="在这里插入图片描述"></p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用需要java.lang.ref:PhantomReference类来实现。</p>
<p>顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p>
<p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在<strong>任何时候都可能被垃圾回收器回收</strong>，它不能单独使用也不能通过它访问对象，虚引用必须和<strong>引用队列(ReferenceQueue)</strong>联合使用。<br>虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。</p>
<p>PhantomReference的get方法总是返回null,因此无法访问对应的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被<br>gc回收，用来实现比finalization机制更灵活的回收操作。</p>
<p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到–个系统通知或者后续添加进一步的处理。Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p>
<p>想要深入理解虚引用，我觉得很有必要理解一下引用队列。<br><img src="https://img-blog.csdnimg.cn/2020032822131292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>其实不管是对SoftReference对象还是WeakReference亦或者是PhantomReference来说他们不只是单单有一个传入引用对象的构造方法，他们还可以传入一个引用队列，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200328221544279.png" alt="在这里插入图片描述"><br>那么传入的这个引用对列有什么用呢？</p>
<p>这个引用队列的作用就是对象在被回收之前会被保存到引用队列中。<br>示例代码如下：<br><img src="https://img-blog.csdnimg.cn/20200328222212940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200328222154722.png" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/20200328222247518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youngyang.top/2020/07/04/Java%20%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="youngyang">
      <meta itemprop="description" content="Record what you want!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/Java%20%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81/" class="post-title-link" itemprop="url">Java 线程的6种状态</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-04 20:10:15 / 修改时间：20:08:09" itemprop="dateCreated datePublished" datetime="2020-07-04T20:10:15+08:00">2020-07-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.5k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>关于Java线程的状态网上的说法不一，有的说是6种状态，有的说是5中状态，索性就查看了一下Java源码。Thread类里面有一个枚举类，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个枚举类里面有6种类型，所以Java中的线程有6种状态。</p>
<p>关于各种状态的简单说明：<br><strong>NEW(初始)</strong>：线程被创建后尚未启动。<br><strong>RUNNABLE(运行)</strong>：包括了操作系统线程状态中的Running和<strong>Ready</strong>，也就是处于此状态的线程可能正在运行，也可能正在等待系统资源，如等待CPU为它分配时间片。<br><strong>BLOCKED(阻塞)</strong>：线程阻塞于锁。<br><strong>WAITING(等待)</strong>：线程需要等待其他线程做出一些特定动作（通知或中断）。<br><strong>TIME_WAITING(超时等待)</strong>：该状态不同于WAITING，它可以在指定的时间内自行返回。<br>TERMINATED(终止)：该线程已经执行完毕。</p>
<p>状态图 ：<br><img src="https://img-blog.csdnimg.cn/20200501000733227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>初始状态<br>通过继承Thread类或实现Runnable接口得到一个线程类，new一个实例出来，这个生成的线程就进入了初始状态。</li>
</ol>
<p>该线程没有被start()启动，但也不代表调用了start()状态就立即改变状态，中间还有一些步骤，如果在这个启动的过程中有另一个线程来获取它的状态，其实是不确定的，要看那些中间步骤是否已经完成了。</p>
<ol start="2">
<li>运行状态<br>就绪状态</li>
</ol>
<p>包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程可能正在运行，也可能正在等待系统资源，如等待CPU为它分配时间片。就绪状态有资格运行，但是要等到调度程序选到，不选到永远都是就绪状态。</p>
<p>进入就绪状态的几种方式：</p>
<p>新建的线程调用start()方法进入就绪状态。<br>运行中线程时间片用完了，调用该线程的yield()方法进入就绪状态。<br>等待锁资源的线程拿到对象锁后进入就绪状态。<br>当前线程sleep()结束、其他线程join()结束、等待用户输入完毕、某个线程拿到对象锁，这些线程也将进入就绪状态。<br>运行中状态</p>
<p>线程调度程序从可运行线程池中选择一个线程作为当前线程时，该线程所处的状态。</p>
<ol start="3">
<li><p>阻塞状态<br>线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p>
</li>
<li><p>等待状态<br>线程需要等待其他线程做通知或中断，如果没有就要一直等待下去。</p>
</li>
</ol>
<p>比如：<br>Thread1获取lock对象锁，之后调用wait()方法进入等待队列，而同时会释放掉对象锁，状态为Waiting。<br>Thread2获取lock对象锁后调用notify()方法通知一个等待线程，将其移到同步队列，然后继续执行自己Synchronized中的代码，当释放掉lock对象锁后，Thread1线程才有可能重新获取lock并执行先前未完成的代码（是否通知了Thread1要看线程调度器有没有选择Thread1）。</p>
<p>阻塞与等待的区别：</p>
<p>阻塞状态是等待着获取到一个排他锁，进入阻塞状态都是被动的，离开阻塞状态是因为其它线程释放了锁，不阻塞了。<br>等待状态是在等待一段时间或者某个唤醒动作的发生，进入等待状态是主动的。<br>5. 超时等待<br>与等待类似，但可以在指定的时间内自行返回。</p>
<ol start="6">
<li>终止状态<br>当线程的run()方法完成时或主线程的main()方法完成时，我们就认为该线程终止了。这个线程对象也许是活的，但它不是一个线程。<br>线程一旦终止就不能复生。在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youngyang.top/2020/07/04/Java%208%E4%B9%8B%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="youngyang">
      <meta itemprop="description" content="Record what you want!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/Java%208%E4%B9%8B%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">Java 8之流式计算</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-04 20:10:15 / 修改时间：20:08:11" itemprop="dateCreated datePublished" datetime="2020-07-04T20:10:15+08:00">2020-07-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java 8 引入了流式操作（Stream），通过该操作可以实现对集合（Collection）的并行处理和函数式操作。用周阳大神的话说就是：SQL就是JAVA，JAVA就是SQL。使用java.util.stream包中的Stream接口即可完成SQL中的计算、order by、where等操作。根据操作返回的结果不同，流式操作分为中间操作和最终操作两种。最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。根据流的并发性，流又可以分为串行和并行两种。流式操作实现了集合的过滤、排序、映射等功能。</p>
<h1 id="四大内置核心函数式接口"><a href="#四大内置核心函数式接口" class="headerlink" title="四大内置核心函数式接口"></a>四大内置核心函数式接口</h1><p>大部分函数式接口都不用我们自己写，Java 8都给我们写好了，这些接口都在java.util.function包里，下面简单介绍其中的几个。而在讲到Java 8中利用Stream的流式计算的时候，就不得不提及到java.util.function包中的四大函数式接口，分别是<strong>Function</strong>函数接口、<strong>Predicate</strong>函数式接口、<strong>Consumer</strong>函数式接口和<strong>Supplier</strong>函数式接口。</p>
<h2 id="Function函数型函数式接口"><a href="#Function函数型函数式接口" class="headerlink" title="Function函数型函数式接口"></a>Function函数型函数式接口</h2><p> Function接口为函数型接口，该接口的抽象方法接收一个参数并且做一些处理然后返回返回一个参数。其中T为接收参数类型，R为返回参数类型。<br> 源码如下：其中的抽象方法为 <strong>R apply(T t)</strong><img src="https://img-blog.csdnimg.cn/20191115170254736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Predicate断言型函数式接口"><a href="#Predicate断言型函数式接口" class="headerlink" title="Predicate断言型函数式接口"></a>Predicate断言型函数式接口</h2><p>Predicate 用于做判断操作，所以抽象方法返回的是Boolean。<br>源码如下：抽象方法为： <strong>boolean test(T t)</strong><br><img src="https://img-blog.csdnimg.cn/20191115170814909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Consumer消费型函数式接口"><a href="#Consumer消费型函数式接口" class="headerlink" title="Consumer消费型函数式接口"></a>Consumer<strong>消费型函数式接口</strong></h2><p>Consumer表示执行在单个参数上面的操作，但没有返回值的（正如消费有去无回）。<br>该类的源码如下：抽象方法为：<strong>void accept(T t)</strong><br><img src="https://img-blog.csdnimg.cn/20191115171119346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="Supplier供给型函数式接口"><a href="#Supplier供给型函数式接口" class="headerlink" title="Supplier供给型函数式接口"></a>Supplier<strong>供给型函数式接口</strong></h2><p>该接口不接受任何参数，返回一个任意泛型的值。<br>该类的源码如下：<strong>T get()</strong><br><img src="https://img-blog.csdnimg.cn/20191115171253184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://img-blog.csdnimg.cn/20191115171323494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="Stream流式计算"><a href="#Stream流式计算" class="headerlink" title="Stream流式计算"></a>Stream流式计算</h1><p>流(Stream) 到底是什么呢？<br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>“集合讲的是数据，流讲的是计算！”</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、Stream 自己不会存储元素。<br>2、Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。<br>3、Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>1、创建一个Stream：一个数据源（数组、集合）。（如list.stream()将List转换为Stream）<br>2、中间操作：一个中间操作，处理数据源数据。<br>3、终止操作：一个终止操作，执行中间操作链，产生结果。</p>
<p>示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.juc.study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String  userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目：请按照给出数据，找出同时满足</span></span><br><span class="line"><span class="comment"> *      偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序</span></span><br><span class="line"><span class="comment"> *      最后只输出一个用户名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">11</span>,<span class="string">"a"</span>,<span class="number">23</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">12</span>,<span class="string">"b"</span>,<span class="number">24</span>);</span><br><span class="line">        User u3 = <span class="keyword">new</span> User(<span class="number">13</span>,<span class="string">"c"</span>,<span class="number">22</span>);</span><br><span class="line">        User u4 = <span class="keyword">new</span> User(<span class="number">14</span>,<span class="string">"d"</span>,<span class="number">28</span>);</span><br><span class="line">        User u5 = <span class="keyword">new</span> User(<span class="number">16</span>,<span class="string">"e"</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; <span class="built_in">list</span> = Arrays.asList(u1,u2,u3,u4,u5);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span>.stream().filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getId() % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">        &#125;).filter(p -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getAge() &gt; <span class="number">24</span>;</span><br><span class="line">        &#125;).<span class="built_in">map</span>(f -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> f.getUserName().toUpperCase();</span><br><span class="line">        &#125;).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    R apply(T t);</span></span><br><span class="line">        Function&lt;String,Integer&gt; function = t -&gt; &#123;<span class="keyword">return</span> t.length();&#125;;</span><br><span class="line">        System.out.println(function.apply(<span class="string">"abc"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// boolean test(T t);</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = t -&gt; &#123;<span class="keyword">return</span> t.startsWith(<span class="string">"a"</span>);&#125;;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void accept(T t);</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = t -&gt; &#123;System.out.println(t);&#125;;</span><br><span class="line">        consumer.accept(<span class="string">"java1018"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//    T get();</span></span><br><span class="line">        Supplier&lt;String&gt; supplier =  () -&gt; &#123;<span class="keyword">return</span> UUID.randomUUID().toString();&#125;;</span><br><span class="line">        System.out.println(supplier.get());;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youngyang.top/2020/07/04/ConcurrentModifcationException%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="youngyang">
      <meta itemprop="description" content="Record what you want!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/ConcurrentModifcationException%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">ConcurrentModifcationException详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-04 20:10:07 / 修改时间：20:08:09" itemprop="dateCreated datePublished" datetime="2020-07-04T20:10:07+08:00">2020-07-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.3k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文主要讲解为什么会产生ConcurrentModifcationException，以及底层代码分析，并且避免产生该异常的方法。</p>
<p>再讲ConcurrentModifcationException的时候，非常必要的说道集合的迭代器，不同的迭代器会产生不同的效果。</p>
<h1 id="Java中的迭代器"><a href="#Java中的迭代器" class="headerlink" title="Java中的迭代器"></a>Java中的迭代器</h1><h2 id="快速失败（fail—fast）"><a href="#快速失败（fail—fast）" class="headerlink" title="快速失败（fail—fast）"></a>快速失败（fail—fast）</h2><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出<strong>ConcurrentModificationException</strong>。</p>
<p>执行该操作的迭代器称为快速失败迭代器，因为迭代器很快就完全失败，而不会冒着在将来某个时间任意发生不确定行为的风险。迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败操作会尽最大努力抛出ConcurrentModificationException。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>场景：<strong>java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。不光是多线程，在单线程时也可能发生该异常。</strong></p>
<p>多线程下发生该异常，代码如下：<br><img src="https://img-blog.csdnimg.cn/20200328134945803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在遍历整个list集合的时候，向里边添加元素，因为改变了list的结构，modCount会发生改变，故发生该异常。<br><img src="https://img-blog.csdnimg.cn/20200328135103235.png" alt="在这里插入图片描述"><br>单线程下发生该异常：<br><img src="https://img-blog.csdnimg.cn/20200328135200996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为在for循环遍历时候删除元素，同样改变了list的结构导致modCount发生改变，所以会抛出异常。<br><img src="https://img-blog.csdnimg.cn/2020032813521648.png" alt="在这里插入图片描述"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个<strong>modCount</strong>变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>例如我们查看ArrayList的关于iterator（）方法，是new了一个Itr对象。<br><img src="https://img-blog.csdnimg.cn/20200328131032502.png" alt="在这里插入图片描述"><br>那我们进来看看这是一个什么对象呢？这是AbstractList类的一个成员，查看他的next方法。<img src="https://img-blog.csdnimg.cn/20200328131741627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在next方法内部查看是否还有剩余元素的时候，会首先调用checkForComodification（）方法，那么这个方法是干什么的呢？<br><img src="https://img-blog.csdnimg.cn/20200328131947797.png" alt="在这里插入图片描述"><br>这个方法很简单，就是查看modCount变量是否的等于expectedModcount，如果这个值和期待的不相同的话就会抛出ConcurrentModificationException。</p>
<p>那么这个modCount是干什么的呢？</p>
<p>还是查看AbstractList中的注释：<br><img src="https://img-blog.csdnimg.cn/20200328131429570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>对于英语0级的我们，我还是去百度翻一下吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">此列表在结构上被修改的次数。结构修改是那些改变列表大小的修改，</span><br><span class="line">或者以其他方式干扰列表，使得正在进行的迭代可能产生不正确的结果。</span><br><span class="line"></span><br><span class="line">此字段由迭代器和列表迭代器方法返回的迭代器和列表迭代器实现使用。</span><br><span class="line">如果此字段的值意外更改，则迭代器（或列表迭代器）将抛出ConcurrentModificationException</span><br><span class="line">以响应下一个、删除、上一个、设置或添加操作。</span><br><span class="line">这提供了快速失败的行为，而不是迭代过程中并发修改时的不确定行为。</span><br><span class="line"></span><br><span class="line">子类使用此字段是可选的。如果子类希望提供快速失败的迭代器（和列表</span><br><span class="line">迭代器），那么它只需在其add（<span class="keyword">int</span>，E）和remove（<span class="keyword">int</span>）方法（以及</span><br><span class="line">它重写的导致列表结构修改的任何其他方法）中增加这个字段。</span><br><span class="line">对add（<span class="keyword">int</span>，E）或remove（<span class="keyword">int</span>）的单个调用必须向该字段添加不超过一个，否则迭代器（和列表迭代器）将抛出虚假的ConcurrentModificationExceptions。</span><br><span class="line">如果实现不希望提供失败快速迭代器，则可以忽略此字段。</span><br></pre></td></tr></table></figure>
<p>也就是说在对list的结构进行改变（list大小发生改变）的时候，modCount就会发生改变，旨在记录改变的次数。</p>
<p>所以综上所述：在对java.util包下的集合类进行并发修改的时候，一边改变数组的结构，一遍进行遍历，由于modCount发生了改变，所以就会跑异常。</p>
<h2 id="安全失败（fail—safe）"><a href="#安全失败（fail—safe）" class="headerlink" title="安全失败（fail—safe）"></a>安全失败（fail—safe）</h2><p>采用安全-失败机制的集合容器，在<strong>遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历</strong>。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>java.util.concurrent包下的容器都是安全失败，可以在多线程或者单线程下并发使用，并发修改。</p>
<p>如多线程下：<br><img src="https://img-blog.csdnimg.cn/20200328135623859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在单线程下：<br><img src="https://img-blog.csdnimg.cn/20200328135517905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p>
<p>同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p>
<p>众所周知，使用java.util.concurrent包下的集合类比如对应ArrayList的CopyOnWriteArrayList类就可以避免该异常的出现，那么是什么原理呢？</p>
<p>让我们来看看他的源码，来到iterator()方法：<br><img src="https://img-blog.csdnimg.cn/20200328133105324.png" alt="在这里插入图片描述"><br>这个方法调用的是COWIterator对象来完成遍历，并且把当前的list也就是底层存储数据的数组数据，和要返回的元素的索引传过来。来到COWIterator类的next()方法。<br><img src="https://img-blog.csdnimg.cn/20200328133451264.png" alt="在这里插入图片描述"><br>看到上边的注释了吧，unchecked就是不用检查，直接遍历，所以也就不会产生这个异常了。</p>
<p>这是因为他遍历的是拷贝的数据快照，所以并不需要考虑并发修改的问题。</p>
<p>但是也有一个缺点：就是在遍历的时候他为了避免产生并发修改异常，所以拷贝出一份快照用于遍历，在遍历期间修改（添加，修改，删除）的数据遍历不到。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://youngyang.top/2020/07/04/activeMQ%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="youngyang">
      <meta itemprop="description" content="Record what you want!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yang's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/04/activeMQ%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">activeMQ入门</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-04 20:10:03 / 修改时间：20:08:11" itemprop="dateCreated datePublished" datetime="2020-07-04T20:10:03+08:00">2020-07-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="为什么要使用消息中间件？"><a href="#为什么要使用消息中间件？" class="headerlink" title="为什么要使用消息中间件？"></a>为什么要使用消息中间件？</h1><h2 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h2><p>假设你有个系统A，这个系统A会产出一个核心数据，现在下游有系统B和系统C需要这个数据。<br>那简单，系统A就是直接调用系统B和系统C的接口发送数据给他们就好了。</p>
<p>整个过程，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191217123156135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是现在要是来了系统D、系统E、系统F、系统G，等等，十来个其他系统慢慢的都需要这份核心数据呢？如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191217123225235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>大家可别以为这是开玩笑，一个大规模系统，往往会拆分为几十个甚至上百个子系统，每个子系统又对应N多个服务，这些系统与系统之间有着错综复杂的关系网络。</p>
<p>如果某个系统产出一份核心数据，可能下游无数的其他系统都需要这份数据来实现各种业务逻辑。此时如果你要是采取上面那种模式来设计系统架构，那么绝对你负责系统A的同学要被烦死了。</p>
<p>先是来一个人找他要求发送数据给一个新的系统H，系统A的同学要修改代码然后在那个代码里加入调用新系统H的流程。一会那个系统B是个陈旧老系统要下线了，告诉系统A的同学：别给我发送数据了，接着系统A再次修改代码不再给这个系统B。<br><strong>然后如果要是某个上游或者下游系统突然宕机了呢？</strong><br>系统A的调用代码里是不是会抛异常？那系统A的同学会收到报警说异常了，结果他还要去care是下游哪个系统宕机了。所以在实际的系统架构设计中，如果全部采取这种系统耦合的方式，在某些场景下绝对是不合适的，系统耦合度太严重。并且互相耦合起来并不是核心链路的调用，而是一些非核心的场景（比如上述的数据消费）导致了系统耦合，这样会严重的影响上下游系统的开发和维护效率。</p>
<p><strong>因此在上述系统架构中，就可以采用MQ中间件来实现系统解耦。</strong><br>系统A就把自己的一份核心数据发到MQ里，下游哪个系统感兴趣自己去消费即可，不需要了就取消数据的消费，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191217123600178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><p>假设你有一个系统调用链路，是系统A调用系统B，一般耗时20ms；系统B调用系统C，一般耗时200ms；系统C调用系统D，一般耗时2s，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20191217123647654.png" alt="在这里插入图片描述"><br><strong>现在最大的问题就是：</strong><br>用户一个请求过来巨慢无比，因为走完一个链路，需要耗费：<br>20ms + 200ms + 2000ms（2s） = 2220ms，</p>
<p>也就是2秒多的时间。但是实际上，链路中的系统A调用系统B，系统B调用系统C，这两个步骤起来也就220ms。就因为引入了系统C调用系统D这个步骤，导致最终链路执行时间是2秒多，直接将链路调用性能降低了10倍，这就是导致链路执行过慢的罪魁祸首。</p>
<p>那此时我们可以思考一下，是不是可以将系统D从链路中抽离出去做成异步调用呢？其实很多的业务场景是可以允许异步调用的。</p>
<p>这样，实现思路就是系统A -&gt; 系统B -&gt; 系统C，直接就耗费220ms后直接成功了。然后系统C就是发送个消息到MQ中间件里，由系统D消费到消息之后慢慢的异步来执行这个耗时2s的业务处理。通过这种方式直接将核心链路的执行性能提升了10倍。整个过程，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191217123928544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h2><p>假设你有一个系统，平时正常的时候每秒可能就几百个请求，系统部署在8核16G的机器的上，正常处理都是OK的，每秒几百请求是可以轻松抗住的，但是如下图所示，在高峰期一下子来了每秒钟几千请求，弹指一挥间出现了流量高峰，此时你的选择是要搞10台机器，抗住这个瞬时高峰吗？<br><img src="https://img-blog.csdnimg.cn/2019121712402454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>假设瞬时高峰每天就那么半个小时，其它时间基本为每秒就几百请求，如果你线上部署了很多台机器，那么每台机器就处理每秒几十个请求就可以了，这不是有点浪费机器资源吗？大部分时候，每秒几百请求，一台机器就足够了，但是为了抗那每天瞬时的高峰，硬是部署了10台机器，每天就那半个小时有用，别的时候都是浪费资源的。</p>
<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="https://img-blog.csdnimg.cn/20191217124255634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1、采用异步处理模式<br><img src="https://img-blog.csdnimg.cn/2019121712442112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/201912171244327.png" alt="在这里插入图片描述"><br>2、应用系统间解耦<br>发送者和接受者无需了解对方，只需发送或者接收消息即可。并且发送者和接受者无需同时在线。</p>
<h1 id="activeMQ安装"><a href="#activeMQ安装" class="headerlink" title="activeMQ安装"></a>activeMQ安装</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>去官网<a href="http://activemq.apache.org/，下载最新安装包，我使用的是5.15.10版本。" target="_blank" rel="noopener">http://activemq.apache.org/，下载最新安装包，我使用的是5.15.10版本。</a><br>将安装包apache-activemq-5.15.10-bin.tar下载到根目录的/opt下。</p>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-activemq<span class="number">-5.15</span><span class="number">.10</span>-bin.tar</span><br></pre></td></tr></table></figure>
<p>对其进行解压，并把挤压后的文件放到根目录的/myactivemq/文件夹下。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /myactivemq/apache-activemq<span class="number">-5.15</span><span class="number">.10</span>/bin</span><br></pre></td></tr></table></figure>
<p>进入activemq目录下的bin目录，使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./activemq start</span><br></pre></td></tr></table></figure>
<p>启动activeMQ。<br>也可以</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./activemq status</span><br></pre></td></tr></table></figure>
<p>查看activeMQ启动状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./activemq stop</span><br></pre></td></tr></table></figure>
<p>关闭。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在启动ActiveMQ之后，ActiveMQ会开放两个端口，一个是后台端口61616，另一个是前台端口8161.我们可以使用ip+端口号进行访问，如<a href="http://192.168.0.119:8161进行访问。能看到如下画面，即启动成功。" target="_blank" rel="noopener">http://192.168.0.119:8161进行访问。能看到如下画面，即启动成功。</a><br><img src="https://img-blog.csdnimg.cn/20191217195602857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="Java编码实现ActiveMQ通信"><a href="#Java编码实现ActiveMQ通信" class="headerlink" title="Java编码实现ActiveMQ通信"></a>Java编码实现ActiveMQ通信</h1><h2 id="建立maven工程"><a href="#建立maven工程" class="headerlink" title="建立maven工程"></a>建立maven工程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.rocket&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;test_activemq&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF<span class="number">-8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;<span class="number">1.8</span>&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.targer&gt;<span class="number">1.8</span>&lt;/maven.compiler.targer&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--activemq需要的jav包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">5.15</span><span class="number">.9</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">3.16</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--下面是junit/log4等通用配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.7</span><span class="number">.25</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.2</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.16</span><span class="number">.18</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">4.12</span>&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>ActiveMQ中的目的地有两种：<strong>queue和topic</strong>，其中队列是点对点的传输，只能有一个接收方，而topic可以有多个接收方，只要再发布消息之前订阅了该topic就可以接收到，并且实现了“负载均衡”，即多个接受者间隔接受。<br><img src="https://img-blog.csdnimg.cn/20191217194057953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="点对点传输"><a href="#点对点传输" class="headerlink" title="点对点传输"></a>点对点传输</h2><p>在点对点传输下，目的地为队列queue。</p>
<h3 id="生产者编码"><a href="#生产者编码" class="headerlink" title="生产者编码"></a>生产者编码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.activemq.<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @ClassName JmsProduce</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsProduce</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final String URL = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final String queue_name = <span class="string">"queue01"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接工厂</span></span><br><span class="line">        ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(URL);</span><br><span class="line">        <span class="comment">//利用工厂获取connection，并开始连接</span></span><br><span class="line">        Connection connection = factory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line">		<span class="comment">//创建会话session，两个参数：事务和签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>,Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//创建目的地Destination</span></span><br><span class="line">        Queue <span class="built_in">queue</span> = session.createQueue(queue_name);</span><br><span class="line">        <span class="comment">//创建生产者</span></span><br><span class="line">        MessageProducer producer = session.createProducer(<span class="built_in">queue</span>);</span><br><span class="line">		<span class="comment">//生产者发送消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">"mag..."</span> + i);</span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">"生产者生产数据成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行生产者代码之后ActiveMQ控制台如下所示：<br><img src="https://img-blog.csdnimg.cn/20191217194919499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="消费者编码"><a href="#消费者编码" class="headerlink" title="消费者编码"></a>消费者编码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ</span></span><br><span class="line"><span class="comment"> * JMS（Java Message Service）的生产者编码</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConsumer</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String ACTIVE_MQ = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String QUEUE_NAME = <span class="string">"queue01"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws JMSException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者01"</span>);</span><br><span class="line">        ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVE_MQ);</span><br><span class="line">        Connection connection = factory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Queue <span class="built_in">queue</span> = session.createQueue(QUEUE_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(<span class="built_in">queue</span>);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       同步阻塞方式receive()</span></span><br><span class="line"><span class="comment">        while (true) &#123;</span></span><br><span class="line"><span class="comment">            TextMessage message = (TextMessage) consumer.receive();</span></span><br><span class="line"><span class="comment">            if (null != message) &#123;</span></span><br><span class="line"><span class="comment">                System.out.println("消费者受到消息，内容是：" + message.getText());</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        consumer.close();</span></span><br><span class="line"><span class="comment">        session.close();</span></span><br><span class="line"><span class="comment">        connection.close();*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//监听器方式</span></span><br><span class="line">        consumer.setMessageListener(<span class="keyword">new</span> MessageListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> onMessage(Message message) &#123;</span><br><span class="line">                <span class="keyword">if</span> (null != message &amp;&amp; message instanceof TextMessage) &#123;</span><br><span class="line">                    TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"msg-----"</span> + textMessage.getText());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.in.read();</span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者消息的接受存在两种方式，一种是同步阻塞方式，另一种是监听器方式。<br>同步阻塞方式中有receive()和receive(long time)两个方法，没有消息阻塞在这里或者没有消息超过一定时间之后退出。监听器方式为设置一个监听器，监听是否有消息传送过来。</p>
<h2 id="基于发布订阅"><a href="#基于发布订阅" class="headerlink" title="基于发布订阅"></a>基于发布订阅</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu;</span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ</span></span><br><span class="line"><span class="comment"> * JMS（Java Message Service）的生产者编码</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsProduceTopic</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String ACTIVE_URL = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String TOPIC_NAME = <span class="string">"topic-01"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throws JMSException </span>&#123;</span><br><span class="line">        <span class="comment">//创建连接工厂，按照指定的url地址，采用默认用户名和密码</span></span><br><span class="line">        ActiveMQConnectionFactory activeMQConnectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVE_URL);</span><br><span class="line">        <span class="comment">//通过连接工厂创建连接，并启动访问</span></span><br><span class="line">        Connection connection = activeMQConnectionFactory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line">        <span class="comment">//创建回话session，两个参数：事务和签收</span></span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        <span class="comment">//常见目的地（队列或queue者主题topic）</span></span><br><span class="line">        Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">        <span class="comment">//创建生产者</span></span><br><span class="line">        MessageProducer producer = session.createProducer(topic);</span><br><span class="line">        <span class="comment">//使用MessageProducer生产3条消息发送到MQ的队列里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建消息</span></span><br><span class="line">            TextMessage textMessage = session.createTextMessage(<span class="string">"msg------"</span> + i);</span><br><span class="line">            <span class="comment">//通过生产者MessageProducer发送给MQ</span></span><br><span class="line">            producer.send(textMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        producer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.activemq.ActiveMQConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ActiveMQ</span></span><br><span class="line"><span class="comment"> * JMS（Java Message Service）的消费者编码</span></span><br><span class="line"><span class="comment"> * @author xxy</span></span><br><span class="line"><span class="comment"> * @date 2019/12/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConsumerTopic</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String ACTIVEMQ_URL = <span class="string">"tcp://192.168.0.119:61616"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final String TOPIC_NAME = <span class="string">"topic-01"</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JMSException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">"消费者TOPIC-3"</span>);</span><br><span class="line">        ActiveMQConnectionFactory factory = <span class="keyword">new</span> ActiveMQConnectionFactory(ACTIVEMQ_URL);</span><br><span class="line">        Connection connection = factory.createConnection();</span><br><span class="line">        connection.start();</span><br><span class="line">        Session session = connection.createSession(<span class="literal">false</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line">        Topic topic = session.createTopic(TOPIC_NAME);</span><br><span class="line">        MessageConsumer consumer = session.createConsumer(topic);</span><br><span class="line">        <span class="comment">//监听器方式</span></span><br><span class="line">        consumer.setMessageListener((message) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (null != message &amp;&amp; message instanceof TextMessage) &#123;</span><br><span class="line">                TextMessage textMessage = (TextMessage) message;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"msg-----"</span> + textMessage.getText());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.in.read();</span><br><span class="line">        consumer.close();</span><br><span class="line">        session.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="queue和topic两种模式的对比"><a href="#queue和topic两种模式的对比" class="headerlink" title="queue和topic两种模式的对比"></a>queue和topic两种模式的对比</h2><p><img src="https://img-blog.csdnimg.cn/20191217201149319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDEzNTkw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="youngyang"
    src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">youngyang</p>
  <div class="site-description" itemprop="description">Record what you want!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xyoungyang" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;xyoungyang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_42013590" title="CSDN &amp;rarr; https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_42013590" rel="noopener" target="_blank"><i class="fa fa-fw fa-crosshairs"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">youngyang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">226k</span>
</div>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
<span id="busuanzi_container_site_uv">
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>

</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":true},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>

